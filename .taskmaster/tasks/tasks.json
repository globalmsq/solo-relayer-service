{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "프로젝트 모노레포 구조 및 Docker Compose 인프라 설정",
        "description": "OZ Relayer v1.3.0 + Redis를 포함한 Docker Compose 기반 개발 환경과 NestJS 모노레포 구조를 구축합니다. (Phase 1 - MySQL 제외)",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "details": "## 구현 세부사항 (v11.2 기준)\n\n### 1. 디렉토리 구조 생성\n```\nmsq-relayer-service/\n├── docker/                          # Docker 관련 파일 전용 디렉토리\n│   ├── Dockerfile.packages          # 멀티스테이지 빌드 (api-gateway tsx 실행)\n│   ├── docker-compose.yaml          # Hardhat Node 로컬 개발 설정\n│   ├── docker-compose-amoy.yaml     # Polygon Amoy Testnet 설정\n│   ├── config/\n│   │   └── oz-relayer/              # OZ Relayer 설정 파일\n│   │       ├── relayer-1.json       # Relayer #1 설정\n│   │       ├── relayer-2.json       # Relayer #2 설정\n│   │       └── relayer-3.json       # Relayer #3 설정\n│   ├── keys-example/                # 샘플 키스토어 (Git 포함, Hardhat #10,11,12)\n│   │   ├── relayer-1/keystore.json\n│   │   ├── relayer-2/keystore.json\n│   │   └── relayer-3/keystore.json\n│   └── keys/                        # 실제 키스토어 (.gitignore)\n│       ├── relayer-1/keystore.json\n│       ├── relayer-2/keystore.json\n│       └── relayer-3/keystore.json\n├── packages/\n│   ├── api-gateway/     # NestJS 10.x\n│   ├── contracts/       # Hardhat\n│   └── examples/        # 통합 예제\n├── scripts/\n│   ├── health-check.sh\n│   └── test-infra.sh\n└── docs/\n    ├── product.md\n    ├── structure.md\n    └── tech.md\n```\n\n### 2. Docker Compose 서비스 정의 (Phase 1)\n\n#### Phase 1 필수 서비스\n- **hardhat-node**: 로컬 블록체인 (Chain ID: 31337, Port 8545)\n- **api-gateway**: NestJS API Gateway (Port 3000)\n- **oz-relayer-1~3**: Multi-Relayer Pool (YAML Anchors 패턴)\n  - Ports: 8081-8083:8080, 8091-8093:8081\n  - Volumes: ./config/oz-relayer/relayer-N.json, ./keys/relayer-N (read-only)\n- **redis**: `redis:8.0-alpine` (Port 6379, AOF 퍼시스턴스)\n\n#### Phase 2+ 서비스 (프로필 분리)\n- **oz-monitor**: 이벤트 모니터링 (profiles: [\"phase2\"])\n- **prometheus**: 메트릭 수집 (profiles: [\"phase2\"])\n- **grafana**: 대시보드 (profiles: [\"phase2\"])\n\n### 3. YAML Anchors 패턴 (중복 제거)\n\n```yaml\nx-relayer-common: &relayer-common\n  image: ghcr.io/openzeppelin/openzeppelin-relayer:v1.3.0\n  environment: &relayer-env\n    RUST_LOG: info\n    KEYSTORE_PASSPHRASE: hardhat-test-passphrase\n    RPC_URL: http://hardhat-node:8545\n    REDIS_HOST: redis\n    REDIS_PORT: 6379\n  depends_on: [redis, hardhat-node]\n\nservices:\n  oz-relayer-1:\n    <<: *relayer-common\n    ports: [\"8081:8080\", \"8091:8081\"]\n    volumes:\n      - ./config/oz-relayer/relayer-1.json:/app/config/config.json:ro\n      - ./keys/relayer-1:/app/config/keys:ro\n    environment:\n      <<: *relayer-env\n      API_KEY: test-api-key-relayer-1\n```\n\n**이유**: 각 Relayer는 고유 Private Key가 필요하여 `deploy.replicas` 사용 불가 (Nonce 충돌 방지)\n\n### 4. OZ Relayer config.json 예시\n\n```json\n{\n  \"relayers\": [{\n    \"id\": \"polygon-relayer-1\",\n    \"name\": \"Polygon Amoy Relayer #1\",\n    \"network\": \"amoy\",\n    \"signer\": {\n      \"type\": \"local\",\n      \"keystore\": \"/app/config/keys/relayer-1.json\"\n    },\n    \"rpc\": {\n      \"url\": \"${AMOY_RPC_URL}\",\n      \"timeout\": 30000\n    },\n    \"policies\": {\n      \"gas_price_cap\": \"500000000000\",\n      \"min_balance\": \"100000000000000000\",\n      \"max_pending_txs\": 10\n    },\n    \"notifications\": [{\n      \"type\": \"webhook\",\n      \"url\": \"http://api-gateway:3000/api/v1/webhook/relayer\",\n      \"signing_key\": \"${WEBHOOK_SIGNING_KEY}\"\n    }]\n  }]\n}\n```\n\n### 5. 환경 변수 (docker-compose.yaml 내 직접 명시)\n\n**Phase 1 필수 환경변수** (.env 파일 사용 금지):\n- AMOY_RPC_URL, POLYGON_RPC_URL\n- OZ_RELAYER_API_KEY\n- KEYSTORE_PASSPHRASE\n- WEBHOOK_SIGNING_KEY (Phase 2+)\n- API_GATEWAY_API_KEY (단일 환경변수 인증)\n\n**Phase 2+ 환경변수** (미사용):\n- DB_PASSWORD, DB_ROOT_PASSWORD (MySQL)\n\n### 6. Redis 설정 (Phase 1 필수)\n\n```yaml\nredis:\n  image: redis:8.0-alpine\n  ports: [\"6379:6379\"]\n  command: redis-server --appendonly yes\n  volumes:\n    - msq-relayer-redis-data:/data\n```\n\n- AOF(Append-Only File) 퍼시스턴스 활성화\n- Named Volume: msq-relayer-redis-data\n- OZ Relayer 내부 Queue 용도",
        "testStrategy": "1. `cd docker && docker compose up -d` 실행 후 Phase 1 필수 서비스 healthy 상태 확인\n   - hardhat-node\n   - api-gateway\n   - oz-relayer-1, oz-relayer-2, oz-relayer-3\n   - redis\n2. `curl http://localhost:8545` - Hardhat Node JSON-RPC 정상 응답 확인\n3. `curl http://localhost:3000/api/v1/health` - API Gateway health check\n4. `curl http://localhost:8081/api/v1/health` - OZ Relayer #1 health check\n5. `curl http://localhost:8082/api/v1/health` - OZ Relayer #2 health check\n6. `curl http://localhost:8083/api/v1/health` - OZ Relayer #3 health check\n7. Redis 연결 테스트: `redis-cli ping` (PONG 응답 확인)\n8. 각 컨테이너 로그에 에러 없음 확인 (`docker compose logs`)\n9. Phase 2+ 서비스는 시작되지 않음 확인 (oz-monitor, prometheus, grafana)\n10. MySQL 관련 컨테이너 없음 확인",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "NestJS API Gateway 프로젝트 스캐폴드 및 기본 모듈 구성",
        "description": "NestJS 10.x 기반 API Gateway 프로젝트를 생성하고, 핵심 모듈(Auth, Relay, Webhook, OZ-Relayer)의 기본 구조를 설정합니다. (Phase 1: DB 없이 OZ Relayer + Redis만 사용)",
        "status": "pending",
        "dependencies": [
          1
        ],
        "priority": "high",
        "details": "## 구현 세부사항 (Phase 1 - DB 없이 Redis만 사용)\n\n### 1. NestJS 프로젝트 생성\n```bash\ncd packages/api-gateway\nnpx @nestjs/cli new . --skip-git --package-manager npm\n```\n\n### 2. 필수 의존성 설치 (Phase 1)\n```json\n{\n  \"dependencies\": {\n    \"@nestjs/common\": \"^10.0.0\",\n    \"@nestjs/core\": \"^10.0.0\",\n    \"@nestjs/config\": \"^3.0.0\",\n    \"@nestjs/swagger\": \"^7.0.0\",\n    \"ethers\": \"^6.0.0\",\n    \"class-validator\": \"^0.14.0\",\n    \"class-transformer\": \"^0.5.0\",\n    \"ioredis\": \"^5.0.0\",\n    \"helmet\": \"^7.0.0\"\n  }\n}\n```\n\n**주의**: Prisma 관련 의존성은 Phase 2+에서 추가 예정\n- `@prisma/client`는 제외 (Phase 1에는 DB 없음)\n- `prisma` devDependency도 제외\n\n### 3. 모듈 구조 생성 (Phase 1)\n```\nsrc/\n├── auth/              # API Key 인증\n│   ├── auth.module.ts\n│   ├── guards/\n│   │   └── api-key.guard.ts\n│   └── decorators/\n│       └── public.decorator.ts\n├── relay/             # TX 엔드포인트\n│   ├── relay.module.ts\n│   ├── direct/\n│   ├── gasless/\n│   └── status/\n├── oz-relayer/        # OZ Relayer 클라이언트\n│   ├── oz-relayer.module.ts\n│   ├── oz-relayer.service.ts\n│   └── relayer-pool.service.ts\n├── common/\n│   ├── filters/exception.filter.ts\n│   ├── interceptors/logging.interceptor.ts\n│   └── decorators/\n├── config/\n│   └── configuration.ts\n└── main.ts\n```\n\n**Phase 2+ 예정 디렉토리** (Phase 1에는 생성하지 않음):\n- `webhook/` - OZ Relayer Webhook 핸들러\n- `prisma/` - DB 스키마\n- `queue/` - Queue System\n- `policy/` - Policy Engine\n\n### 4. 환경 설정 (config/configuration.ts)\n```typescript\nexport default () => ({\n  port: parseInt(process.env.PORT, 10) || 3000,\n  nodeEnv: process.env.NODE_ENV || 'development',\n  apiKey: process.env.API_GATEWAY_API_KEY,  // Phase 1 단일 API Key\n  redis: {\n    url: process.env.REDIS_URL || 'redis://localhost:6379'\n  },\n  rpc: {\n    url: process.env.RPC_URL || 'http://localhost:8545'\n  },\n  relayerPool: {\n    configPath: process.env.RELAYER_POOL_CONFIG || './config/relayer-pool.yaml'\n  }\n});\n```\n\n### 5. Swagger/OpenAPI 설정 (main.ts)\n```typescript\nimport { NestFactory } from '@nestjs/core';\nimport { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';\nimport { ValidationPipe } from '@nestjs/common';\nimport helmet from 'helmet';\nimport { AppModule } from './app.module';\n\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n  \n  // Security\n  app.use(helmet());\n  \n  // Validation\n  app.useGlobalPipes(new ValidationPipe({\n    whitelist: true,\n    forbidNonWhitelisted: true,\n    transform: true\n  }));\n  \n  // Swagger/OpenAPI\n  const config = new DocumentBuilder()\n    .setTitle('MSQ Relayer API')\n    .setDescription('Blockchain Transaction Relayer System (Phase 1)')\n    .setVersion('1.0')\n    .addApiKey({ type: 'apiKey', name: 'X-API-Key', in: 'header' })\n    .build();\n  const document = SwaggerModule.createDocument(app, config);\n  SwaggerModule.setup('api/docs', app, document);\n  \n  const port = process.env.PORT || 3000;\n  await app.listen(port);\n  console.log(`API Gateway listening on port ${port}`);\n}\nbootstrap();\n```\n\n### 6. Dockerfile (packages/api-gateway/Dockerfile)\n**참고**: 실제로는 `docker/Dockerfile.packages`의 멀티스테이지 빌드에서 처리됩니다.\n\n```dockerfile\nFROM node:20-alpine AS builder\nWORKDIR /app\nCOPY package*.json ./\nRUN npm ci\nCOPY . .\nRUN npm run build\n\nFROM node:20-alpine\nWORKDIR /app\nCOPY --from=builder /app/dist ./dist\nCOPY --from=builder /app/node_modules ./node_modules\nCOPY --from=builder /app/package*.json ./\nENV NODE_ENV=production\nCMD [\"node\", \"dist/main.js\"]\n```\n\n### 7. Phase 1 체크리스트\n- ✅ NestJS 프로젝트 생성 (DB 없이)\n- ✅ Auth 모듈 (API Key 단일 환경변수)\n- ✅ Relay 모듈 (Direct/Gasless 디렉토리 생성)\n- ✅ OZ-Relayer 모듈 (Relayer Pool 지원)\n- ✅ Config 모듈 (Redis + RPC만)\n- ✅ Swagger/OpenAPI 문서화\n- ✅ Helmet 보안 헤더\n- ✅ Global Validation Pipe\n- ❌ Prisma 제외 (Phase 2+)\n- ❌ MySQL 연결 제외 (Phase 2+)\n- ❌ Webhook 모듈 제외 (Phase 2+)\n- ❌ Queue 모듈 제외 (Phase 2+)",
        "testStrategy": "1. `npm run start:dev` - 서버 정상 시작 확인 (DB 연결 없음)\n2. `curl http://localhost:3000/api/docs` - Swagger UI 접근 확인\n3. 모든 모듈 DI 컨테이너 정상 로드 확인 (Auth, Relay, OZ-Relayer만)\n4. `npm run lint` - 린트 에러 없음\n5. `npm run build` - 빌드 성공 확인\n6. Redis 연결 확인 (REDIS_URL 환경변수)\n7. Prisma/MySQL 연결 시도 없음 확인 (Phase 1 제약사항)\n8. package.json에 @prisma/client 없음 확인",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "API Key 인증 모듈 및 Guard 구현",
        "description": "Phase 1 단일 환경변수 기반 API Key 인증 시스템을 구현합니다. NestJS Guard를 사용하여 X-API-Key 헤더 검증 로직을 작성하고, 환경변수 API_GATEWAY_API_KEY와 비교하여 인증을 처리합니다.",
        "status": "pending",
        "dependencies": [
          2
        ],
        "priority": "high",
        "details": "## Phase 1 요구사항 (v11.2 기준)\n\n### 인증 방식\n- **환경변수**: `API_GATEWAY_API_KEY` (단일 키)\n- **Header**: `X-API-Key: {api_key}`\n- **검증 방식**: 환경변수 값과 헤더 값 직접 비교\n- **Phase 2+ 확장**: DB 기반 다중 API Key 관리, Client별 권한, 로테이션\n\n### 디렉토리 구조\n```\npackages/api-gateway/src/auth/\n├── auth.module.ts              # Global Guard 등록\n├── guards/\n│   └── api-key.guard.ts        # X-API-Key 검증 Guard\n└── decorators/\n    └── public.decorator.ts     # @Public() 데코레이터 (Health Check 등)\n```\n\n## 구현 세부사항\n\n### 1. API Key Guard 구현\n```typescript\n// auth/guards/api-key.guard.ts\nimport {\n  Injectable,\n  CanActivate,\n  ExecutionContext,\n  UnauthorizedException,\n} from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\nimport { Reflector } from '@nestjs/core';\nimport { IS_PUBLIC_KEY } from '../decorators/public.decorator';\n\n@Injectable()\nexport class ApiKeyGuard implements CanActivate {\n  constructor(\n    private readonly configService: ConfigService,\n    private readonly reflector: Reflector,\n  ) {}\n\n  canActivate(context: ExecutionContext): boolean {\n    // @Public() 데코레이터가 적용된 엔드포인트는 인증 스킵\n    const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [\n      context.getHandler(),\n      context.getClass(),\n    ]);\n    if (isPublic) {\n      return true;\n    }\n\n    const request = context.switchToHttp().getRequest();\n    const apiKey = request.headers['x-api-key'];\n    \n    if (!apiKey) {\n      throw new UnauthorizedException('API Key is required');\n    }\n    \n    return this.validateApiKey(apiKey);\n  }\n\n  private validateApiKey(apiKey: string): boolean {\n    const validApiKey = this.configService.get<string>('API_GATEWAY_API_KEY');\n    \n    if (!validApiKey) {\n      throw new Error('API_GATEWAY_API_KEY environment variable is not configured');\n    }\n    \n    if (apiKey !== validApiKey) {\n      throw new UnauthorizedException('Invalid API Key');\n    }\n    \n    return true;\n  }\n}\n```\n\n### 2. Public 데코레이터\n```typescript\n// auth/decorators/public.decorator.ts\nimport { SetMetadata } from '@nestjs/common';\n\nexport const IS_PUBLIC_KEY = 'isPublic';\nexport const Public = () => SetMetadata(IS_PUBLIC_KEY, true);\n```\n\n### 3. Auth 모듈 및 Global Guard 등록\n```typescript\n// auth/auth.module.ts\nimport { Module } from '@nestjs/common';\nimport { APP_GUARD } from '@nestjs/core';\nimport { ConfigModule } from '@nestjs/config';\nimport { ApiKeyGuard } from './guards/api-key.guard';\n\n@Module({\n  imports: [ConfigModule],\n  providers: [\n    {\n      provide: APP_GUARD,\n      useClass: ApiKeyGuard,\n    },\n  ],\n})\nexport class AuthModule {}\n```\n\n### 4. 환경변수 설정\n```typescript\n// .env.example (개발 참고용)\nAPI_GATEWAY_API_KEY=msq-dev-api-key-12345\n\n// Docker Compose 예시 (docker/docker-compose.yaml)\napi-gateway:\n  environment:\n    API_GATEWAY_API_KEY: \"msq-dev-api-key-12345\"\n```\n\n### 5. Health Check 엔드포인트에 @Public() 적용\n```typescript\n// health/health.controller.ts\nimport { Controller, Get } from '@nestjs/common';\nimport { Public } from '../auth/decorators/public.decorator';\n\n@Controller('api/v1/health')\nexport class HealthController {\n  @Get()\n  @Public()  // 인증 없이 접근 가능\n  async check() {\n    return {\n      'api-gateway': 'healthy',\n      'oz-relayer': 'healthy',\n      'redis': 'healthy',\n    };\n  }\n}\n```\n\n### 6. Swagger 문서화\n```typescript\n// main.ts (Swagger 설정)\nimport { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';\n\nconst config = new DocumentBuilder()\n  .setTitle('MSQ Relayer Service API')\n  .setDescription('Blockchain Transaction Relayer API')\n  .setVersion('1.0')\n  .addApiKey(\n    {\n      type: 'apiKey',\n      name: 'X-API-Key',\n      in: 'header',\n      description: 'API Key for authentication',\n    },\n    'X-API-Key',\n  )\n  .build();\n\nconst document = SwaggerModule.createDocument(app, config);\nSwaggerModule.setup('api/docs', app, document);\n```\n\n## Phase 2+ 확장 계획\n\n확장 기능 (현재 구현하지 않음):\n- DB 기반 다중 API Key 관리 (생성/취소/로테이션)\n- Client Service별 권한 관리 (permissions)\n- API Key 사용량 추적 (metrics)\n- Rate Limiting 연동\n- API Key 만료 기능",
        "testStrategy": "## 테스트 전략\n\n### 1. 단위 테스트 (api-key.guard.spec.ts)\n```typescript\ndescribe('ApiKeyGuard', () => {\n  let guard: ApiKeyGuard;\n  let configService: ConfigService;\n  let reflector: Reflector;\n\n  beforeEach(() => {\n    configService = {\n      get: jest.fn().mockReturnValue('test-api-key-12345'),\n    } as any;\n    reflector = { getAllAndOverride: jest.fn() } as any;\n    guard = new ApiKeyGuard(configService, reflector);\n  });\n\n  it('@Public() 데코레이터 적용 시 인증 스킵', () => {\n    jest.spyOn(reflector, 'getAllAndOverride').mockReturnValue(true);\n    const context = createMockContext({});\n    expect(guard.canActivate(context)).toBe(true);\n  });\n\n  it('X-API-Key 헤더 없으면 401 UnauthorizedException', () => {\n    jest.spyOn(reflector, 'getAllAndOverride').mockReturnValue(false);\n    const context = createMockContext({});\n    expect(() => guard.canActivate(context)).toThrow(UnauthorizedException);\n  });\n\n  it('잘못된 API Key는 401 UnauthorizedException', () => {\n    jest.spyOn(reflector, 'getAllAndOverride').mockReturnValue(false);\n    const context = createMockContext({ 'x-api-key': 'invalid-key' });\n    expect(() => guard.canActivate(context)).toThrow(UnauthorizedException);\n  });\n\n  it('올바른 API Key는 통과', () => {\n    jest.spyOn(reflector, 'getAllAndOverride').mockReturnValue(false);\n    const context = createMockContext({ 'x-api-key': 'test-api-key-12345' });\n    expect(guard.canActivate(context)).toBe(true);\n  });\n\n  it('API_GATEWAY_API_KEY 환경변수 미설정 시 에러', () => {\n    jest.spyOn(configService, 'get').mockReturnValue(undefined);\n    jest.spyOn(reflector, 'getAllAndOverride').mockReturnValue(false);\n    const context = createMockContext({ 'x-api-key': 'any-key' });\n    expect(() => guard.canActivate(context)).toThrow('API_GATEWAY_API_KEY');\n  });\n});\n```\n\n### 2. E2E 테스트 (auth.e2e-spec.ts)\n```typescript\ndescribe('API Key Authentication (e2e)', () => {\n  let app: INestApplication;\n\n  beforeAll(async () => {\n    const moduleFixture = await Test.createTestingModule({\n      imports: [AppModule],\n    }).compile();\n\n    app = moduleFixture.createNestApplication();\n    await app.init();\n  });\n\n  it('GET /api/v1/health는 인증 없이 접근 가능 (@Public)', () => {\n    return request(app.getHttpServer())\n      .get('/api/v1/health')\n      .expect(200);\n  });\n\n  it('POST /api/v1/relay/direct - X-API-Key 없으면 401', () => {\n    return request(app.getHttpServer())\n      .post('/api/v1/relay/direct')\n      .send({ to: '0x...', data: '0x...' })\n      .expect(401);\n  });\n\n  it('POST /api/v1/relay/direct - 잘못된 API Key는 401', () => {\n    return request(app.getHttpServer())\n      .post('/api/v1/relay/direct')\n      .set('X-API-Key', 'invalid-key')\n      .send({ to: '0x...', data: '0x...' })\n      .expect(401);\n  });\n\n  it('POST /api/v1/relay/direct - 올바른 API Key는 통과', () => {\n    return request(app.getHttpServer())\n      .post('/api/v1/relay/direct')\n      .set('X-API-Key', process.env.API_GATEWAY_API_KEY)\n      .send({ to: '0x...', data: '0x...' })\n      .expect(201);\n  });\n});\n```\n\n### 3. 검증 항목\n1. ✅ API Key 없이 요청 시 401 Unauthorized 응답 확인\n2. ✅ 잘못된 API Key로 요청 시 401 응답 확인\n3. ✅ 올바른 API Key로 요청 시 정상 응답 확인\n4. ✅ @Public() 데코레이터 적용 엔드포인트는 인증 없이 접근 가능 확인\n5. ✅ 환경변수 API_GATEWAY_API_KEY 미설정 시 서버 시작 실패 확인\n6. ✅ Swagger UI에서 X-API-Key 헤더 입력 가능 확인\n7. ✅ Header는 대소문자 구분 없음 (x-api-key, X-API-Key 모두 동작) 확인",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Health Check 엔드포인트 구현",
        "description": "API Gateway, OZ Relayer, Redis 상태를 확인하는 Health Check API를 구현합니다. (Phase 1: MySQL 제외)",
        "status": "pending",
        "dependencies": [
          2
        ],
        "priority": "high",
        "details": "## 구현 세부사항 (Phase 1 - OZ Relayer + Redis만 해당)\n\n### 1. @nestjs/terminus 설치\n```bash\nnpm install @nestjs/terminus\n```\n\n### 2. Health Controller 구현\n```typescript\n// health/health.controller.ts\n@Controller('api/v1/health')\nexport class HealthController {\n  constructor(\n    private health: HealthCheckService,\n    private http: HttpHealthIndicator,\n    private ozRelayer: OzRelayerHealthIndicator,\n  ) {}\n\n  @Get()\n  @Public()\n  @HealthCheck()\n  async check() {\n    return this.health.check([\n      () => this.http.pingCheck('redis', 'redis://redis:6379'),\n      () => this.ozRelayer.isHealthy('oz-relayer'),\n    ]);\n  }\n}\n```\n\n### 3. OZ Relayer Health Indicator\n```typescript\n// health/oz-relayer.health.ts\n@Injectable()\nexport class OzRelayerHealthIndicator extends HealthIndicator {\n  constructor(private readonly httpService: HttpService) {\n    super();\n  }\n\n  async isHealthy(key: string): Promise<HealthIndicatorResult> {\n    try {\n      const response = await firstValueFrom(\n        this.httpService.get('http://oz-relayer:8080/api/v1/health')\n      );\n      const isHealthy = response.status === 200;\n      return this.getStatus(key, isHealthy, { status: response.data });\n    } catch (error) {\n      return this.getStatus(key, false, { error: error.message });\n    }\n  }\n}\n```\n\n### 4. 응답 형식 (Phase 1)\n```json\n{\n  \"status\": \"ok\",\n  \"info\": {\n    \"api-gateway\": { \"status\": \"up\" },\n    \"oz-relayer\": { \"status\": \"up\" },\n    \"redis\": { \"status\": \"up\" }\n  },\n  \"error\": {},\n  \"details\": { ... }\n}\n```\n\n### 5. Phase 1 제약사항\n- MySQL/Prisma health check는 Phase 2+에서 구현\n- Health check 대상: OZ Relayer + Redis만\n- DB 연결 상태 확인 로직 제외",
        "testStrategy": "1. `GET /api/v1/health` - 모든 서비스 healthy 시 200 OK 반환\n2. OZ Relayer 다운 시 degraded 상태 반환\n3. Redis 연결 실패 시 에러 상세 정보 포함\n4. 각 서비스별 개별 상태 정보 확인 (api-gateway, oz-relayer, redis)\n5. MySQL 연결 시도 없음 확인 (Phase 1 제약사항)\n6. 응답 포맷이 Phase 1 구조를 따르는지 검증",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "OZ Relayer 프록시 서비스 및 Multi-Relayer Pool 관리자 구현",
        "description": "OZ Relayer SDK 래퍼 서비스를 구현하고, Multi-Relayer Pool에서 Load Balancing(Round Robin/Least Load) 및 Health Check 로직을 구현합니다.",
        "details": "## 구현 세부사항\n\n### 1. relayer-pool.yaml 설정\n```yaml\nrelayer_pool:\n  strategy: \"round_robin\"  # round_robin | least_load\n  health_check:\n    interval_ms: 10000\n    timeout_ms: 5000\n    unhealthy_threshold: 3\n  relayers:\n    - id: \"relayer-1\"\n      url: \"http://oz-relayer-1:8080\"\n      api_key: \"${OZ_RELAYER_1_API_KEY}\"\n      priority: 1\n```\n\n### 2. Relayer Pool Service\n```typescript\n// oz-relayer/relayer-pool.service.ts\n@Injectable()\nexport class RelayerPoolService {\n  private relayers: RelayerInstance[] = [];\n  private currentIndex = 0;\n\n  async getHealthyRelayer(): Promise<RelayerInstance> {\n    const healthy = this.relayers.filter(r => r.isHealthy);\n    if (healthy.length === 0) {\n      throw new ServiceUnavailableException('No healthy relayers available');\n    }\n    \n    if (this.strategy === 'round_robin') {\n      return this.roundRobinSelect(healthy);\n    }\n    return this.leastLoadSelect(healthy);\n  }\n\n  private roundRobinSelect(relayers: RelayerInstance[]): RelayerInstance {\n    const relayer = relayers[this.currentIndex % relayers.length];\n    this.currentIndex++;\n    return relayer;\n  }\n\n  private leastLoadSelect(relayers: RelayerInstance[]): RelayerInstance {\n    return relayers.reduce((min, r) => \n      r.pendingTxCount < min.pendingTxCount ? r : min\n    );\n  }\n}\n```\n\n### 3. OZ Relayer Client Service\n```typescript\n// oz-relayer/oz-relayer.service.ts\n@Injectable()\nexport class OzRelayerService {\n  constructor(\n    private readonly httpService: HttpService,\n    private readonly poolService: RelayerPoolService,\n  ) {}\n\n  async sendTransaction(request: DirectTxRequest): Promise<TxResponse> {\n    const relayer = await this.poolService.getHealthyRelayer();\n    const response = await firstValueFrom(\n      this.httpService.post(\n        `${relayer.url}/api/v1/relayers/${relayer.id}/transactions`,\n        request,\n        { headers: { 'Authorization': `Bearer ${relayer.apiKey}` } }\n      )\n    );\n    return response.data;\n  }\n\n  async getTransactionStatus(txId: string): Promise<TxStatus> {\n    // 모든 relayer에서 조회 시도\n  }\n}\n```\n\n### 4. Health Check Scheduler\n```typescript\n@Injectable()\nexport class RelayerHealthScheduler {\n  @Cron('*/10 * * * * *')  // 10초마다\n  async checkRelayerHealth() {\n    for (const relayer of this.relayers) {\n      try {\n        const response = await this.httpService.get(\n          `${relayer.url}/api/v1/health`,\n          { timeout: 5000 }\n        );\n        relayer.isHealthy = response.status === 200;\n        relayer.failCount = 0;\n      } catch {\n        relayer.failCount++;\n        if (relayer.failCount >= 3) {\n          relayer.isHealthy = false;\n        }\n      }\n    }\n  }\n}\n```",
        "testStrategy": "1. Round Robin 전략: 순차적으로 다른 Relayer 선택 확인\n2. Least Load 전략: 대기 TX 가장 적은 Relayer 선택 확인\n3. Relayer 다운 시 자동으로 다른 Relayer로 전환 확인\n4. 모든 Relayer 다운 시 503 Service Unavailable 반환\n5. Health Check 스케줄러 정상 동작 확인",
        "priority": "high",
        "dependencies": [
          "2",
          "4"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Direct Transaction API 엔드포인트 구현",
        "description": "POST /api/v1/relay/direct 엔드포인트를 구현하여 OZ Relayer를 통한 Direct Transaction 전송 기능을 제공합니다.",
        "details": "## 구현 세부사항\n\n### 1. DTO 정의\n```typescript\n// relay/direct/dto/direct-tx.dto.ts\nexport class DirectTxRequestDto {\n  @ApiProperty({ description: '대상 컨트랙트 주소' })\n  @IsEthereumAddress()\n  to: string;\n\n  @ApiProperty({ description: 'Encoded function call' })\n  @IsHexadecimal()\n  data: string;\n\n  @ApiPropertyOptional({ description: 'ETH 전송량 (wei)' })\n  @IsOptional()\n  @IsNumberString()\n  value?: string;\n\n  @ApiPropertyOptional({ enum: ['safeLow', 'average', 'fast', 'fastest'] })\n  @IsOptional()\n  @IsIn(['safeLow', 'average', 'fast', 'fastest'])\n  speed?: string;\n\n  @ApiPropertyOptional()\n  @IsOptional()\n  @IsNumber()\n  gasLimit?: number;\n\n  @ApiPropertyOptional()\n  @IsOptional()\n  metadata?: Record<string, any>;\n}\n\nexport class DirectTxResponseDto {\n  @ApiProperty()\n  txId: string;\n\n  @ApiProperty()\n  txHash: string;\n\n  @ApiProperty({ enum: ['pending', 'sent', 'submitted', 'inmempool', 'mined', 'confirmed', 'failed'] })\n  status: string;\n\n  @ApiProperty()\n  from: string;\n\n  @ApiProperty()\n  nonce: number;\n\n  @ApiPropertyOptional()\n  gasPrice?: string;\n}\n```\n\n### 2. Controller 구현\n```typescript\n// relay/direct/direct.controller.ts\n@Controller('api/v1/relay')\n@ApiTags('Relay')\nexport class DirectController {\n  constructor(private readonly directService: DirectService) {}\n\n  @Post('direct')\n  @ApiOperation({ summary: 'Direct Transaction 전송' })\n  @ApiResponse({ status: 201, type: DirectTxResponseDto })\n  async sendDirectTransaction(\n    @Body() dto: DirectTxRequestDto,\n  ): Promise<ApiResponse<DirectTxResponseDto>> {\n    const result = await this.directService.send(dto);\n    return { success: true, data: result };\n  }\n}\n```\n\n### 3. Service 구현\n```typescript\n// relay/direct/direct.service.ts\n@Injectable()\nexport class DirectService {\n  constructor(private readonly ozRelayer: OzRelayerService) {}\n\n  async send(dto: DirectTxRequestDto): Promise<DirectTxResponseDto> {\n    const txRequest = {\n      to: dto.to,\n      data: dto.data,\n      value: dto.value || '0',\n      speed: dto.speed || 'average',\n      gasLimit: dto.gasLimit,\n    };\n\n    const response = await this.ozRelayer.sendTransaction(txRequest);\n    \n    return {\n      txId: response.id,\n      txHash: response.hash,\n      status: response.status,\n      from: response.from,\n      nonce: response.nonce,\n      gasPrice: response.gasPrice,\n    };\n  }\n}\n```\n\n### 4. OZ Defender SDK 호환 응답 포맷 유지",
        "testStrategy": "1. 유효한 요청으로 Direct TX 전송 성공 확인\n2. 필수 필드 누락 시 400 Bad Request 반환\n3. 잘못된 주소 형식 시 validation 에러 확인\n4. OZ Relayer 에러 시 적절한 에러 응답 반환\n5. 응답 포맷이 OZ Defender SDK와 호환되는지 확인",
        "priority": "high",
        "dependencies": [
          "3",
          "5"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Smart Contracts 패키지 및 ERC2771Forwarder 배포 스크립트 작성",
        "description": "Hardhat 기반 스마트 컨트랙트 패키지를 설정하고, OpenZeppelin ERC2771Forwarder 배포 스크립트와 Sample ERC20/ERC721 컨트랙트를 작성합니다.",
        "details": "## 구현 세부사항\n\n### 1. Hardhat 프로젝트 초기화\n```bash\ncd packages/contracts\nnpm init -y\nnpm install --save-dev hardhat @nomicfoundation/hardhat-toolbox typescript\nnpm install @openzeppelin/contracts@^5.3.0\nnpx hardhat init\n```\n\n### 2. hardhat.config.ts\n```typescript\nimport { HardhatUserConfig } from 'hardhat/config';\nimport '@nomicfoundation/hardhat-toolbox';\n\nconst config: HardhatUserConfig = {\n  solidity: {\n    version: '0.8.20',\n    settings: { optimizer: { enabled: true, runs: 200 } }\n  },\n  networks: {\n    hardhat: { chainId: 31337 },\n    amoy: {\n      url: process.env.AMOY_RPC_URL || '',\n      chainId: 80002,\n      accounts: process.env.DEPLOYER_PRIVATE_KEY ? [process.env.DEPLOYER_PRIVATE_KEY] : []\n    },\n    polygon: {\n      url: process.env.POLYGON_RPC_URL || '',\n      chainId: 137,\n      accounts: process.env.DEPLOYER_PRIVATE_KEY ? [process.env.DEPLOYER_PRIVATE_KEY] : []\n    }\n  }\n};\nexport default config;\n```\n\n### 3. Sample ERC20 + ERC2771Context\n```solidity\n// contracts/tokens/SampleToken.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/metatx/ERC2771Context.sol\";\n\ncontract SampleToken is ERC20, ERC2771Context {\n    constructor(address trustedForwarder) \n        ERC20(\"Sample Token\", \"SAMPLE\") \n        ERC2771Context(trustedForwarder) \n    {\n        _mint(msg.sender, 1000000 * 10**18);\n    }\n\n    function _msgSender() internal view override(Context, ERC2771Context) \n        returns (address) {\n        return ERC2771Context._msgSender();\n    }\n\n    function _msgData() internal view override(Context, ERC2771Context) \n        returns (bytes calldata) {\n        return ERC2771Context._msgData();\n    }\n\n    function _contextSuffixLength() internal view override(Context, ERC2771Context) \n        returns (uint256) {\n        return ERC2771Context._contextSuffixLength();\n    }\n}\n```\n\n### 4. Forwarder 배포 스크립트\n```typescript\n// scripts/deploy-forwarder.ts\nimport { ethers } from 'hardhat';\n\nasync function main() {\n  const ERC2771Forwarder = await ethers.getContractFactory('ERC2771Forwarder');\n  const forwarder = await ERC2771Forwarder.deploy('Relayer-Forwarder');\n  await forwarder.waitForDeployment();\n  \n  console.log(`ERC2771Forwarder deployed to: ${await forwarder.getAddress()}`);\n  \n  // 배포 정보 저장\n  const deployments = {\n    network: network.name,\n    chainId: network.config.chainId,\n    forwarder: await forwarder.getAddress(),\n    deployedAt: new Date().toISOString()\n  };\n  fs.writeFileSync(\n    `./deployments/${network.name}.json`,\n    JSON.stringify(deployments, null, 2)\n  );\n}\n\nmain().catch(console.error);\n```",
        "testStrategy": "1. `npx hardhat compile` - 컴파일 성공 확인\n2. `npx hardhat test` - 로컬 테스트 통과\n3. Hardhat 로컬 노드에서 Forwarder 배포 테스트\n4. SampleToken이 Forwarder를 신뢰하는지 확인\n5. Polygon Amoy에 배포 후 컨트랙트 검증",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Gasless Transaction API 및 EIP-712 서명 검증 구현",
        "description": "POST /api/v1/relay/gasless 엔드포인트를 구현하고, ethers.js v6를 사용한 EIP-712 서명 사전 검증 로직을 작성합니다.",
        "details": "## 구현 세부사항\n\n### 1. ForwardRequest DTO\n```typescript\n// relay/gasless/dto/gasless-tx.dto.ts\nexport class ForwardRequestDto {\n  @ApiProperty()\n  @IsEthereumAddress()\n  from: string;\n\n  @ApiProperty()\n  @IsEthereumAddress()\n  to: string;\n\n  @ApiProperty()\n  @IsNumberString()\n  value: string;\n\n  @ApiProperty()\n  @IsNumberString()\n  gas: string;\n\n  @ApiProperty()\n  @IsNumberString()\n  nonce: string;\n\n  @ApiProperty()\n  @IsNumber()\n  deadline: number;\n\n  @ApiProperty()\n  @IsHexadecimal()\n  data: string;\n}\n\nexport class GaslessTxRequestDto {\n  @ApiProperty({ type: ForwardRequestDto })\n  @ValidateNested()\n  @Type(() => ForwardRequestDto)\n  request: ForwardRequestDto;\n\n  @ApiProperty({ description: 'EIP-712 서명' })\n  @IsHexadecimal()\n  signature: string;\n\n  @ApiPropertyOptional()\n  metadata?: Record<string, any>;\n}\n```\n\n### 2. EIP-712 서명 검증 서비스\n```typescript\n// relay/gasless/signature-verifier.service.ts\nimport { verifyTypedData, TypedDataDomain } from 'ethers';\n\n@Injectable()\nexport class SignatureVerifierService {\n  private readonly domain: TypedDataDomain;\n  private readonly types = {\n    ForwardRequest: [\n      { name: 'from', type: 'address' },\n      { name: 'to', type: 'address' },\n      { name: 'value', type: 'uint256' },\n      { name: 'gas', type: 'uint256' },\n      { name: 'nonce', type: 'uint256' },\n      { name: 'deadline', type: 'uint48' },\n      { name: 'data', type: 'bytes' },\n    ],\n  };\n\n  constructor(private configService: ConfigService) {\n    this.domain = {\n      name: 'Relayer-Forwarder',\n      version: '1',\n      chainId: configService.get<number>('CHAIN_ID'),\n      verifyingContract: configService.get<string>('FORWARDER_ADDRESS'),\n    };\n  }\n\n  verifySignature(request: ForwardRequestDto, signature: string): boolean {\n    try {\n      const recoveredAddress = verifyTypedData(\n        this.domain,\n        this.types,\n        request,\n        signature\n      );\n      return recoveredAddress.toLowerCase() === request.from.toLowerCase();\n    } catch {\n      return false;\n    }\n  }\n\n  validateDeadline(deadline: number): boolean {\n    return deadline > Math.floor(Date.now() / 1000);\n  }\n}\n```\n\n### 3. Gasless Service\n```typescript\n// relay/gasless/gasless.service.ts\n@Injectable()\nexport class GaslessService {\n  constructor(\n    private readonly signatureVerifier: SignatureVerifierService,\n    private readonly ozRelayer: OzRelayerService,\n  ) {}\n\n  async send(dto: GaslessTxRequestDto): Promise<GaslessTxResponseDto> {\n    // 1. Deadline 검증\n    if (!this.signatureVerifier.validateDeadline(dto.request.deadline)) {\n      throw new BadRequestException('Request expired');\n    }\n\n    // 2. EIP-712 서명 검증\n    if (!this.signatureVerifier.verifySignature(dto.request, dto.signature)) {\n      throw new UnauthorizedException('Invalid signature');\n    }\n\n    // 3. Forwarder.execute() 호출용 TX 빌드\n    const forwarderTx = this.buildForwarderExecuteTx(dto);\n    \n    // 4. OZ Relayer로 전송\n    return this.ozRelayer.sendTransaction(forwarderTx);\n  }\n\n  private buildForwarderExecuteTx(dto: GaslessTxRequestDto) {\n    const iface = new Interface(ERC2771ForwarderABI);\n    const data = iface.encodeFunctionData('execute', [\n      {\n        from: dto.request.from,\n        to: dto.request.to,\n        value: dto.request.value,\n        gas: dto.request.gas,\n        nonce: dto.request.nonce,\n        deadline: dto.request.deadline,\n        data: dto.request.data,\n      },\n      dto.signature,\n    ]);\n    return { to: this.forwarderAddress, data, value: dto.request.value };\n  }\n}\n```\n\n### 4. Nonce 조회 엔드포인트\n```typescript\n@Get('nonce/:address')\nasync getNonce(@Param('address') address: string, @Query('network') network: string) {\n  const nonce = await this.gaslessService.getNonceFromForwarder(address);\n  return { address, nonce, network, forwarder: this.forwarderAddress };\n}\n```",
        "testStrategy": "1. 유효한 EIP-712 서명으로 Gasless TX 전송 성공 확인\n2. 잘못된 서명 시 401 Unauthorized 반환\n3. 만료된 deadline 시 400 Bad Request 반환\n4. from 주소와 서명자 불일치 시 에러 반환\n5. Nonce 조회 API 정상 동작 확인\n6. Forwarder contract 호출 데이터 정확성 검증",
        "priority": "high",
        "dependencies": [
          "5",
          "6",
          "7"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "9",
        "title": "Transaction Status 조회 API 및 Webhook 핸들러 구현",
        "description": "GET /api/v1/relay/status/{txId} 엔드포인트 (Phase 1 - 폴링 방식)와 OZ Relayer Webhook 이벤트 처리 핸들러 (Phase 2+)를 구현합니다.",
        "status": "pending",
        "dependencies": [
          6
        ],
        "priority": "medium",
        "details": "## Phase 분리 (v11.2 기준)\n\n**Phase 1 (현재)**: 상태 폴링 방식 `/api/v1/relay/status/{txId}`\n**Phase 2+**: Webhook Handler + TX History (MySQL)\n\n---\n\n## Phase 1 구현 (상태 폴링)\n\n### 1. Status Controller (Phase 1)\n\n```typescript\n// packages/api-gateway/src/relay/status/status.controller.ts\n@Controller('api/v1/relay')\nexport class StatusController {\n  constructor(private readonly statusService: StatusService) {}\n\n  @Get('status/:txId')\n  @ApiOperation({ summary: '트랜잭션 상태 조회 (폴링)' })\n  @ApiResponse({ status: 200, type: TxStatusDto })\n  @ApiResponse({ status: 404, description: 'Transaction not found' })\n  async getStatus(@Param('txId') txId: string): Promise<ApiResponse<TxStatusDto>> {\n    const status = await this.statusService.getStatus(txId);\n    return { success: true, data: status };\n  }\n}\n```\n\n### 2. Status DTO\n\n```typescript\n// packages/api-gateway/src/relay/status/dto/tx-status.dto.ts\nexport class TxStatusDto {\n  @ApiProperty({ description: 'Relayer 내부 트랜잭션 ID' })\n  txId: string;\n\n  @ApiPropertyOptional({ description: '블록체인 트랜잭션 해시' })\n  txHash?: string;\n\n  @ApiProperty({ \n    enum: ['pending', 'sent', 'submitted', 'inmempool', 'mined', 'confirmed', 'failed'],\n    description: 'OZ Relayer 트랜잭션 상태'\n  })\n  status: string;\n\n  @ApiPropertyOptional({ description: '확인 블록 수' })\n  confirmations?: number;\n\n  @ApiPropertyOptional({ description: '마이닝된 블록 번호' })\n  blockNumber?: number;\n\n  @ApiPropertyOptional({ description: '에러 메시지 (실패 시)' })\n  error?: string;\n\n  @ApiPropertyOptional({ description: '마지막 업데이트 시각' })\n  updatedAt?: Date;\n}\n```\n\n### 3. Status Service (OZ Relayer API 폴링)\n\n```typescript\n// packages/api-gateway/src/relay/status/status.service.ts\n@Injectable()\nexport class StatusService {\n  constructor(\n    private readonly relayerPoolService: RelayerPoolService,\n    private readonly configService: ConfigService,\n  ) {}\n\n  async getStatus(txId: string): Promise<TxStatusDto> {\n    // OZ Relayer API 호출 (GET /transactions/{txId})\n    const relayer = this.relayerPoolService.getHealthyRelayer();\n    \n    try {\n      const response = await axios.get(\n        `${relayer.url}/transactions/${txId}`,\n        { headers: { 'X-Api-Key': relayer.apiKey } }\n      );\n\n      return {\n        txId: response.data.id,\n        txHash: response.data.hash,\n        status: response.data.status,\n        confirmations: response.data.confirmations,\n        blockNumber: response.data.blockNumber,\n        error: response.data.error,\n        updatedAt: new Date(response.data.updatedAt)\n      };\n    } catch (error) {\n      if (error.response?.status === 404) {\n        throw new NotFoundException(`Transaction ${txId} not found`);\n      }\n      throw error;\n    }\n  }\n}\n```\n\n### 4. Phase 1 사용 패턴\n\n```typescript\n// Client Service 예시 (결제 시스템)\n// 1. Direct TX 전송\nconst { txId } = await relayerClient.post('/api/v1/relay/direct', txRequest);\n\n// 2. 상태 폴링 (Phase 1)\nwhile (true) {\n  const { status } = await relayerClient.get(`/api/v1/relay/status/${txId}`);\n  \n  if (status === 'confirmed') {\n    console.log('트랜잭션 확정');\n    break;\n  } else if (status === 'failed') {\n    console.error('트랜잭션 실패');\n    break;\n  }\n  \n  await sleep(5000); // 5초마다 폴링\n}\n```\n\n---\n\n## Phase 2+ 구현 (Webhook Handler + TX History)\n\n> **참고**: Phase 2+에서는 상태 폴링 대신 Webhook Push 방식을 사용합니다.\n> MySQL에 트랜잭션 히스토리를 저장하고, OZ Relayer Webhook을 통해 상태 변경을 실시간으로 수신합니다.\n\n### 5. Webhook Controller (Phase 2+)\n\n```typescript\n// packages/api-gateway/src/webhook/webhook.controller.ts\n@Controller('api/v1/webhook')\nexport class WebhookController {\n  constructor(private readonly webhookService: WebhookService) {}\n\n  @Post('relayer')\n  @Public() // API Key 인증 제외\n  @ApiOperation({ summary: 'OZ Relayer Webhook 이벤트 수신 (Phase 2+)' })\n  async handleRelayerWebhook(\n    @Headers('x-webhook-signature') signature: string,\n    @Body() payload: RelayerWebhookPayload,\n  ) {\n    // 1. Webhook 서명 검증 (HMAC SHA-256)\n    if (!this.webhookService.verifySignature(payload, signature)) {\n      throw new UnauthorizedException('Invalid webhook signature');\n    }\n\n    // 2. 이벤트 처리 (MySQL 저장)\n    await this.webhookService.processEvent(payload);\n    return { received: true };\n  }\n}\n```\n\n### 6. Webhook Service (Phase 2+)\n\n```typescript\n// packages/api-gateway/src/webhook/webhook.service.ts\n@Injectable()\nexport class WebhookService {\n  constructor(\n    private readonly configService: ConfigService,\n    @InjectRepository(Transaction)\n    private readonly txRepository: Repository<Transaction>,\n  ) {}\n\n  verifySignature(payload: any, signature: string): boolean {\n    const signingKey = this.configService.get('WEBHOOK_SIGNING_KEY');\n    const expectedSig = createHmac('sha256', signingKey)\n      .update(JSON.stringify(payload))\n      .digest('hex');\n    return timingSafeEqual(\n      Buffer.from(signature),\n      Buffer.from(expectedSig)\n    );\n  }\n\n  async processEvent(payload: RelayerWebhookPayload) {\n    const { event, data } = payload;\n    \n    switch (event) {\n      case 'transaction.sent':\n        await this.updateTxStatus(data.txId, 'sent', data);\n        break;\n      case 'transaction.mined':\n        await this.updateTxStatus(data.txId, 'mined', data);\n        break;\n      case 'transaction.confirmed':\n        await this.updateTxStatus(data.txId, 'confirmed', data);\n        break;\n      case 'transaction.failed':\n        await this.updateTxStatus(data.txId, 'failed', data);\n        break;\n    }\n  }\n\n  private async updateTxStatus(\n    txId: string,\n    status: string,\n    data: any\n  ): Promise<void> {\n    await this.txRepository.update(\n      { txId },\n      {\n        status,\n        txHash: data.txHash,\n        confirmations: data.confirmations,\n        blockNumber: data.blockNumber,\n        error: data.error,\n        updatedAt: new Date()\n      }\n    );\n  }\n}\n```\n\n### 7. Prisma Schema (Phase 2+ MySQL)\n\n```prisma\n// packages/api-gateway/prisma/schema.prisma\nmodel Transaction {\n  id            String   @id @default(uuid())\n  txId          String   @unique              // OZ Relayer txId\n  txHash        String?                       // 블록체인 트랜잭션 해시\n  status        String   @default(\"pending\")  // pending|sent|submitted|inmempool|mined|confirmed|failed\n  from          String                        // Relayer 주소\n  to            String                        // 대상 컨트랙트 주소\n  type          String                        // \"direct\" | \"gasless\"\n  confirmations Int      @default(0)\n  blockNumber   Int?\n  error         String?  @db.Text\n  metadata      Json?                         // 클라이언트 메타데이터\n  createdAt     DateTime @default(now())\n  updatedAt     DateTime @updatedAt\n\n  @@index([txId])\n  @@index([status])\n  @@index([createdAt])\n  @@map(\"transactions\")\n}\n```\n\n### 8. OZ Relayer Webhook 설정 (Phase 2+)\n\n```json\n// docker/config/oz-relayer/relayer-1.json\n{\n  \"relayers\": [{\n    \"id\": \"polygon-relayer-1\",\n    \"notifications\": [{\n      \"type\": \"webhook\",\n      \"url\": \"http://api-gateway:3000/api/v1/webhook/relayer\",\n      \"signing_key\": \"${WEBHOOK_SIGNING_KEY}\",\n      \"events\": [\n        \"transaction.sent\",\n        \"transaction.mined\",\n        \"transaction.confirmed\",\n        \"transaction.failed\"\n      ]\n    }]\n  }]\n}\n```\n\n---\n\n## Phase별 구현 순서\n\n**Phase 1** (현재 구현 대상):\n1. Status Controller + Service (폴링 API)\n2. OZ Relayer API 연동\n3. 에러 핸들링 (404 Not Found)\n\n**Phase 2+** (추후 구현):\n1. MySQL 및 Prisma 설정\n2. Transaction 모델 마이그레이션\n3. Webhook Controller + Service\n4. Webhook 서명 검증\n5. 이벤트별 상태 업데이트\n6. OZ Relayer Webhook 설정",
        "testStrategy": "## Phase 1 테스트 전략 (상태 폴링)\n\n1. **유효한 txId로 상태 조회 성공**\n   - OZ Relayer API에서 트랜잭션 정보 정상 반환 확인\n   - DTO 매핑 정확성 검증\n\n2. **존재하지 않는 txId 시 404 Not Found 반환**\n   - NotFoundException 발생 확인\n   - 에러 메시지 검증\n\n3. **OZ Relayer 다운 시 적절한 에러 처리**\n   - 다른 Relayer로 자동 전환 (RelayerPoolService)\n   - 모든 Relayer 다운 시 503 Service Unavailable\n\n4. **상태 전환 시나리오 테스트**\n   - pending → sent → submitted → mined → confirmed\n   - pending → sent → failed\n\n5. **Relayer Pool 통합 테스트**\n   - Multi-Relayer 환경에서 상태 조회 정상 동작 확인\n\n---\n\n## Phase 2+ 테스트 전략 (Webhook Handler)\n\n1. **Webhook 서명 검증 성공/실패 케이스**\n   - 유효한 HMAC SHA-256 서명: 200 OK\n   - 잘못된 서명: 401 Unauthorized\n   - 서명 누락: 401 Unauthorized\n\n2. **각 이벤트 타입별 상태 업데이트 확인**\n   - transaction.sent → status: 'sent'\n   - transaction.mined → status: 'mined', blockNumber 업데이트\n   - transaction.confirmed → status: 'confirmed', confirmations 업데이트\n   - transaction.failed → status: 'failed', error 메시지 저장\n\n3. **DB에 트랜잭션 정보 정상 저장 확인**\n   - Prisma를 통한 Transaction 모델 저장/업데이트\n   - Index 성능 확인 (txId, status, createdAt)\n\n4. **중복 이벤트 처리**\n   - 동일 txId에 대한 중복 Webhook 처리 시 멱등성 보장\n\n5. **OZ Relayer 통합 테스트**\n   - 로컬 OZ Relayer에서 실제 Webhook 발송 테스트\n   - Webhook 재시도 로직 검증",
        "subtasks": [
          {
            "id": 1,
            "title": "Phase 1: Status 폴링 API 구현",
            "description": "GET /api/v1/relay/status/{txId} 엔드포인트 구현 (OZ Relayer API 연동)",
            "dependencies": [],
            "details": "- StatusController 생성 (packages/api-gateway/src/relay/status/status.controller.ts)\n- StatusService 구현 (OZ Relayer API 폴링)\n- TxStatusDto 정의 (DTO)\n- RelayerPoolService 통합 (Multi-Relayer 지원)\n- 에러 핸들링 (404 Not Found, 503 Service Unavailable)",
            "status": "pending",
            "testStrategy": "단위 테스트: StatusService OZ Relayer API 호출 검증\n통합 테스트: 실제 OZ Relayer와 상태 조회 시나리오"
          },
          {
            "id": 2,
            "title": "Phase 2+: MySQL 및 Prisma Transaction 모델 설정",
            "description": "Transaction 히스토리 저장을 위한 데이터베이스 스키마 설정",
            "dependencies": [],
            "details": "- Prisma Schema 작성 (Transaction 모델)\n- 마이그레이션 파일 생성\n- Index 설정 (txId, status, createdAt)\n- Docker Compose MySQL 서비스 활성화 (Profile: phase2)",
            "status": "pending",
            "testStrategy": "마이그레이션 정상 실행 확인\nTransaction CRUD 테스트"
          },
          {
            "id": 3,
            "title": "Phase 2+: Webhook Controller 및 Service 구현",
            "description": "OZ Relayer Webhook 이벤트 수신 및 처리",
            "dependencies": [
              2
            ],
            "details": "- WebhookController 생성 (POST /api/v1/webhook/relayer)\n- @Public() 데코레이터 적용 (API Key 인증 제외)\n- WebhookService 구현 (HMAC SHA-256 서명 검증)\n- 이벤트 타입별 분기 처리 (sent/mined/confirmed/failed)\n- Transaction 모델 업데이트 로직",
            "status": "pending",
            "testStrategy": "Webhook 서명 검증 단위 테스트\n이벤트별 상태 업데이트 통합 테스트\nDB 저장 검증"
          },
          {
            "id": 4,
            "title": "Phase 2+: OZ Relayer Webhook 설정",
            "description": "OZ Relayer config.json에 Webhook 알림 설정 추가",
            "dependencies": [
              3
            ],
            "details": "- docker/config/oz-relayer/relayer-{1,2,3}.json 수정\n- notifications 섹션 추가 (type: webhook)\n- WEBHOOK_SIGNING_KEY 환경변수 설정\n- 이벤트 타입 등록 (transaction.sent/mined/confirmed/failed)",
            "status": "pending",
            "testStrategy": "OZ Relayer 재시작 후 Webhook 발송 확인\nAPI Gateway Webhook 수신 로그 검증"
          }
        ]
      },
      {
        "id": 10,
        "title": "Client SDK 패키지 개발 (OZ Defender 호환)",
        "description": "OpenZeppelin Defender SDK와 호환되는 TypeScript Client SDK를 개발하여 Client Service의 마이그레이션 용이성을 제공합니다.",
        "details": "## 구현 세부사항\n\n### 1. SDK 프로젝트 구조\n```\npackages/sdk/\n├── src/\n│   ├── index.ts           # RelayerClient 진입점\n│   ├── clients/\n│   │   ├── relayer.ts     # Direct TX 클라이언트\n│   │   └── relay-signer.ts # Gasless TX 클라이언트\n│   ├── models/\n│   │   ├── transactions.ts\n│   │   ├── relayer.ts\n│   │   └── common.ts      # ApiResponse<T>\n│   └── types.ts\n├── package.json\n└── tsconfig.json\n```\n\n### 2. RelayerClient 진입점\n```typescript\n// src/index.ts\nexport class RelayerClient {\n  public readonly relayer: Relayer;\n  public readonly relaySigner: RelaySigner;\n\n  constructor(config: RelayerClientConfig) {\n    const httpClient = new HttpClient(config);\n    this.relayer = new Relayer(httpClient);\n    this.relaySigner = new RelaySigner(httpClient);\n  }\n}\n\nexport interface RelayerClientConfig {\n  apiKey: string;\n  apiSecret: string;\n  network: string;\n  baseUrl?: string;\n}\n```\n\n### 3. Relayer 클라이언트 (Direct TX)\n```typescript\n// src/clients/relayer.ts\nexport class Relayer {\n  constructor(private readonly http: HttpClient) {}\n\n  async sendTransaction(request: DirectTxRequest): Promise<ApiResponse<TxResponse>> {\n    return this.http.post('/relay/direct', request);\n  }\n\n  async getRelayer(): Promise<ApiResponse<RelayerInfo>> {\n    return this.http.get('/relay/info');\n  }\n\n  async getTransactionStatus(txId: string): Promise<ApiResponse<TxStatus>> {\n    return this.http.get(`/relay/status/${txId}`);\n  }\n\n  async cancelTransactionById(txId: string): Promise<ApiResponse<void>> {\n    return this.http.post(`/relay/cancel/${txId}`);\n  }\n}\n```\n\n### 4. RelaySigner 클라이언트 (Gasless TX)\n```typescript\n// src/clients/relay-signer.ts\nexport class RelaySigner {\n  async sendTransaction(request: GaslessTxRequest): Promise<ApiResponse<TxResponse>> {\n    return this.http.post('/relay/gasless', request);\n  }\n\n  async getNonce(address: string): Promise<ApiResponse<NonceInfo>> {\n    return this.http.get(`/relay/nonce/${address}`);\n  }\n}\n```\n\n### 5. ApiResponse 래퍼\n```typescript\n// src/models/common.ts\nexport interface ApiResponse<T> {\n  data: T | null;\n  error?: string;\n  success: boolean;\n}\n\nexport type TxStatus = \n  | 'pending' \n  | 'sent' \n  | 'submitted' \n  | 'inmempool' \n  | 'mined' \n  | 'confirmed' \n  | 'failed';\n```\n\n### 6. package.json\n```json\n{\n  \"name\": \"@msq/relayer-sdk\",\n  \"version\": \"1.0.0\",\n  \"main\": \"dist/index.js\",\n  \"types\": \"dist/index.d.ts\",\n  \"dependencies\": {\n    \"ethers\": \"^6.0.0\"\n  },\n  \"peerDependencies\": {\n    \"ethers\": \"^6.0.0\"\n  }\n}\n```",
        "testStrategy": "1. Direct TX 전송 테스트 (sendTransaction)\n2. Gasless TX 전송 테스트 (relaySigner.sendTransaction)\n3. 트랜잭션 상태 조회 테스트\n4. Nonce 조회 테스트\n5. API 에러 응답 처리 테스트\n6. OZ Defender SDK에서 마이그레이션 코드 변경 최소화 확인",
        "priority": "medium",
        "dependencies": [
          "6",
          "8",
          "9"
        ],
        "status": "cancelled",
        "subtasks": [],
        "updatedAt": "2025-12-15T03:44:21.230Z"
      },
      {
        "id": 11,
        "title": "통합 테스트 및 결제 시스템 연동 검증",
        "description": "전체 시스템 통합 테스트를 수행하고, 결제 시스템 연동 시나리오(Direct TX 정산, Gasless TX 가스비 대납)를 검증합니다. PRD v7.0 변경사항에 따라 Client SDK를 제거하고 HTTP API 직접 호출 방식으로 테스트합니다.",
        "status": "pending",
        "dependencies": [
          8,
          9
        ],
        "priority": "high",
        "details": "## 구현 세부사항\n\n### 1. E2E 테스트 설정\n```typescript\n// packages/api-gateway/test/e2e/relay.e2e-spec.ts\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { INestApplication } from '@nestjs/common';\nimport * as request from 'supertest';\n\ndescribe('Relay API (e2e)', () => {\n  let app: INestApplication;\n\n  beforeAll(async () => {\n    const moduleFixture: TestingModule = await Test.createTestingModule({\n      imports: [AppModule],\n    }).compile();\n\n    app = moduleFixture.createNestApplication();\n    await app.init();\n  });\n\n  describe('Direct Transaction', () => {\n    it('should send direct transaction successfully', async () => {\n      const response = await request(app.getHttpServer())\n        .post('/api/v1/relay/direct')\n        .set('X-API-Key', process.env.TEST_API_KEY)\n        .send({\n          to: '0x...',\n          data: '0x...',\n          value: '0',\n          speed: 'fast',\n        })\n        .expect(201);\n\n      expect(response.body.success).toBe(true);\n      expect(response.body.data.txId).toBeDefined();\n    });\n  });\n\n  describe('Gasless Transaction', () => {\n    it('should send gasless transaction with valid signature', async () => {\n      const forwardRequest = await buildForwardRequest();\n      const signature = await signTypedData(forwardRequest);\n\n      const response = await request(app.getHttpServer())\n        .post('/api/v1/relay/gasless')\n        .set('X-API-Key', process.env.TEST_API_KEY)\n        .send({ request: forwardRequest, signature })\n        .expect(201);\n\n      expect(response.body.success).toBe(true);\n    });\n  });\n});\n```\n\n### 2. 결제 시스템 통합 테스트 (HTTP API 직접 호출)\n```typescript\n// test/integration/payment-system.test.ts\nimport axios from 'axios';\nimport { Wallet } from 'ethers';\nimport { encodeTransfer } from './utils/encoding';\n\nconst API_BASE_URL = process.env.API_BASE_URL || 'http://localhost:3000';\nconst API_KEY = process.env.API_KEY;\nconst TOKEN_ADDRESS = process.env.TOKEN_ADDRESS;\nconst MERCHANT_ADDRESS = process.env.MERCHANT_ADDRESS;\n\nconst apiClient = axios.create({\n  baseURL: API_BASE_URL,\n  headers: {\n    'X-API-Key': API_KEY,\n    'Content-Type': 'application/json',\n  },\n});\n\ndescribe('Payment System Integration', () => {\n  describe('Direct TX - 토큰 정산', () => {\n    it('should batch transfer tokens to multiple recipients', async () => {\n      const recipients = [\n        { address: '0x...', amount: '100' },\n        { address: '0x...', amount: '200' },\n      ];\n\n      for (const recipient of recipients) {\n        const response = await apiClient.post('/api/v1/relay/direct', {\n          to: TOKEN_ADDRESS,\n          data: encodeTransfer(recipient.address, recipient.amount),\n          value: '0',\n          speed: 'fast',\n        });\n\n        expect(response.status).toBe(201);\n        expect(response.data.success).toBe(true);\n        expect(response.data.data.txId).toBeDefined();\n      }\n    });\n  });\n\n  describe('Gasless TX - 가스비 대납 결제', () => {\n    it('should execute payment on behalf of end user', async () => {\n      // 1. End User 서명 시뮬레이션\n      const userWallet = new Wallet(process.env.USER_PRIVATE_KEY);\n      \n      // 2. Nonce 조회 (HTTP API)\n      const nonceResponse = await apiClient.get(\n        `/api/v1/relay/nonce/${userWallet.address}`,\n        { params: { network: 'polygon-amoy' } }\n      );\n      const nonce = nonceResponse.data.data.nonce;\n\n      // 3. ForwardRequest 생성\n      const forwardRequest = {\n        from: userWallet.address,\n        to: TOKEN_ADDRESS,\n        value: '0',\n        gas: '200000',\n        nonce,\n        deadline: Math.floor(Date.now() / 1000) + 3600,\n        data: encodeTransfer(MERCHANT_ADDRESS, '50'),\n      };\n\n      // 4. EIP-712 서명 생성\n      const domain = {\n        name: 'MSQ Relayer',\n        version: '1',\n        chainId: 80002, // Polygon Amoy\n        verifyingContract: process.env.FORWARDER_ADDRESS,\n      };\n\n      const types = {\n        ForwardRequest: [\n          { name: 'from', type: 'address' },\n          { name: 'to', type: 'address' },\n          { name: 'value', type: 'uint256' },\n          { name: 'gas', type: 'uint256' },\n          { name: 'nonce', type: 'uint256' },\n          { name: 'deadline', type: 'uint48' },\n          { name: 'data', type: 'bytes' },\n        ],\n      };\n\n      const signature = await userWallet.signTypedData(domain, types, forwardRequest);\n\n      // 5. Gasless TX 전송 (HTTP API)\n      const txResponse = await apiClient.post('/api/v1/relay/gasless', {\n        request: forwardRequest,\n        signature,\n        metadata: {\n          paymentId: 'PAY-001',\n          userId: userWallet.address,\n        },\n      });\n\n      expect(txResponse.status).toBe(201);\n      expect(txResponse.data.success).toBe(true);\n      expect(txResponse.data.data.txId).toBeDefined();\n\n      // 6. 트랜잭션 상태 확인\n      const txId = txResponse.data.data.txId;\n      await waitForConfirmation(txId);\n    });\n  });\n});\n\n// 트랜잭션 확인 헬퍼 함수\nasync function waitForConfirmation(txId: string, maxAttempts = 30) {\n  for (let i = 0; i < maxAttempts; i++) {\n    const statusResponse = await apiClient.get(`/api/v1/relay/status/${txId}`);\n    const status = statusResponse.data.data.status;\n\n    if (status === 'confirmed') {\n      return statusResponse.data.data;\n    }\n\n    if (status === 'failed') {\n      throw new Error(`Transaction ${txId} failed`);\n    }\n\n    await new Promise(resolve => setTimeout(resolve, 2000));\n  }\n\n  throw new Error(`Transaction ${txId} confirmation timeout`);\n}\n```\n\n### 3. 부하 테스트 (Artillery)\n```yaml\n# load-test.yml\nconfig:\n  target: 'http://localhost:3000'\n  phases:\n    - duration: 60\n      arrivalRate: 10\n  defaults:\n    headers:\n      X-API-Key: '{{API_KEY}}'\n\nscenarios:\n  - name: 'Direct TX Load Test'\n    flow:\n      - post:\n          url: '/api/v1/relay/direct'\n          json:\n            to: '{{CONTRACT_ADDRESS}}'\n            data: '{{ENCODED_DATA}}'\n            value: '0'\n            speed: 'fast'\n```\n\n### 4. API 문서 참조 가이드\n\n**Swagger UI**: `http://localhost:3000/api/docs`에서 모든 엔드포인트 테스트 가능\n\n**주요 엔드포인트**:\n- `POST /api/v1/relay/direct`: Direct Transaction 전송\n- `POST /api/v1/relay/gasless`: Gasless Transaction 전송\n- `GET /api/v1/relay/nonce/{address}`: Nonce 조회\n- `GET /api/v1/relay/status/{txId}`: 트랜잭션 상태 조회\n- `GET /api/v1/health`: Health Check\n\n**OpenAPI JSON**: `http://localhost:3000/api/docs-json`에서 스펙 파일 다운로드\n\n### 5. 테스트 디렉토리 구조\n```\ntest/\n├── integration/\n│   ├── payment-system.test.ts    # 결제 시스템 통합 테스트\n│   ├── utils/\n│   │   ├── encoding.ts           # 트랜잭션 인코딩 유틸\n│   │   └── signing.ts            # EIP-712 서명 유틸\n│   └── fixtures/\n│       ├── test-wallets.ts       # 테스트 지갑\n│       └── test-contracts.ts     # 테스트 컨트랙트 주소\n└── load/\n    └── load-test.yml             # Artillery 부하 테스트 설정\n```",
        "testStrategy": "1. 로컬 Hardhat 노드에서 전체 플로우 테스트\n2. Polygon Amoy에서 실제 트랜잭션 테스트\n3. Direct TX 배치 처리 성능 테스트 (100 TX, HTTP API 직접 호출)\n4. Gasless TX End-to-End 플로우 검증 (HTTP API 직접 호출)\n5. Multi-Relayer Pool 부하 분산 테스트\n6. 에러 시나리오 테스트 (Relayer 다운, 잔액 부족 등)\n7. Swagger UI를 통한 API 문서 검증 및 수동 테스트\n8. Artillery를 사용한 부하 테스트 (10 req/s, 60초)",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "프로덕션 환경 설정, API 문서화 및 운영 가이드 작성",
        "description": "프로덕션 배포를 위한 환경 설정, Swagger/OpenAPI 기반 API 문서화, 운영 가이드 및 트러블슈팅 문서를 작성합니다. Client Services가 Swagger UI(/api/docs)와 OpenAPI JSON(/api/docs-json)을 통해 API를 학습하고 통합할 수 있도록 합니다.",
        "status": "pending",
        "dependencies": [
          11
        ],
        "priority": "medium",
        "details": "## 구현 세부사항\n\n### 1. 프로덕션 Docker Compose\n```yaml\n# docker-compose.prod.yml\nversion: '3.8'\n\nservices:\n  api-gateway:\n    image: msq-relayer/api-gateway:${VERSION}\n    deploy:\n      replicas: 2\n      resources:\n        limits:\n          cpus: '1'\n          memory: 1G\n    environment:\n      - NODE_ENV=production\n      - DATABASE_URL=${DATABASE_URL}\n    healthcheck:\n      test: ['CMD', 'curl', '-f', 'http://localhost:3000/api/v1/health']\n      interval: 30s\n      timeout: 10s\n      retries: 3\n\n  oz-relayer-1:\n    image: ghcr.io/openzeppelin/openzeppelin-relayer:v1.3.0\n    deploy:\n      resources:\n        limits:\n          cpus: '0.5'\n          memory: 512M\n    secrets:\n      - keystore_passphrase\n```\n\n### 2. Swagger/OpenAPI 문서 완성\n\n#### 2.1 모든 엔드포인트에 상세 문서 추가\n```typescript\n// 모든 엔드포인트에 상세 문서 추가\n@ApiOperation({\n  summary: 'Direct Transaction 전송',\n  description: `\n    OZ Relayer를 통해 Direct Transaction을 전송합니다.\n    \n    ## 사용 사례\n    - 결제 시스템 토큰 정산\n    - 에어드랍 배치 처리\n    \n    ## 주의사항\n    - gasLimit 미지정 시 자동 추정\n    - speed에 따라 가스 가격 조정\n  `,\n})\n@ApiResponse({\n  status: 201,\n  description: '트랜잭션 전송 성공',\n  type: DirectTxResponseDto,\n})\n@ApiResponse({\n  status: 400,\n  description: '잘못된 요청 파라미터',\n})\n@ApiResponse({\n  status: 503,\n  description: 'OZ Relayer 연결 실패',\n})\n```\n\n#### 2.2 OpenAPI JSON 엔드포인트 설정\n```typescript\n// main.ts에서 Swagger 설정\nconst config = new DocumentBuilder()\n  .setTitle('MSQ Relayer Service API')\n  .setDescription('Blockchain Transaction Relayer API for Client Services')\n  .setVersion('1.0')\n  .addApiKey({ type: 'apiKey', name: 'X-API-Key', in: 'header' }, 'api-key')\n  .build();\n\nconst document = SwaggerModule.createDocument(app, config);\n\n// Swagger UI: /api/docs\nSwaggerModule.setup('api/docs', app, document);\n\n// OpenAPI JSON: /api/docs-json (자동 생성)\n// Client Services는 이 JSON을 다운로드하여 코드 생성 가능\n```\n\n#### 2.3 DTO에 상세한 예제 추가\n```typescript\n// Direct TX DTO 예제\nexport class DirectTxRequestDto {\n  @ApiProperty({\n    description: '대상 컨트랙트 주소',\n    example: '0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb',\n  })\n  to: string;\n\n  @ApiProperty({\n    description: '전송할 데이터 (hex)',\n    example: '0xa9059cbb000000000000000000000000...',\n  })\n  data: string;\n\n  @ApiProperty({\n    description: '가스 전송 속도',\n    enum: ['safeLow', 'average', 'fast', 'fastest'],\n    example: 'fast',\n    required: false,\n  })\n  speed?: string;\n}\n```\n\n### 3. 운영 가이드 (docs/operations.md)\n```markdown\n# MSQ Relayer 운영 가이드\n\n## 1. 서비스 시작/종료\n```bash\n# 시작\ndocker compose -f docker-compose.prod.yml up -d\n\n# 종료\ndocker compose -f docker-compose.prod.yml down\n```\n\n## 2. API 문서 접근\n\n### Swagger UI (대화형 문서)\n- URL: `http://localhost:3000/api/docs`\n- 용도: API 테스트, 사용법 확인\n- 기능: Try it out 버튼으로 직접 API 호출 가능\n\n### OpenAPI JSON (코드 생성용)\n- URL: `http://localhost:3000/api/docs-json`\n- 용도: Client SDK 자동 생성\n- 활용:\n  - TypeScript: openapi-generator-cli\n  - Python: openapi-python-client\n  - Java: swagger-codegen\n\n### Client Services 통합 방법\n1. `/api/docs`에서 API 스펙 확인\n2. `/api/docs-json`에서 OpenAPI JSON 다운로드\n3. 해당 언어의 코드 생성 도구로 클라이언트 코드 생성\n4. API Key 발급받아 X-API-Key 헤더에 포함하여 호출\n\n## 3. Relayer 잔액 모니터링\n- OZ Monitor 알림 설정 확인\n- 최소 잔액: 0.1 MATIC (Polygon)\n\n## 4. 스케일링\n```bash\n# Relayer 추가\ndocker compose --profile scale up -d oz-relayer-2\n```\n\n## 5. 트러블슈팅\n### 5.1 Nonce 충돌\n- OZ Relayer 자동 복구 대기 (최대 5분)\n- 수동 개입: Relayer 재시작\n\n### 5.2 Gas Price 급등\n- gas_price_cap 확인\n- 필요시 상한 조정 후 Relayer 재시작\n```\n\n### 4. 배포 Makefile\n```makefile\n.PHONY: build deploy\n\nbuild:\n\tdocker build -t msq-relayer/api-gateway:$(VERSION) ./packages/api-gateway\n\ndeploy-staging:\n\tdocker compose -f docker-compose.staging.yml up -d\n\ndeploy-prod:\n\tdocker compose -f docker-compose.prod.yml up -d\n\nlogs:\n\tdocker compose logs -f api-gateway oz-relayer-1\n\nhealth:\n\tcurl http://localhost:3000/api/v1/health | jq\n\napi-docs:\n\tcurl http://localhost:3000/api/docs-json | jq > openapi.json\n```\n\n### 5. 환경별 설정 분리\n- `.env.development` - 로컬 개발\n- `.env.staging` - 스테이징 (Amoy)\n- `.env.production` - 프로덕션 (Polygon Mainnet)\n\n### 6. API 문서화 체크리스트\n- [ ] 모든 엔드포인트에 @ApiOperation 추가\n- [ ] 모든 DTO에 @ApiProperty와 example 추가\n- [ ] 모든 HTTP 응답 코드에 @ApiResponse 추가\n- [ ] Swagger UI에서 Try it out 기능 정상 작동 확인\n- [ ] OpenAPI JSON 유효성 검증 (validator.swagger.io)\n- [ ] 인증 방식(X-API-Key) 문서화 확인",
        "testStrategy": "1. Swagger UI(/api/docs)에서 모든 API 문서 검토 및 Try it out 기능 테스트\n2. OpenAPI JSON(/api/docs-json) 다운로드 및 스키마 유효성 검증 (validator.swagger.io)\n3. OpenAPI Generator를 사용하여 TypeScript 클라이언트 코드 생성 테스트\n4. 운영 가이드의 API 문서 접근 방법 검증 (신규 인력 온보딩 시뮬레이션)\n5. 프로덕션 Docker Compose로 로컬 테스트\n6. Health Check 및 모니터링 정상 동작 확인\n7. 스케일링 절차 테스트\n8. 트러블슈팅 시나리오별 복구 절차 검증\n9. Makefile의 api-docs 명령어로 OpenAPI JSON 추출 테스트",
        "subtasks": []
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-12-15T03:44:21.230Z",
      "taskCount": 12,
      "completedCount": 0,
      "tags": [
        "master"
      ],
      "created": "2025-12-15T03:47:47.097Z",
      "description": "Tasks for master context"
    }
  }
}