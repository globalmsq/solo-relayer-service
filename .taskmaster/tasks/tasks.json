{
  "master": {
    "tasks": [
      {
        "id": "1",
        "title": "프로젝트 모노레포 구조 및 Docker Compose 인프라 설정",
        "description": "OZ Relayer v1.3.0 + Redis를 포함한 Docker Compose 기반 개발 환경과 NestJS 모노레포 구조를 구축합니다. (Phase 1 - MySQL 제외)",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "## 구현 세부사항 (v11.2 기준)\n\n### 1. 디렉토리 구조 생성\n```\nmsq-relayer-service/\n├── docker/                          # Docker 관련 파일 전용 디렉토리\n│   ├── Dockerfile.packages          # 멀티스테이지 빌드 (relay-api tsx 실행)\n│   ├── docker-compose.yaml          # Hardhat Node 로컬 개발 설정\n│   ├── docker-compose-amoy.yaml     # Polygon Amoy Testnet 설정\n│   ├── config/\n│   │   └── oz-relayer/              # OZ Relayer 설정 파일\n│   │       ├── relayer-1.json       # Relayer #1 설정\n│   │       ├── relayer-2.json       # Relayer #2 설정\n│   │       └── relayer-3.json       # Relayer #3 설정\n│   ├── keys-example/                # 샘플 키스토어 (Git 포함, Hardhat #10,11,12)\n│   │   ├── relayer-1/keystore.json\n│   │   ├── relayer-2/keystore.json\n│   │   └── relayer-3/keystore.json\n│   └── keys/                        # 실제 키스토어 (.gitignore)\n│       ├── relayer-1/keystore.json\n│       ├── relayer-2/keystore.json\n│       └── relayer-3/keystore.json\n├── packages/\n│   ├── relay-api/     # NestJS 10.x\n│   ├── contracts/       # Hardhat\n│   └── examples/        # 통합 예제\n├── scripts/\n│   ├── health-check.sh\n│   └── test-infra.sh\n└── docs/\n    ├── product.md\n    ├── structure.md\n    └── tech.md\n```\n\n### 2. Docker Compose 서비스 정의 (Phase 1)\n\n#### Phase 1 필수 서비스\n- **hardhat-node**: 로컬 블록체인 (Chain ID: 31337, Port 8545)\n- **relay-api**: NestJS API Gateway (Port 3000)\n- **oz-relayer-1~3**: Multi-Relayer Pool (YAML Anchors 패턴)\n  - Ports: 8081-8083:8080, 8091-8093:8081\n  - Volumes: ./config/oz-relayer/relayer-N.json, ./keys/relayer-N (read-only)\n- **redis**: `redis:8.0-alpine` (Port 6379, AOF 퍼시스턴스)\n\n#### Phase 2+ 서비스 (프로필 분리)\n- **oz-monitor**: 이벤트 모니터링 (profiles: [\"phase2\"])\n- **prometheus**: 메트릭 수집 (profiles: [\"phase2\"])\n- **grafana**: 대시보드 (profiles: [\"phase2\"])\n\n### 3. YAML Anchors 패턴 (중복 제거)\n\n```yaml\nx-relayer-common: &relayer-common\n  image: ghcr.io/openzeppelin/openzeppelin-relayer:v1.3.0\n  environment: &relayer-env\n    RUST_LOG: info\n    KEYSTORE_PASSPHRASE: hardhat-test-passphrase\n    RPC_URL: http://hardhat-node:8545\n    REDIS_HOST: redis\n    REDIS_PORT: 6379\n  depends_on: [redis, hardhat-node]\n\nservices:\n  oz-relayer-1:\n    <<: *relayer-common\n    ports: [\"8081:8080\", \"8091:8081\"]\n    volumes:\n      - ./config/oz-relayer/relayer-1.json:/app/config/config.json:ro\n      - ./keys/relayer-1:/app/config/keys:ro\n    environment:\n      <<: *relayer-env\n      API_KEY: test-api-key-relayer-1\n```\n\n**이유**: 각 Relayer는 고유 Private Key가 필요하여 `deploy.replicas` 사용 불가 (Nonce 충돌 방지)\n\n### 4. OZ Relayer config.json 예시\n\n```json\n{\n  \"relayers\": [{\n    \"id\": \"polygon-relayer-1\",\n    \"name\": \"Polygon Amoy Relayer #1\",\n    \"network\": \"amoy\",\n    \"signer\": {\n      \"type\": \"local\",\n      \"keystore\": \"/app/config/keys/relayer-1.json\"\n    },\n    \"rpc\": {\n      \"url\": \"${AMOY_RPC_URL}\",\n      \"timeout\": 30000\n    },\n    \"policies\": {\n      \"gas_price_cap\": \"500000000000\",\n      \"min_balance\": \"100000000000000000\",\n      \"max_pending_txs\": 10\n    },\n    \"notifications\": [{\n      \"type\": \"webhook\",\n      \"url\": \"http://relay-api:3000/api/v1/webhook/relayer\",\n      \"signing_key\": \"${WEBHOOK_SIGNING_KEY}\"\n    }]\n  }]\n}\n```\n\n### 5. 환경 변수 (docker-compose.yaml 내 직접 명시)\n\n**Phase 1 필수 환경변수** (.env 파일 사용 금지):\n- AMOY_RPC_URL, POLYGON_RPC_URL\n- OZ_RELAYER_API_KEY\n- KEYSTORE_PASSPHRASE\n- WEBHOOK_SIGNING_KEY (Phase 2+)\n- RELAY_API_KEY (단일 환경변수 인증)\n\n**Phase 2+ 환경변수** (미사용):\n- DB_PASSWORD, DB_ROOT_PASSWORD (MySQL)\n\n### 6. Redis 설정 (Phase 1 필수)\n\n```yaml\nredis:\n  image: redis:8.0-alpine\n  ports: [\"6379:6379\"]\n  command: redis-server --appendonly yes\n  volumes:\n    - msq-relayer-redis-data:/data\n```\n\n- AOF(Append-Only File) 퍼시스턴스 활성화\n- Named Volume: msq-relayer-redis-data\n- OZ Relayer 내부 Queue 용도",
        "testStrategy": "1. `cd docker && docker compose up -d` 실행 후 Phase 1 필수 서비스 healthy 상태 확인\n   - hardhat-node\n   - relay-api\n   - oz-relayer-1, oz-relayer-2, oz-relayer-3\n   - redis\n2. `curl http://localhost:8545` - Hardhat Node JSON-RPC 정상 응답 확인\n3. `curl http://localhost:3000/api/v1/health` - API Gateway health check\n4. `curl http://localhost:8081/api/v1/health` - OZ Relayer #1 health check\n5. `curl http://localhost:8082/api/v1/health` - OZ Relayer #2 health check\n6. `curl http://localhost:8083/api/v1/health` - OZ Relayer #3 health check\n7. Redis 연결 테스트: `redis-cli ping` (PONG 응답 확인)\n8. 각 컨테이너 로그에 에러 없음 확인 (`docker compose logs`)\n9. Phase 2+ 서비스는 시작되지 않음 확인 (oz-monitor, prometheus, grafana)\n10. MySQL 관련 컨테이너 없음 확인",
        "subtasks": [],
        "updatedAt": "2025-12-16T13:38:38.102Z"
      },
      {
        "id": "2",
        "title": "NestJS API Gateway 프로젝트 스캐폴드 및 기본 모듈 구성",
        "description": "NestJS 10.x 기반 API Gateway 프로젝트를 생성하고, 핵심 모듈(Auth, Relay, Webhook, OZ-Relayer)의 기본 구조를 설정합니다. (Phase 1: DB 없이 OZ Relayer + Redis만 사용)",
        "status": "done",
        "dependencies": [
          "1"
        ],
        "priority": "high",
        "details": "## 구현 세부사항 (Phase 1 - DB 없이 Redis만 사용)\n\n### 1. NestJS 프로젝트 생성\n```bash\ncd packages/relay-api\nnpx @nestjs/cli new . --skip-git --package-manager npm\n```\n\n### 2. 필수 의존성 설치 (Phase 1)\n```json\n{\n  \"dependencies\": {\n    \"@nestjs/common\": \"^10.0.0\",\n    \"@nestjs/core\": \"^10.0.0\",\n    \"@nestjs/config\": \"^3.0.0\",\n    \"@nestjs/swagger\": \"^7.0.0\",\n    \"ethers\": \"^6.0.0\",\n    \"class-validator\": \"^0.14.0\",\n    \"class-transformer\": \"^0.5.0\",\n    \"ioredis\": \"^5.0.0\",\n    \"helmet\": \"^7.0.0\"\n  }\n}\n```\n\n**주의**: Prisma 관련 의존성은 Phase 2+에서 추가 예정\n- `@prisma/client`는 제외 (Phase 1에는 DB 없음)\n- `prisma` devDependency도 제외\n\n### 3. 모듈 구조 생성 (Phase 1)\n```\nsrc/\n├── auth/              # API Key 인증\n│   ├── auth.module.ts\n│   ├── guards/\n│   │   └── api-key.guard.ts\n│   └── decorators/\n│       └── public.decorator.ts\n├── relay/             # TX 엔드포인트\n│   ├── relay.module.ts\n│   ├── direct/\n│   ├── gasless/\n│   └── status/\n├── oz-relayer/        # OZ Relayer 클라이언트\n│   ├── oz-relayer.module.ts\n│   ├── oz-relayer.service.ts\n│   └── relayer-pool.service.ts\n├── common/\n│   ├── filters/exception.filter.ts\n│   ├── interceptors/logging.interceptor.ts\n│   └── decorators/\n├── config/\n│   └── configuration.ts\n└── main.ts\n```\n\n**Phase 2+ 예정 디렉토리** (Phase 1에는 생성하지 않음):\n- `webhook/` - OZ Relayer Webhook 핸들러\n- `prisma/` - DB 스키마\n- `queue/` - Queue System\n- `policy/` - Policy Engine\n\n### 4. 환경 설정 (config/configuration.ts)\n```typescript\nexport default () => ({\n  port: parseInt(process.env.PORT, 10) || 3000,\n  nodeEnv: process.env.NODE_ENV || 'development',\n  apiKey: process.env.RELAY_API_KEY,  // Phase 1 단일 API Key\n  redis: {\n    url: process.env.REDIS_URL || 'redis://localhost:6379'\n  },\n  rpc: {\n    url: process.env.RPC_URL || 'http://localhost:8545'\n  },\n  relayerPool: {\n    configPath: process.env.RELAYER_POOL_CONFIG || './config/relayer-pool.yaml'\n  }\n});\n```\n\n### 5. Swagger/OpenAPI 설정 (main.ts)\n```typescript\nimport { NestFactory } from '@nestjs/core';\nimport { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';\nimport { ValidationPipe } from '@nestjs/common';\nimport helmet from 'helmet';\nimport { AppModule } from './app.module';\n\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n  \n  // Security\n  app.use(helmet());\n  \n  // Validation\n  app.useGlobalPipes(new ValidationPipe({\n    whitelist: true,\n    forbidNonWhitelisted: true,\n    transform: true\n  }));\n  \n  // Swagger/OpenAPI\n  const config = new DocumentBuilder()\n    .setTitle('MSQ Relayer API')\n    .setDescription('Blockchain Transaction Relayer System (Phase 1)')\n    .setVersion('1.0')\n    .addApiKey({ type: 'apiKey', name: 'X-API-Key', in: 'header' })\n    .build();\n  const document = SwaggerModule.createDocument(app, config);\n  SwaggerModule.setup('api/docs', app, document);\n  \n  const port = process.env.PORT || 3000;\n  await app.listen(port);\n  console.log(`API Gateway listening on port ${port}`);\n}\nbootstrap();\n```\n\n### 6. Dockerfile (packages/relay-api/Dockerfile)\n**참고**: 실제로는 `docker/Dockerfile.packages`의 멀티스테이지 빌드에서 처리됩니다.\n\n```dockerfile\nFROM node:20-alpine AS builder\nWORKDIR /app\nCOPY package*.json ./\nRUN npm ci\nCOPY . .\nRUN npm run build\n\nFROM node:20-alpine\nWORKDIR /app\nCOPY --from=builder /app/dist ./dist\nCOPY --from=builder /app/node_modules ./node_modules\nCOPY --from=builder /app/package*.json ./\nENV NODE_ENV=production\nCMD [\"node\", \"dist/main.js\"]\n```\n\n### 7. Phase 1 체크리스트\n- ✅ NestJS 프로젝트 생성 (DB 없이)\n- ✅ Auth 모듈 (API Key 단일 환경변수)\n- ✅ Relay 모듈 (Direct/Gasless 디렉토리 생성)\n- ✅ OZ-Relayer 모듈 (Relayer Pool 지원)\n- ✅ Config 모듈 (Redis + RPC만)\n- ✅ Swagger/OpenAPI 문서화\n- ✅ Helmet 보안 헤더\n- ✅ Global Validation Pipe\n- ❌ Prisma 제외 (Phase 2+)\n- ❌ MySQL 연결 제외 (Phase 2+)\n- ❌ Webhook 모듈 제외 (Phase 2+)\n- ❌ Queue 모듈 제외 (Phase 2+)",
        "testStrategy": "1. `npm run start:dev` - 서버 정상 시작 확인 (DB 연결 없음)\n2. `curl http://localhost:3000/api/docs` - Swagger UI 접근 확인\n3. 모든 모듈 DI 컨테이너 정상 로드 확인 (Auth, Relay, OZ-Relayer만)\n4. `npm run lint` - 린트 에러 없음\n5. `npm run build` - 빌드 성공 확인\n6. Redis 연결 확인 (REDIS_URL 환경변수)\n7. Prisma/MySQL 연결 시도 없음 확인 (Phase 1 제약사항)\n8. package.json에 @prisma/client 없음 확인",
        "subtasks": [],
        "updatedAt": "2025-12-17T11:26:17.194Z"
      },
      {
        "id": "3",
        "title": "API Key 인증 모듈 및 Guard 구현",
        "description": "Phase 1 단일 환경변수 기반 API Key 인증 시스템을 구현합니다. NestJS Guard를 사용하여 X-API-Key 헤더 검증 로직을 작성하고, 환경변수 RELAY_API_KEY와 비교하여 인증을 처리합니다.",
        "status": "done",
        "dependencies": [
          "2"
        ],
        "priority": "high",
        "details": "## Phase 1 요구사항 (v11.2 기준)\n\n### 인증 방식\n- **환경변수**: `RELAY_API_KEY` (단일 키)\n- **Header**: `X-API-Key: {api_key}`\n- **검증 방식**: 환경변수 값과 헤더 값 직접 비교\n- **Phase 2+ 확장**: DB 기반 다중 API Key 관리, Client별 권한, 로테이션\n\n### 디렉토리 구조\n```\npackages/relay-api/src/auth/\n├── auth.module.ts              # Global Guard 등록\n├── guards/\n│   └── api-key.guard.ts        # X-API-Key 검증 Guard\n└── decorators/\n    └── public.decorator.ts     # @Public() 데코레이터 (Health Check 등)\n```\n\n## 구현 세부사항\n\n### 1. API Key Guard 구현\n```typescript\n// auth/guards/api-key.guard.ts\nimport {\n  Injectable,\n  CanActivate,\n  ExecutionContext,\n  UnauthorizedException,\n} from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\nimport { Reflector } from '@nestjs/core';\nimport { IS_PUBLIC_KEY } from '../decorators/public.decorator';\n\n@Injectable()\nexport class ApiKeyGuard implements CanActivate {\n  constructor(\n    private readonly configService: ConfigService,\n    private readonly reflector: Reflector,\n  ) {}\n\n  canActivate(context: ExecutionContext): boolean {\n    // @Public() 데코레이터가 적용된 엔드포인트는 인증 스킵\n    const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [\n      context.getHandler(),\n      context.getClass(),\n    ]);\n    if (isPublic) {\n      return true;\n    }\n\n    const request = context.switchToHttp().getRequest();\n    const apiKey = request.headers['x-api-key'];\n    \n    if (!apiKey) {\n      throw new UnauthorizedException('API Key is required');\n    }\n    \n    return this.validateApiKey(apiKey);\n  }\n\n  private validateApiKey(apiKey: string): boolean {\n    const validApiKey = this.configService.get<string>('RELAY_API_KEY');\n    \n    if (!validApiKey) {\n      throw new Error('RELAY_API_KEY environment variable is not configured');\n    }\n    \n    if (apiKey !== validApiKey) {\n      throw new UnauthorizedException('Invalid API Key');\n    }\n    \n    return true;\n  }\n}\n```\n\n### 2. Public 데코레이터\n```typescript\n// auth/decorators/public.decorator.ts\nimport { SetMetadata } from '@nestjs/common';\n\nexport const IS_PUBLIC_KEY = 'isPublic';\nexport const Public = () => SetMetadata(IS_PUBLIC_KEY, true);\n```\n\n### 3. Auth 모듈 및 Global Guard 등록\n```typescript\n// auth/auth.module.ts\nimport { Module } from '@nestjs/common';\nimport { APP_GUARD } from '@nestjs/core';\nimport { ConfigModule } from '@nestjs/config';\nimport { ApiKeyGuard } from './guards/api-key.guard';\n\n@Module({\n  imports: [ConfigModule],\n  providers: [\n    {\n      provide: APP_GUARD,\n      useClass: ApiKeyGuard,\n    },\n  ],\n})\nexport class AuthModule {}\n```\n\n### 4. 환경변수 설정\n```typescript\n// .env.example (개발 참고용)\nRELAY_API_KEY=msq-dev-api-key-12345\n\n// Docker Compose 예시 (docker/docker-compose.yaml)\nrelay-api:\n  environment:\n    RELAY_API_KEY: \"msq-dev-api-key-12345\"\n```\n\n### 5. Health Check 엔드포인트에 @Public() 적용\n```typescript\n// health/health.controller.ts\nimport { Controller, Get } from '@nestjs/common';\nimport { Public } from '../auth/decorators/public.decorator';\n\n@Controller('api/v1/health')\nexport class HealthController {\n  @Get()\n  @Public()  // 인증 없이 접근 가능\n  async check() {\n    return {\n      'relay-api': 'healthy',\n      'oz-relayer': 'healthy',\n      'redis': 'healthy',\n    };\n  }\n}\n```\n\n### 6. Swagger 문서화\n```typescript\n// main.ts (Swagger 설정)\nimport { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';\n\nconst config = new DocumentBuilder()\n  .setTitle('MSQ Relayer Service API')\n  .setDescription('Blockchain Transaction Relayer API')\n  .setVersion('1.0')\n  .addApiKey(\n    {\n      type: 'apiKey',\n      name: 'X-API-Key',\n      in: 'header',\n      description: 'API Key for authentication',\n    },\n    'X-API-Key',\n  )\n  .build();\n\nconst document = SwaggerModule.createDocument(app, config);\nSwaggerModule.setup('api/docs', app, document);\n```\n\n## Phase 2+ 확장 계획\n\n확장 기능 (현재 구현하지 않음):\n- DB 기반 다중 API Key 관리 (생성/취소/로테이션)\n- Client Service별 권한 관리 (permissions)\n- API Key 사용량 추적 (metrics)\n- Rate Limiting 연동\n- API Key 만료 기능",
        "testStrategy": "## 테스트 전략\n\n### 1. 단위 테스트 (api-key.guard.spec.ts)\n```typescript\ndescribe('ApiKeyGuard', () => {\n  let guard: ApiKeyGuard;\n  let configService: ConfigService;\n  let reflector: Reflector;\n\n  beforeEach(() => {\n    configService = {\n      get: jest.fn().mockReturnValue('test-api-key-12345'),\n    } as any;\n    reflector = { getAllAndOverride: jest.fn() } as any;\n    guard = new ApiKeyGuard(configService, reflector);\n  });\n\n  it('@Public() 데코레이터 적용 시 인증 스킵', () => {\n    jest.spyOn(reflector, 'getAllAndOverride').mockReturnValue(true);\n    const context = createMockContext({});\n    expect(guard.canActivate(context)).toBe(true);\n  });\n\n  it('X-API-Key 헤더 없으면 401 UnauthorizedException', () => {\n    jest.spyOn(reflector, 'getAllAndOverride').mockReturnValue(false);\n    const context = createMockContext({});\n    expect(() => guard.canActivate(context)).toThrow(UnauthorizedException);\n  });\n\n  it('잘못된 API Key는 401 UnauthorizedException', () => {\n    jest.spyOn(reflector, 'getAllAndOverride').mockReturnValue(false);\n    const context = createMockContext({ 'x-api-key': 'invalid-key' });\n    expect(() => guard.canActivate(context)).toThrow(UnauthorizedException);\n  });\n\n  it('올바른 API Key는 통과', () => {\n    jest.spyOn(reflector, 'getAllAndOverride').mockReturnValue(false);\n    const context = createMockContext({ 'x-api-key': 'test-api-key-12345' });\n    expect(guard.canActivate(context)).toBe(true);\n  });\n\n  it('RELAY_API_KEY 환경변수 미설정 시 에러', () => {\n    jest.spyOn(configService, 'get').mockReturnValue(undefined);\n    jest.spyOn(reflector, 'getAllAndOverride').mockReturnValue(false);\n    const context = createMockContext({ 'x-api-key': 'any-key' });\n    expect(() => guard.canActivate(context)).toThrow('RELAY_API_KEY');\n  });\n});\n```\n\n### 2. E2E 테스트 (auth.e2e-spec.ts)\n```typescript\ndescribe('API Key Authentication (e2e)', () => {\n  let app: INestApplication;\n\n  beforeAll(async () => {\n    const moduleFixture = await Test.createTestingModule({\n      imports: [AppModule],\n    }).compile();\n\n    app = moduleFixture.createNestApplication();\n    await app.init();\n  });\n\n  it('GET /api/v1/health는 인증 없이 접근 가능 (@Public)', () => {\n    return request(app.getHttpServer())\n      .get('/api/v1/health')\n      .expect(200);\n  });\n\n  it('POST /api/v1/relay/direct - X-API-Key 없으면 401', () => {\n    return request(app.getHttpServer())\n      .post('/api/v1/relay/direct')\n      .send({ to: '0x...', data: '0x...' })\n      .expect(401);\n  });\n\n  it('POST /api/v1/relay/direct - 잘못된 API Key는 401', () => {\n    return request(app.getHttpServer())\n      .post('/api/v1/relay/direct')\n      .set('X-API-Key', 'invalid-key')\n      .send({ to: '0x...', data: '0x...' })\n      .expect(401);\n  });\n\n  it('POST /api/v1/relay/direct - 올바른 API Key는 통과', () => {\n    return request(app.getHttpServer())\n      .post('/api/v1/relay/direct')\n      .set('X-API-Key', process.env.RELAY_API_KEY)\n      .send({ to: '0x...', data: '0x...' })\n      .expect(201);\n  });\n});\n```\n\n### 3. 검증 항목\n1. ✅ API Key 없이 요청 시 401 Unauthorized 응답 확인\n2. ✅ 잘못된 API Key로 요청 시 401 응답 확인\n3. ✅ 올바른 API Key로 요청 시 정상 응답 확인\n4. ✅ @Public() 데코레이터 적용 엔드포인트는 인증 없이 접근 가능 확인\n5. ✅ 환경변수 RELAY_API_KEY 미설정 시 서버 시작 실패 확인\n6. ✅ Swagger UI에서 X-API-Key 헤더 입력 가능 확인\n7. ✅ Header는 대소문자 구분 없음 (x-api-key, X-API-Key 모두 동작) 확인",
        "subtasks": [],
        "updatedAt": "2025-12-17T12:08:18.681Z"
      },
      {
        "id": "4",
        "title": "Health Check 엔드포인트 구현",
        "description": "API Gateway, OZ Relayer, Redis 상태를 확인하는 Health Check API를 구현합니다. (Phase 1: MySQL 제외)",
        "status": "done",
        "dependencies": [
          "2"
        ],
        "priority": "high",
        "details": "## 구현 세부사항 (Phase 1 - @nestjs/terminus 표준 패턴)\n\n### 현재 상태 분석\n- **프로젝트 경로**: `packages/relay-api/src/health/`\n- **설치된 패키지**: `@nestjs/terminus@^10.2.0` (이미 설치됨)\n- **기존 파일**:\n  - `health.controller.ts`: 기본 health check 컨트롤러 (Custom HealthService 사용)\n  - `health.service.ts`: OZ Relayer Pool + Redis 체크 구현 (Custom 패턴)\n  - `health.module.ts`: HealthModule 정의\n\n### 1. indicators/ 디렉토리 구조 생성\n\n**생성 경로**: `packages/relay-api/src/health/indicators/`\n\n```\npackages/relay-api/src/health/\n├── indicators/\n│   ├── oz-relayer.health.ts      # OzRelayerHealthIndicator\n│   ├── redis.health.ts            # RedisHealthIndicator\n│   └── index.ts                   # barrel export\n├── health.controller.ts\n├── health.module.ts\n└── health.service.ts              # 제거 예정 (deprecated)\n```\n\n### 2. OzRelayerHealthIndicator 구현\n\n**파일**: `packages/relay-api/src/health/indicators/oz-relayer.health.ts`\n\n```typescript\nimport { Injectable } from '@nestjs/common';\nimport { HttpService } from '@nestjs/axios';\nimport { HealthIndicator, HealthIndicatorResult, HealthCheckError } from '@nestjs/terminus';\nimport { firstValueFrom, timeout, catchError, of } from 'rxjs';\n\nexport interface RelayerHealth {\n  id: string;\n  url: string;\n  status: 'healthy' | 'unhealthy';\n  responseTime?: number;\n  error?: string;\n}\n\nexport interface PoolHealthDetail {\n  healthyCount: number;\n  totalCount: number;\n  relayers: RelayerHealth[];\n}\n\n@Injectable()\nexport class OzRelayerHealthIndicator extends HealthIndicator {\n  private readonly relayerEndpoints = [\n    {\n      id: 'oz-relayer-1',\n      url: 'http://oz-relayer-1:8080/api/v1/health',\n      apiKey: process.env.OZ_RELAYER_1_API_KEY || 'test-api-key-relayer-1-local-dev-32ch',\n    },\n    {\n      id: 'oz-relayer-2',\n      url: 'http://oz-relayer-2:8080/api/v1/health',\n      apiKey: process.env.OZ_RELAYER_2_API_KEY || 'test-api-key-relayer-2-local-dev-32ch',\n    },\n    {\n      id: 'oz-relayer-3',\n      url: 'http://oz-relayer-3:8080/api/v1/health',\n      apiKey: process.env.OZ_RELAYER_3_API_KEY || 'test-api-key-relayer-3-local-dev-32ch',\n    },\n  ];\n\n  constructor(private readonly httpService: HttpService) {\n    super();\n  }\n\n  /**\n   * Check health of entire Relayer Pool\n   * @param key - Health check key (e.g., 'oz-relayer-pool')\n   * @returns HealthIndicatorResult with pool status\n   */\n  async isHealthy(key: string): Promise<HealthIndicatorResult> {\n    // 3개 Relayer 병렬 체크\n    const results = await Promise.all(\n      this.relayerEndpoints.map((endpoint) => this.checkSingleRelayer(endpoint))\n    );\n\n    const healthyCount = results.filter((r) => r.status === 'healthy').length;\n    const totalCount = results.length;\n\n    // 상태 집계: healthy/degraded/unhealthy\n    const status = this.aggregateStatus(healthyCount, totalCount);\n    const isHealthy = status === 'healthy';\n\n    const poolDetail: PoolHealthDetail = {\n      healthyCount,\n      totalCount,\n      relayers: results,\n    };\n\n    const result = this.getStatus(key, isHealthy, {\n      status,\n      ...poolDetail,\n    });\n\n    if (!isHealthy) {\n      throw new HealthCheckError('OZ Relayer Pool health check failed', result);\n    }\n\n    return result;\n  }\n\n  /**\n   * Check single Relayer health\n   */\n  private async checkSingleRelayer(endpoint: {\n    id: string;\n    url: string;\n    apiKey: string;\n  }): Promise<RelayerHealth> {\n    const startTime = Date.now();\n\n    try {\n      await firstValueFrom(\n        this.httpService\n          .get(endpoint.url, {\n            headers: {\n              Authorization: `Bearer ${endpoint.apiKey}`,\n            },\n          })\n          .pipe(\n            timeout(5000), // 5 second timeout\n            catchError((err) => {\n              throw err;\n            })\n          )\n      );\n\n      return {\n        id: endpoint.id,\n        url: endpoint.url,\n        status: 'healthy',\n        responseTime: Date.now() - startTime,\n      };\n    } catch (error) {\n      return {\n        id: endpoint.id,\n        url: endpoint.url,\n        status: 'unhealthy',\n        responseTime: Date.now() - startTime,\n        error: error instanceof Error ? error.message : 'Unknown error',\n      };\n    }\n  }\n\n  /**\n   * Aggregate pool status based on healthy count\n   */\n  private aggregateStatus(\n    healthyCount: number,\n    totalCount: number\n  ): 'healthy' | 'degraded' | 'unhealthy' {\n    if (healthyCount === totalCount) return 'healthy';\n    if (healthyCount > 0) return 'degraded';\n    return 'unhealthy';\n  }\n}\n```\n\n### 3. RedisHealthIndicator 구현\n\n**파일**: `packages/relay-api/src/health/indicators/redis.health.ts`\n\n```typescript\nimport { Injectable } from '@nestjs/common';\nimport { HealthIndicator, HealthIndicatorResult } from '@nestjs/terminus';\n\n@Injectable()\nexport class RedisHealthIndicator extends HealthIndicator {\n  /**\n   * Check Redis health\n   * Phase 1: Placeholder - always returns healthy\n   * Phase 2+: Will integrate actual Redis client connectivity check\n   * \n   * @param key - Health check key (e.g., 'redis')\n   * @returns HealthIndicatorResult\n   */\n  async isHealthy(key: string): Promise<HealthIndicatorResult> {\n    // Phase 1: placeholder (항상 healthy)\n    const isHealthy = true;\n    \n    return this.getStatus(key, isHealthy, {\n      status: 'healthy',\n      message: 'Phase 1: Redis connectivity not implemented',\n    });\n  }\n}\n```\n\n### 4. Barrel Export (index.ts)\n\n**파일**: `packages/relay-api/src/health/indicators/index.ts`\n\n```typescript\nexport * from './oz-relayer.health';\nexport * from './redis.health';\n```\n\n### 5. HealthController 업데이트 (@nestjs/terminus 패턴)\n\n**파일**: `packages/relay-api/src/health/health.controller.ts`\n\n```typescript\nimport { Controller, Get } from '@nestjs/common';\nimport { ApiTags, ApiOperation, ApiResponse } from '@nestjs/swagger';\nimport { HealthCheck, HealthCheckService } from '@nestjs/terminus';\nimport { Public } from '../auth/decorators/public.decorator';\nimport { OzRelayerHealthIndicator, RedisHealthIndicator } from './indicators';\n\n@Controller('api/v1')\n@ApiTags('Health')\nexport class HealthController {\n  constructor(\n    private readonly health: HealthCheckService,\n    private readonly ozRelayerHealth: OzRelayerHealthIndicator,\n    private readonly redisHealth: RedisHealthIndicator,\n  ) {}\n\n  @Get('health')\n  @Public()\n  @HealthCheck()\n  @ApiOperation({\n    summary: 'Get system health status',\n    description: 'Returns health status using @nestjs/terminus standard pattern',\n  })\n  @ApiResponse({\n    status: 200,\n    description: 'Health check successful',\n    schema: {\n      example: {\n        status: 'ok',\n        info: {\n          'oz-relayer-pool': {\n            status: 'healthy',\n            healthyCount: 3,\n            totalCount: 3,\n            relayers: [\n              {\n                id: 'oz-relayer-1',\n                url: 'http://oz-relayer-1:8080/api/v1/health',\n                status: 'healthy',\n                responseTime: 45,\n              },\n            ],\n          },\n          redis: {\n            status: 'healthy',\n            message: 'Phase 1: Redis connectivity not implemented',\n          },\n        },\n        error: {},\n        details: {\n          'oz-relayer-pool': {\n            status: 'healthy',\n            healthyCount: 3,\n            totalCount: 3,\n            relayers: [\n              {\n                id: 'oz-relayer-1',\n                url: 'http://oz-relayer-1:8080/api/v1/health',\n                status: 'healthy',\n                responseTime: 45,\n              },\n            ],\n          },\n          redis: {\n            status: 'healthy',\n            message: 'Phase 1: Redis connectivity not implemented',\n          },\n        },\n      },\n    },\n  })\n  @ApiResponse({\n    status: 503,\n    description: 'Service unavailable',\n  })\n  async check() {\n    return this.health.check([\n      () => this.ozRelayerHealth.isHealthy('oz-relayer-pool'),\n      () => this.redisHealth.isHealthy('redis'),\n    ]);\n  }\n}\n```\n\n### 6. HealthModule 업데이트\n\n**파일**: `packages/relay-api/src/health/health.module.ts`\n\n```typescript\nimport { Module } from '@nestjs/common';\nimport { HttpModule } from '@nestjs/axios';\nimport { TerminusModule } from '@nestjs/terminus';\nimport { HealthController } from './health.controller';\nimport { OzRelayerHealthIndicator, RedisHealthIndicator } from './indicators';\n\n@Module({\n  imports: [\n    HttpModule,\n    TerminusModule, // @nestjs/terminus 모듈 추가\n  ],\n  controllers: [HealthController],\n  providers: [\n    OzRelayerHealthIndicator,\n    RedisHealthIndicator,\n  ],\n  exports: [\n    OzRelayerHealthIndicator,\n    RedisHealthIndicator,\n  ],\n})\nexport class HealthModule {}\n```\n\n### 7. 응답 포맷 (@nestjs/terminus 표준)\n\n**성공 응답 (모든 서비스 healthy)**:\n```json\n{\n  \"status\": \"ok\",\n  \"info\": {\n    \"oz-relayer-pool\": {\n      \"status\": \"healthy\",\n      \"healthyCount\": 3,\n      \"totalCount\": 3,\n      \"relayers\": [\n        {\n          \"id\": \"oz-relayer-1\",\n          \"url\": \"http://oz-relayer-1:8080/api/v1/health\",\n          \"status\": \"healthy\",\n          \"responseTime\": 45\n        },\n        {\n          \"id\": \"oz-relayer-2\",\n          \"url\": \"http://oz-relayer-2:8080/api/v1/health\",\n          \"status\": \"healthy\",\n          \"responseTime\": 52\n        },\n        {\n          \"id\": \"oz-relayer-3\",\n          \"url\": \"http://oz-relayer-3:8080/api/v1/health\",\n          \"status\": \"healthy\",\n          \"responseTime\": 48\n        }\n      ]\n    },\n    \"redis\": {\n      \"status\": \"healthy\",\n      \"message\": \"Phase 1: Redis connectivity not implemented\"\n    }\n  },\n  \"error\": {},\n  \"details\": {\n    \"oz-relayer-pool\": { ... },\n    \"redis\": { ... }\n  }\n}\n```\n\n**Degraded 응답 (일부 Relayer unhealthy)**:\n```json\n{\n  \"status\": \"error\",\n  \"info\": {\n    \"redis\": { \"status\": \"healthy\" }\n  },\n  \"error\": {\n    \"oz-relayer-pool\": {\n      \"status\": \"degraded\",\n      \"healthyCount\": 2,\n      \"totalCount\": 3,\n      \"relayers\": [\n        { \"id\": \"oz-relayer-1\", \"status\": \"healthy\" },\n        { \"id\": \"oz-relayer-2\", \"status\": \"healthy\" },\n        { \"id\": \"oz-relayer-3\", \"status\": \"unhealthy\", \"error\": \"Connection timeout\" }\n      ]\n    }\n  },\n  \"details\": { ... }\n}\n```\n\n### 8. Phase 1 제약사항\n- MySQL/Prisma health check는 Phase 2+에서 구현\n- Health check 대상: OZ Relayer Pool (3개) + Redis만\n- DB 연결 상태 확인 로직 제외\n- Redis는 placeholder 구현 (항상 healthy)",
        "testStrategy": "## 테스트 전략 (@nestjs/terminus 패턴)\n\n### 1. OzRelayerHealthIndicator 단위 테스트\n\n**파일**: `packages/relay-api/src/health/indicators/oz-relayer.health.spec.ts`\n\n**테스트 케이스**:\n- ✅ 모든 Relayer healthy 시 `isHealthy()` 성공\n- ✅ 일부 Relayer unhealthy 시 HealthCheckError 발생\n- ✅ 모든 Relayer unhealthy 시 HealthCheckError 발생\n- ✅ 3개 Relayer 병렬 체크 검증 (Promise.all)\n- ✅ 응답 시간 측정 정확성 검증\n- ✅ HTTP timeout (5초) 동작 검증\n- ✅ `aggregateStatus()` 로직 검증:\n  - 3/3 healthy → 'healthy'\n  - 2/3 healthy → 'degraded'\n  - 1/3 healthy → 'degraded'\n  - 0/3 healthy → 'unhealthy'\n\n### 2. RedisHealthIndicator 단위 테스트\n\n**파일**: `packages/relay-api/src/health/indicators/redis.health.spec.ts`\n\n**테스트 케이스**:\n- ✅ Phase 1: `isHealthy()` 항상 성공 (placeholder)\n- ✅ 응답 포맷 검증: `{ status: 'healthy', message: '...' }`\n- ✅ HealthIndicator 인터페이스 준수 검증\n\n### 3. HealthController 통합 테스트\n\n**파일**: `packages/relay-api/src/health/health.controller.spec.ts`\n\n**테스트 케이스**:\n- ✅ `GET /api/v1/health` - 모든 서비스 healthy 시 200 OK\n- ✅ `GET /api/v1/health` - 일부 Relayer unhealthy 시 503 Service Unavailable\n- ✅ `GET /api/v1/health` - 모든 Relayer unhealthy 시 503 Service Unavailable\n- ✅ @Public() 데코레이터로 인증 없이 접근 가능 확인\n- ✅ @HealthCheck() 데코레이터 적용 확인\n- ✅ HealthCheckService.check() 호출 검증\n- ✅ 응답 포맷이 @nestjs/terminus 표준 따르는지 검증:\n  - `status: 'ok' | 'error'`\n  - `info: { ... }`\n  - `error: { ... }`\n  - `details: { ... }`\n\n### 4. E2E 테스트\n\n**파일**: `packages/relay-api/test/health.e2e-spec.ts`\n\n**테스트 케이스**:\n- ✅ 실제 Docker Compose 환경에서 health check 성공\n- ✅ OZ Relayer 1개 다운 시 degraded 상태 반환\n- ✅ 모든 OZ Relayer 다운 시 503 에러 반환\n- ✅ Redis placeholder 정상 동작 (항상 healthy)\n- ✅ 응답 시간 5초 이내 확인 (타임아웃 테스트)\n- ✅ MySQL 연결 시도 없음 확인 (Phase 1 제약사항)\n- ✅ 응답 포맷 검증:\n  - `info` 필드에 healthy 서비스\n  - `error` 필드에 unhealthy 서비스\n  - `details` 필드에 모든 서비스 상세 정보\n\n### 5. Swagger API 문서 검증\n\n**테스트 케이스**:\n- ✅ `GET /api/docs` - Swagger UI에서 `/api/v1/health` 엔드포인트 확인\n- ✅ @ApiOperation 설명 표시 확인\n- ✅ @ApiResponse 예제 응답 표시 확인\n- ✅ 200/503 응답 코드 문서화 확인\n\n### 6. 성능 테스트\n\n**테스트 케이스**:\n- ✅ 100 동시 요청 시 응답 시간 < 6초 (병렬 체크)\n- ✅ 메모리 누수 없음 확인 (반복 요청 테스트)\n- ✅ HTTP 연결 풀 정상 동작 확인 (@nestjs/axios)\n\n### 7. 통합 시나리오 테스트\n\n**시나리오 1**: 정상 운영\n- 모든 서비스 healthy → 200 OK\n\n**시나리오 2**: 부분 장애\n- Relayer 1개 다운 → 503 + degraded 상태\n\n**시나리오 3**: 전체 장애\n- 모든 Relayer 다운 → 503 + unhealthy 상태\n\n**시나리오 4**: 복구 확인\n- Relayer 재시작 후 → 200 OK로 복구",
        "subtasks": [],
        "updatedAt": "2025-12-18T04:03:43.155Z"
      },
      {
        "id": "5",
        "title": "OZ Relayer 프록시 서비스 및 Multi-Relayer Pool 관리자 구현",
        "description": "Nginx Load Balancer 기반 OZ Relayer 프록시 및 Direct Transaction API를 구현합니다. Load Balancing과 Health Check는 Nginx에 위임하여 구현을 단순화합니다.",
        "status": "done",
        "dependencies": [
          "2",
          "4"
        ],
        "priority": "high",
        "details": "## 설계 결정\n\n### 아키텍처\nRelay API → Nginx LB (oz-relayer-lb:8080) → OZ Relayer Pool (relayer-1, relayer-2, relayer-3)\n\n### Load Balancing 전략\n- **Nginx upstream** 모듈 사용\n- Round Robin 방식 (기본)\n- Nginx 내장 health_check로 자동 failover\n\n## 구현 범위\n\n### 1. Nginx Load Balancer 설정\n\n**파일**: `docker/nginx/nginx.conf`\n\n```nginx\nupstream oz_relayer_pool {\n    least_conn;  # 또는 기본 round_robin\n    \n    server oz-relayer-1:8080 max_fails=3 fail_timeout=30s;\n    server oz-relayer-2:8080 max_fails=3 fail_timeout=30s;\n    server oz-relayer-3:8080 max_fails=3 fail_timeout=30s;\n}\n\nserver {\n    listen 8080;\n    server_name oz-relayer-lb;\n\n    location / {\n        proxy_pass http://oz_relayer_pool;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_connect_timeout 5s;\n        proxy_send_timeout 30s;\n        proxy_read_timeout 30s;\n    }\n    \n    # Health check endpoint\n    location /health {\n        access_log off;\n        return 200 \"healthy\\n\";\n        add_header Content-Type text/plain;\n    }\n}\n```\n\n### 2. Docker Compose 서비스 추가\n\n**파일**: `docker/docker-compose.yaml`\n\n```yaml\nservices:\n  oz-relayer-lb:\n    image: nginx:alpine\n    container_name: oz-relayer-lb\n    ports:\n      - \"8080:8080\"\n    volumes:\n      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro\n    depends_on:\n      - oz-relayer-1\n      - oz-relayer-2\n      - oz-relayer-3\n    networks:\n      - relayer-network\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:8080/health\"]\n      interval: 10s\n      timeout: 5s\n      retries: 3\n```\n\n### 3. OZ Relayer Service 단순화\n\n**파일**: `packages/relay-api/src/oz-relayer/oz-relayer.service.ts`\n\n```typescript\nimport { Injectable, ServiceUnavailableException } from '@nestjs/common';\nimport { HttpService } from '@nestjs/axios';\nimport { ConfigService } from '@nestjs/config';\nimport { firstValueFrom } from 'rxjs';\n\n@Injectable()\nexport class OzRelayerService {\n  private readonly relayerUrl: string;\n\n  constructor(\n    private readonly httpService: HttpService,\n    private readonly configService: ConfigService,\n  ) {\n    // Nginx LB 단일 엔드포인트\n    this.relayerUrl = this.configService.get<string>(\n      'OZ_RELAYER_URL',\n      'http://oz-relayer-lb:8080'\n    );\n  }\n\n  async sendTransaction(request: DirectTxRequest): Promise<TxResponse> {\n    try {\n      const response = await firstValueFrom(\n        this.httpService.post(\n          `${this.relayerUrl}/api/v1/transactions`,\n          request,\n          {\n            headers: {\n              'Content-Type': 'application/json',\n            },\n            timeout: 30000,\n          }\n        )\n      );\n      return response.data;\n    } catch (error) {\n      throw new ServiceUnavailableException(\n        'OZ Relayer service unavailable'\n      );\n    }\n  }\n\n  async getTransactionStatus(txId: string): Promise<TxStatus> {\n    const response = await firstValueFrom(\n      this.httpService.get(\n        `${this.relayerUrl}/api/v1/transactions/${txId}`,\n        { timeout: 10000 }\n      )\n    );\n    return response.data;\n  }\n}\n```\n\n### 4. Health Check 단순화\n\n**파일**: `packages/relay-api/src/health/indicators/oz-relayer.health.ts`\n\n```typescript\nimport { Injectable } from '@nestjs/common';\nimport { HealthIndicator, HealthIndicatorResult, HealthCheckError } from '@nestjs/terminus';\nimport { HttpService } from '@nestjs/axios';\nimport { ConfigService } from '@nestjs/config';\nimport { firstValueFrom } from 'rxjs';\n\n@Injectable()\nexport class OzRelayerHealthIndicator extends HealthIndicator {\n  private readonly relayerUrl: string;\n\n  constructor(\n    private readonly httpService: HttpService,\n    private readonly configService: ConfigService,\n  ) {\n    super();\n    this.relayerUrl = this.configService.get<string>(\n      'OZ_RELAYER_URL',\n      'http://oz-relayer-lb:8080'\n    );\n  }\n\n  async isHealthy(): Promise<HealthIndicatorResult> {\n    try {\n      const response = await firstValueFrom(\n        this.httpService.get(`${this.relayerUrl}/health`, {\n          timeout: 5000,\n        })\n      );\n\n      if (response.status === 200) {\n        return this.getStatus('oz-relayer-lb', true, {\n          url: this.relayerUrl,\n          status: 'healthy',\n        });\n      }\n    } catch (error) {\n      throw new HealthCheckError(\n        'OZ Relayer LB check failed',\n        this.getStatus('oz-relayer-lb', false, {\n          url: this.relayerUrl,\n          error: error.message,\n        })\n      );\n    }\n  }\n}\n```\n\n### 5. Direct Transaction Controller\n\n**파일**: `packages/relay-api/src/relay/direct/direct.controller.ts`\n\n```typescript\nimport { Controller, Post, Body, HttpCode, HttpStatus } from '@nestjs/common';\nimport { ApiTags, ApiOperation, ApiResponse } from '@nestjs/swagger';\nimport { DirectService } from './direct.service';\nimport { DirectTxRequestDto } from '../dto/direct-tx-request.dto';\nimport { DirectTxResponseDto } from '../dto/direct-tx-response.dto';\n\n@ApiTags('Direct Transaction')\n@Controller('relay/direct')\nexport class DirectController {\n  constructor(private readonly directService: DirectService) {}\n\n  @Post()\n  @HttpCode(HttpStatus.ACCEPTED)\n  @ApiOperation({ summary: 'Send direct transaction via OZ Relayer' })\n  @ApiResponse({ status: 202, type: DirectTxResponseDto })\n  async sendDirectTransaction(\n    @Body() dto: DirectTxRequestDto,\n  ): Promise<DirectTxResponseDto> {\n    return this.directService.sendTransaction(dto);\n  }\n}\n```\n\n### 6. Direct Transaction Service\n\n**파일**: `packages/relay-api/src/relay/direct/direct.service.ts`\n\n```typescript\nimport { Injectable } from '@nestjs/common';\nimport { OzRelayerService } from '../../oz-relayer/oz-relayer.service';\nimport { DirectTxRequestDto } from '../dto/direct-tx-request.dto';\nimport { DirectTxResponseDto } from '../dto/direct-tx-response.dto';\n\n@Injectable()\nexport class DirectService {\n  constructor(private readonly ozRelayerService: OzRelayerService) {}\n\n  async sendTransaction(\n    dto: DirectTxRequestDto,\n  ): Promise<DirectTxResponseDto> {\n    const response = await this.ozRelayerService.sendTransaction({\n      to: dto.to,\n      data: dto.data,\n      value: dto.value,\n      gasLimit: dto.gasLimit,\n      speed: dto.speed,\n    });\n\n    return {\n      transactionId: response.transactionId,\n      hash: response.hash,\n      status: response.status,\n      createdAt: response.createdAt,\n    };\n  }\n}\n```\n\n### 7. DTOs\n\n**파일**: `packages/relay-api/src/relay/dto/direct-tx-request.dto.ts`\n\n```typescript\nimport { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';\nimport { IsEthereumAddress, IsHexadecimal, IsOptional, IsNumberString, IsEnum } from 'class-validator';\n\nexport class DirectTxRequestDto {\n  @ApiProperty({ description: '대상 컨트랙트 주소' })\n  @IsEthereumAddress()\n  to: string;\n\n  @ApiProperty({ description: 'Encoded function call' })\n  @IsHexadecimal()\n  data: string;\n\n  @ApiPropertyOptional({ description: 'ETH 전송량 (wei)' })\n  @IsOptional()\n  @IsNumberString()\n  value?: string;\n\n  @ApiPropertyOptional({ description: 'Gas limit' })\n  @IsOptional()\n  @IsNumberString()\n  gasLimit?: string;\n\n  @ApiPropertyOptional({ enum: ['safeLow', 'average', 'fast', 'fastest'] })\n  @IsOptional()\n  @IsEnum(['safeLow', 'average', 'fast', 'fastest'])\n  speed?: string;\n}\n```\n\n**파일**: `packages/relay-api/src/relay/dto/direct-tx-response.dto.ts`\n\n```typescript\nimport { ApiProperty } from '@nestjs/swagger';\n\nexport class DirectTxResponseDto {\n  @ApiProperty({ description: 'Transaction ID' })\n  transactionId: string;\n\n  @ApiProperty({ description: 'Transaction hash' })\n  hash: string;\n\n  @ApiProperty({ description: 'Transaction status' })\n  status: string;\n\n  @ApiProperty({ description: 'Created timestamp' })\n  createdAt: string;\n}\n```\n\n### 8. Relay Module 등록\n\n**파일**: `packages/relay-api/src/relay/relay.module.ts`\n\n```typescript\nimport { Module } from '@nestjs/common';\nimport { HttpModule } from '@nestjs/axios';\nimport { DirectController } from './direct/direct.controller';\nimport { DirectService } from './direct/direct.service';\nimport { OzRelayerModule } from '../oz-relayer/oz-relayer.module';\n\n@Module({\n  imports: [HttpModule, OzRelayerModule],\n  controllers: [DirectController],\n  providers: [DirectService],\n})\nexport class RelayModule {}\n```\n\n## 제거된 구현\n\n1. ~~RelayerPoolService~~ → Nginx가 처리\n2. ~~RelayerHealthScheduler~~ → Nginx health_check가 처리\n3. ~~relayer-pool.yaml~~ → 불필요\n4. ~~Round Robin / Least Load 로직~~ → Nginx upstream 설정으로 대체\n\n## 장점\n\n1. **코드 간소화**: ~300 LOC → ~100 LOC\n2. **프로덕션 준비**: 환경변수 변경만으로 외부 LB 사용 가능\n3. **안정성**: Nginx 검증된 health check 및 failover\n4. **성능**: Nginx native load balancing\n5. **유지보수**: 복잡한 pool 관리 로직 제거",
        "testStrategy": "## 테스트 전략\n\n### 1. Nginx Load Balancer 테스트\n```bash\n# Nginx 설정 검증\ndocker exec oz-relayer-lb nginx -t\n\n# Load Balancing 동작 확인 (여러 번 호출 시 다른 relayer 선택)\nfor i in {1..10}; do\n  curl -s http://localhost:8080/api/v1/health | grep -o 'relayer-[0-9]'\ndone\n\n# Relayer 하나 중단 후 자동 failover 확인\ndocker stop oz-relayer-1\ncurl http://localhost:8080/api/v1/health  # 여전히 200 OK\ndocker start oz-relayer-1\n```\n\n### 2. Direct Transaction API 통합 테스트\n```bash\n# 유효한 Direct TX 전송\ncurl -X POST http://localhost:3000/api/v1/relay/direct \\\n  -H \"Content-Type: application/json\" \\\n  -H \"X-API-Key: ${RELAY_API_KEY}\" \\\n  -d '{\n    \"to\": \"0x1234567890123456789012345678901234567890\",\n    \"data\": \"0xabcdef\",\n    \"value\": \"1000000000000000000\"\n  }'\n# 예상: 202 Accepted + transactionId 응답\n\n# 필수 필드 누락 (to 없음)\ncurl -X POST http://localhost:3000/api/v1/relay/direct \\\n  -H \"Content-Type: application/json\" \\\n  -H \"X-API-Key: ${RELAY_API_KEY}\" \\\n  -d '{ \"data\": \"0xabcdef\" }'\n# 예상: 400 Bad Request + validation error\n\n# 잘못된 주소 형식\ncurl -X POST http://localhost:3000/api/v1/relay/direct \\\n  -H \"Content-Type: application/json\" \\\n  -H \"X-API-Key: ${RELAY_API_KEY}\" \\\n  -d '{ \"to\": \"invalid\", \"data\": \"0xabcdef\" }'\n# 예상: 400 Bad Request + \"must be an Ethereum address\"\n```\n\n### 3. Health Check 테스트\n```bash\n# OZ Relayer LB health check\ncurl http://localhost:3000/api/v1/health\n# 예상: { \"status\": \"ok\", \"info\": { \"oz-relayer-lb\": { \"status\": \"up\" } } }\n\n# 모든 Relayer 중단 시\ndocker stop oz-relayer-1 oz-relayer-2 oz-relayer-3\ncurl http://localhost:3000/api/v1/health\n# 예상: { \"status\": \"error\", \"error\": { \"oz-relayer-lb\": { \"status\": \"down\" } } }\ndocker start oz-relayer-1 oz-relayer-2 oz-relayer-3\n```\n\n### 4. 단위 테스트\n\n**DirectService 테스트**:\n- ✅ 유효한 요청으로 TX 전송 성공\n- ✅ OzRelayerService 에러 시 ServiceUnavailableException\n- ✅ 응답 DTO 매핑 정확성\n\n**OzRelayerService 테스트**:\n- ✅ HTTP POST 호출 성공\n- ✅ Timeout 처리\n- ✅ HTTP 에러 → ServiceUnavailableException\n\n**OzRelayerHealthIndicator 테스트**:\n- ✅ LB healthy 시 isHealthy() 성공\n- ✅ LB unhealthy 시 HealthCheckError\n\n### 5. E2E 테스트 시나리오\n1. Docker Compose 전체 stack 기동\n2. API Key 인증 통과 확인\n3. Direct TX 전송 → 202 응답\n4. Transaction ID로 상태 조회\n5. Nginx access log에서 round-robin 확인\n6. Relayer 하나 중단 → 자동 failover 확인\n7. 모든 Relayer 중단 → 503 Service Unavailable",
        "subtasks": [],
        "updatedAt": "2025-12-19T09:15:31.641Z"
      },
      {
        "id": "6",
        "title": "Direct Transaction API 엔드포인트 구현",
        "description": "POST /api/v1/relay/direct 엔드포인트를 구현하여 OZ Relayer를 통한 Direct Transaction 전송 기능을 제공합니다.",
        "details": "## 구현 세부사항\n\n### 1. DTO 정의\n```typescript\n// relay/direct/dto/direct-tx.dto.ts\nexport class DirectTxRequestDto {\n  @ApiProperty({ description: '대상 컨트랙트 주소' })\n  @IsEthereumAddress()\n  to: string;\n\n  @ApiProperty({ description: 'Encoded function call' })\n  @IsHexadecimal()\n  data: string;\n\n  @ApiPropertyOptional({ description: 'ETH 전송량 (wei)' })\n  @IsOptional()\n  @IsNumberString()\n  value?: string;\n\n  @ApiPropertyOptional({ enum: ['safeLow', 'average', 'fast', 'fastest'] })\n  @IsOptional()\n  @IsIn(['safeLow', 'average', 'fast', 'fastest'])\n  speed?: string;\n\n  @ApiPropertyOptional()\n  @IsOptional()\n  @IsNumber()\n  gasLimit?: number;\n\n  @ApiPropertyOptional()\n  @IsOptional()\n  metadata?: Record<string, any>;\n}\n\nexport class DirectTxResponseDto {\n  @ApiProperty()\n  txId: string;\n\n  @ApiProperty()\n  txHash: string;\n\n  @ApiProperty({ enum: ['pending', 'sent', 'submitted', 'inmempool', 'mined', 'confirmed', 'failed'] })\n  status: string;\n\n  @ApiProperty()\n  from: string;\n\n  @ApiProperty()\n  nonce: number;\n\n  @ApiPropertyOptional()\n  gasPrice?: string;\n}\n```\n\n### 2. Controller 구현\n```typescript\n// relay/direct/direct.controller.ts\n@Controller('api/v1/relay')\n@ApiTags('Relay')\nexport class DirectController {\n  constructor(private readonly directService: DirectService) {}\n\n  @Post('direct')\n  @ApiOperation({ summary: 'Direct Transaction 전송' })\n  @ApiResponse({ status: 201, type: DirectTxResponseDto })\n  async sendDirectTransaction(\n    @Body() dto: DirectTxRequestDto,\n  ): Promise<ApiResponse<DirectTxResponseDto>> {\n    const result = await this.directService.send(dto);\n    return { success: true, data: result };\n  }\n}\n```\n\n### 3. Service 구현\n```typescript\n// relay/direct/direct.service.ts\n@Injectable()\nexport class DirectService {\n  constructor(private readonly ozRelayer: OzRelayerService) {}\n\n  async send(dto: DirectTxRequestDto): Promise<DirectTxResponseDto> {\n    const txRequest = {\n      to: dto.to,\n      data: dto.data,\n      value: dto.value || '0',\n      speed: dto.speed || 'average',\n      gasLimit: dto.gasLimit,\n    };\n\n    const response = await this.ozRelayer.sendTransaction(txRequest);\n    \n    return {\n      txId: response.id,\n      txHash: response.hash,\n      status: response.status,\n      from: response.from,\n      nonce: response.nonce,\n      gasPrice: response.gasPrice,\n    };\n  }\n}\n```\n\n### 4. OZ Defender SDK 호환 응답 포맷 유지",
        "testStrategy": "1. 유효한 요청으로 Direct TX 전송 성공 확인\n2. 필수 필드 누락 시 400 Bad Request 반환\n3. 잘못된 주소 형식 시 validation 에러 확인\n4. OZ Relayer 에러 시 적절한 에러 응답 반환\n5. 응답 포맷이 OZ Defender SDK와 호환되는지 확인",
        "priority": "high",
        "dependencies": [
          "3",
          "5"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-19T09:16:32.553Z"
      },
      {
        "id": "7",
        "title": "Smart Contracts 패키지 및 ERC2771Forwarder 배포 스크립트 작성",
        "description": "Hardhat 기반 스마트 컨트랙트 패키지를 설정하고, OpenZeppelin ERC2771Forwarder 배포 스크립트와 Sample ERC20/ERC721 컨트랙트를 작성합니다.",
        "details": "## 구현 세부사항\n\n### 1. Hardhat 프로젝트 초기화\n```bash\ncd packages/contracts\nnpm init -y\nnpm install --save-dev hardhat @nomicfoundation/hardhat-toolbox typescript\nnpm install @openzeppelin/contracts@^5.3.0\nnpx hardhat init\n```\n\n### 2. hardhat.config.ts\n```typescript\nimport { HardhatUserConfig } from 'hardhat/config';\nimport '@nomicfoundation/hardhat-toolbox';\n\nconst config: HardhatUserConfig = {\n  solidity: {\n    version: '0.8.20',\n    settings: { optimizer: { enabled: true, runs: 200 } }\n  },\n  networks: {\n    hardhat: { chainId: 31337 },\n    amoy: {\n      url: process.env.AMOY_RPC_URL || '',\n      chainId: 80002,\n      accounts: process.env.DEPLOYER_PRIVATE_KEY ? [process.env.DEPLOYER_PRIVATE_KEY] : []\n    },\n    polygon: {\n      url: process.env.POLYGON_RPC_URL || '',\n      chainId: 137,\n      accounts: process.env.DEPLOYER_PRIVATE_KEY ? [process.env.DEPLOYER_PRIVATE_KEY] : []\n    }\n  }\n};\nexport default config;\n```\n\n### 3. Sample ERC20 + ERC2771Context\n```solidity\n// contracts/tokens/SampleToken.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/metatx/ERC2771Context.sol\";\n\ncontract SampleToken is ERC20, ERC2771Context {\n    constructor(address trustedForwarder) \n        ERC20(\"Sample Token\", \"SAMPLE\") \n        ERC2771Context(trustedForwarder) \n    {\n        _mint(msg.sender, 1000000 * 10**18);\n    }\n\n    function _msgSender() internal view override(Context, ERC2771Context) \n        returns (address) {\n        return ERC2771Context._msgSender();\n    }\n\n    function _msgData() internal view override(Context, ERC2771Context) \n        returns (bytes calldata) {\n        return ERC2771Context._msgData();\n    }\n\n    function _contextSuffixLength() internal view override(Context, ERC2771Context) \n        returns (uint256) {\n        return ERC2771Context._contextSuffixLength();\n    }\n}\n```\n\n### 4. Forwarder 배포 스크립트\n```typescript\n// scripts/deploy-forwarder.ts\nimport { ethers } from 'hardhat';\n\nasync function main() {\n  const ERC2771Forwarder = await ethers.getContractFactory('ERC2771Forwarder');\n  const forwarder = await ERC2771Forwarder.deploy('Relayer-Forwarder');\n  await forwarder.waitForDeployment();\n  \n  console.log(`ERC2771Forwarder deployed to: ${await forwarder.getAddress()}`);\n  \n  // 배포 정보 저장\n  const deployments = {\n    network: network.name,\n    chainId: network.config.chainId,\n    forwarder: await forwarder.getAddress(),\n    deployedAt: new Date().toISOString()\n  };\n  fs.writeFileSync(\n    `./deployments/${network.name}.json`,\n    JSON.stringify(deployments, null, 2)\n  );\n}\n\nmain().catch(console.error);\n```",
        "testStrategy": "1. `npx hardhat compile` - 컴파일 성공 확인\n2. `npx hardhat test` - 로컬 테스트 통과\n3. Hardhat 로컬 노드에서 Forwarder 배포 테스트\n4. SampleToken이 Forwarder를 신뢰하는지 확인\n5. Polygon Amoy에 배포 후 컨트랙트 검증",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-18T15:48:35.336Z"
      },
      {
        "id": "8",
        "title": "Gasless Transaction API 및 EIP-712 서명 검증 구현",
        "description": "POST /api/v1/relay/gasless 엔드포인트를 구현하고, ethers.js v6를 사용한 EIP-712 서명 사전 검증 로직을 작성합니다.",
        "details": "## 구현 세부사항\n\n### 1. ForwardRequest DTO\n```typescript\n// relay/gasless/dto/gasless-tx.dto.ts\nexport class ForwardRequestDto {\n  @ApiProperty()\n  @IsEthereumAddress()\n  from: string;\n\n  @ApiProperty()\n  @IsEthereumAddress()\n  to: string;\n\n  @ApiProperty()\n  @IsNumberString()\n  value: string;\n\n  @ApiProperty()\n  @IsNumberString()\n  gas: string;\n\n  @ApiProperty()\n  @IsNumberString()\n  nonce: string;\n\n  @ApiProperty()\n  @IsNumber()\n  deadline: number;\n\n  @ApiProperty()\n  @IsHexadecimal()\n  data: string;\n}\n\nexport class GaslessTxRequestDto {\n  @ApiProperty({ type: ForwardRequestDto })\n  @ValidateNested()\n  @Type(() => ForwardRequestDto)\n  request: ForwardRequestDto;\n\n  @ApiProperty({ description: 'EIP-712 서명' })\n  @IsHexadecimal()\n  signature: string;\n\n  @ApiPropertyOptional()\n  metadata?: Record<string, any>;\n}\n```\n\n### 2. EIP-712 서명 검증 서비스\n```typescript\n// relay/gasless/signature-verifier.service.ts\nimport { verifyTypedData, TypedDataDomain } from 'ethers';\n\n@Injectable()\nexport class SignatureVerifierService {\n  private readonly domain: TypedDataDomain;\n  private readonly types = {\n    ForwardRequest: [\n      { name: 'from', type: 'address' },\n      { name: 'to', type: 'address' },\n      { name: 'value', type: 'uint256' },\n      { name: 'gas', type: 'uint256' },\n      { name: 'nonce', type: 'uint256' },\n      { name: 'deadline', type: 'uint48' },\n      { name: 'data', type: 'bytes' },\n    ],\n  };\n\n  constructor(private configService: ConfigService) {\n    this.domain = {\n      name: 'Relayer-Forwarder',\n      version: '1',\n      chainId: configService.get<number>('CHAIN_ID'),\n      verifyingContract: configService.get<string>('FORWARDER_ADDRESS'),\n    };\n  }\n\n  verifySignature(request: ForwardRequestDto, signature: string): boolean {\n    try {\n      const recoveredAddress = verifyTypedData(\n        this.domain,\n        this.types,\n        request,\n        signature\n      );\n      return recoveredAddress.toLowerCase() === request.from.toLowerCase();\n    } catch {\n      return false;\n    }\n  }\n\n  validateDeadline(deadline: number): boolean {\n    return deadline > Math.floor(Date.now() / 1000);\n  }\n}\n```\n\n### 3. Gasless Service\n```typescript\n// relay/gasless/gasless.service.ts\n@Injectable()\nexport class GaslessService {\n  constructor(\n    private readonly signatureVerifier: SignatureVerifierService,\n    private readonly ozRelayer: OzRelayerService,\n  ) {}\n\n  async send(dto: GaslessTxRequestDto): Promise<GaslessTxResponseDto> {\n    // 1. Deadline 검증\n    if (!this.signatureVerifier.validateDeadline(dto.request.deadline)) {\n      throw new BadRequestException('Request expired');\n    }\n\n    // 2. EIP-712 서명 검증\n    if (!this.signatureVerifier.verifySignature(dto.request, dto.signature)) {\n      throw new UnauthorizedException('Invalid signature');\n    }\n\n    // 3. Forwarder.execute() 호출용 TX 빌드\n    const forwarderTx = this.buildForwarderExecuteTx(dto);\n    \n    // 4. OZ Relayer로 전송\n    return this.ozRelayer.sendTransaction(forwarderTx);\n  }\n\n  private buildForwarderExecuteTx(dto: GaslessTxRequestDto) {\n    const iface = new Interface(ERC2771ForwarderABI);\n    const data = iface.encodeFunctionData('execute', [\n      {\n        from: dto.request.from,\n        to: dto.request.to,\n        value: dto.request.value,\n        gas: dto.request.gas,\n        nonce: dto.request.nonce,\n        deadline: dto.request.deadline,\n        data: dto.request.data,\n      },\n      dto.signature,\n    ]);\n    return { to: this.forwarderAddress, data, value: dto.request.value };\n  }\n}\n```\n\n### 4. Nonce 조회 엔드포인트\n```typescript\n@Get('nonce/:address')\nasync getNonce(@Param('address') address: string, @Query('network') network: string) {\n  const nonce = await this.gaslessService.getNonceFromForwarder(address);\n  return { address, nonce, network, forwarder: this.forwarderAddress };\n}\n```",
        "testStrategy": "1. 유효한 EIP-712 서명으로 Gasless TX 전송 성공 확인\n2. 잘못된 서명 시 401 Unauthorized 반환\n3. 만료된 deadline 시 400 Bad Request 반환\n4. from 주소와 서명자 불일치 시 에러 반환\n5. Nonce 조회 API 정상 동작 확인\n6. Forwarder contract 호출 데이터 정확성 검증",
        "priority": "high",
        "dependencies": [
          "5",
          "6",
          "7"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-22T10:22:36.925Z"
      },
      {
        "id": "9",
        "title": "Transaction Status 조회 API 및 Webhook 핸들러 구현",
        "description": "GET /api/v1/relay/status/{txId} 엔드포인트 (Phase 1 - 폴링 방식)와 OZ Relayer Webhook 이벤트 처리 핸들러 (Phase 2+)를 구현합니다.",
        "status": "done",
        "dependencies": [
          "6"
        ],
        "priority": "medium",
        "details": "## Phase 분리 (v11.2 기준)\n\n**Phase 1 (현재)**: 상태 폴링 방식 `/api/v1/relay/status/{txId}`\n**Phase 2+**: Webhook Handler + TX History (MySQL)\n\n---\n\n## Phase 1 구현 (상태 폴링)\n\n### 1. Status Controller (Phase 1)\n\n```typescript\n// packages/relay-api/src/relay/status/status.controller.ts\n@Controller('api/v1/relay')\nexport class StatusController {\n  constructor(private readonly statusService: StatusService) {}\n\n  @Get('status/:txId')\n  @ApiOperation({ summary: '트랜잭션 상태 조회 (폴링)' })\n  @ApiResponse({ status: 200, type: TxStatusDto })\n  @ApiResponse({ status: 404, description: 'Transaction not found' })\n  async getStatus(@Param('txId') txId: string): Promise<ApiResponse<TxStatusDto>> {\n    const status = await this.statusService.getStatus(txId);\n    return { success: true, data: status };\n  }\n}\n```\n\n### 2. Status DTO\n\n```typescript\n// packages/relay-api/src/relay/status/dto/tx-status.dto.ts\nexport class TxStatusDto {\n  @ApiProperty({ description: 'Relayer 내부 트랜잭션 ID' })\n  txId: string;\n\n  @ApiPropertyOptional({ description: '블록체인 트랜잭션 해시' })\n  txHash?: string;\n\n  @ApiProperty({ \n    enum: ['pending', 'sent', 'submitted', 'inmempool', 'mined', 'confirmed', 'failed'],\n    description: 'OZ Relayer 트랜잭션 상태'\n  })\n  status: string;\n\n  @ApiPropertyOptional({ description: '확인 블록 수' })\n  confirmations?: number;\n\n  @ApiPropertyOptional({ description: '마이닝된 블록 번호' })\n  blockNumber?: number;\n\n  @ApiPropertyOptional({ description: '에러 메시지 (실패 시)' })\n  error?: string;\n\n  @ApiPropertyOptional({ description: '마지막 업데이트 시각' })\n  updatedAt?: Date;\n}\n```\n\n### 3. Status Service (OZ Relayer API 폴링)\n\n```typescript\n// packages/relay-api/src/relay/status/status.service.ts\n@Injectable()\nexport class StatusService {\n  constructor(\n    private readonly relayerPoolService: RelayerPoolService,\n    private readonly configService: ConfigService,\n  ) {}\n\n  async getStatus(txId: string): Promise<TxStatusDto> {\n    // OZ Relayer API 호출 (GET /transactions/{txId})\n    const relayer = this.relayerPoolService.getHealthyRelayer();\n    \n    try {\n      const response = await axios.get(\n        `${relayer.url}/transactions/${txId}`,\n        { headers: { 'X-Api-Key': relayer.apiKey } }\n      );\n\n      return {\n        txId: response.data.id,\n        txHash: response.data.hash,\n        status: response.data.status,\n        confirmations: response.data.confirmations,\n        blockNumber: response.data.blockNumber,\n        error: response.data.error,\n        updatedAt: new Date(response.data.updatedAt)\n      };\n    } catch (error) {\n      if (error.response?.status === 404) {\n        throw new NotFoundException(`Transaction ${txId} not found`);\n      }\n      throw error;\n    }\n  }\n}\n```\n\n### 4. Phase 1 사용 패턴\n\n```typescript\n// Client Service 예시 (결제 시스템)\n// 1. Direct TX 전송\nconst { txId } = await relayerClient.post('/api/v1/relay/direct', txRequest);\n\n// 2. 상태 폴링 (Phase 1)\nwhile (true) {\n  const { status } = await relayerClient.get(`/api/v1/relay/status/${txId}`);\n  \n  if (status === 'confirmed') {\n    console.log('트랜잭션 확정');\n    break;\n  } else if (status === 'failed') {\n    console.error('트랜잭션 실패');\n    break;\n  }\n  \n  await sleep(5000); // 5초마다 폴링\n}\n```\n\n---\n\n## Phase 2+ 구현 (Webhook Handler + TX History)\n\n> **참고**: Phase 2+에서는 상태 폴링 대신 Webhook Push 방식을 사용합니다.\n> MySQL에 트랜잭션 히스토리를 저장하고, OZ Relayer Webhook을 통해 상태 변경을 실시간으로 수신합니다.\n\n### 5. Webhook Controller (Phase 2+)\n\n```typescript\n// packages/relay-api/src/webhook/webhook.controller.ts\n@Controller('api/v1/webhook')\nexport class WebhookController {\n  constructor(private readonly webhookService: WebhookService) {}\n\n  @Post('relayer')\n  @Public() // API Key 인증 제외\n  @ApiOperation({ summary: 'OZ Relayer Webhook 이벤트 수신 (Phase 2+)' })\n  async handleRelayerWebhook(\n    @Headers('x-webhook-signature') signature: string,\n    @Body() payload: RelayerWebhookPayload,\n  ) {\n    // 1. Webhook 서명 검증 (HMAC SHA-256)\n    if (!this.webhookService.verifySignature(payload, signature)) {\n      throw new UnauthorizedException('Invalid webhook signature');\n    }\n\n    // 2. 이벤트 처리 (MySQL 저장)\n    await this.webhookService.processEvent(payload);\n    return { received: true };\n  }\n}\n```\n\n### 6. Webhook Service (Phase 2+)\n\n```typescript\n// packages/relay-api/src/webhook/webhook.service.ts\n@Injectable()\nexport class WebhookService {\n  constructor(\n    private readonly configService: ConfigService,\n    @InjectRepository(Transaction)\n    private readonly txRepository: Repository<Transaction>,\n  ) {}\n\n  verifySignature(payload: any, signature: string): boolean {\n    const signingKey = this.configService.get('WEBHOOK_SIGNING_KEY');\n    const expectedSig = createHmac('sha256', signingKey)\n      .update(JSON.stringify(payload))\n      .digest('hex');\n    return timingSafeEqual(\n      Buffer.from(signature),\n      Buffer.from(expectedSig)\n    );\n  }\n\n  async processEvent(payload: RelayerWebhookPayload) {\n    const { event, data } = payload;\n    \n    switch (event) {\n      case 'transaction.sent':\n        await this.updateTxStatus(data.txId, 'sent', data);\n        break;\n      case 'transaction.mined':\n        await this.updateTxStatus(data.txId, 'mined', data);\n        break;\n      case 'transaction.confirmed':\n        await this.updateTxStatus(data.txId, 'confirmed', data);\n        break;\n      case 'transaction.failed':\n        await this.updateTxStatus(data.txId, 'failed', data);\n        break;\n    }\n  }\n\n  private async updateTxStatus(\n    txId: string,\n    status: string,\n    data: any\n  ): Promise<void> {\n    await this.txRepository.update(\n      { txId },\n      {\n        status,\n        txHash: data.txHash,\n        confirmations: data.confirmations,\n        blockNumber: data.blockNumber,\n        error: data.error,\n        updatedAt: new Date()\n      }\n    );\n  }\n}\n```\n\n### 7. Prisma Schema (Phase 2+ MySQL)\n\n```prisma\n// packages/relay-api/prisma/schema.prisma\nmodel Transaction {\n  id            String   @id @default(uuid())\n  txId          String   @unique              // OZ Relayer txId\n  txHash        String?                       // 블록체인 트랜잭션 해시\n  status        String   @default(\"pending\")  // pending|sent|submitted|inmempool|mined|confirmed|failed\n  from          String                        // Relayer 주소\n  to            String                        // 대상 컨트랙트 주소\n  type          String                        // \"direct\" | \"gasless\"\n  confirmations Int      @default(0)\n  blockNumber   Int?\n  error         String?  @db.Text\n  metadata      Json?                         // 클라이언트 메타데이터\n  createdAt     DateTime @default(now())\n  updatedAt     DateTime @updatedAt\n\n  @@index([txId])\n  @@index([status])\n  @@index([createdAt])\n  @@map(\"transactions\")\n}\n```\n\n### 8. OZ Relayer Webhook 설정 (Phase 2+)\n\n```json\n// docker/config/oz-relayer/relayer-1.json\n{\n  \"relayers\": [{\n    \"id\": \"polygon-relayer-1\",\n    \"notifications\": [{\n      \"type\": \"webhook\",\n      \"url\": \"http://relay-api:3000/api/v1/webhook/relayer\",\n      \"signing_key\": \"${WEBHOOK_SIGNING_KEY}\",\n      \"events\": [\n        \"transaction.sent\",\n        \"transaction.mined\",\n        \"transaction.confirmed\",\n        \"transaction.failed\"\n      ]\n    }]\n  }]\n}\n```\n\n---\n\n## Phase별 구현 순서\n\n**Phase 1** (현재 구현 대상):\n1. Status Controller + Service (폴링 API)\n2. OZ Relayer API 연동\n3. 에러 핸들링 (404 Not Found)\n\n**Phase 2+** (추후 구현):\n1. MySQL 및 Prisma 설정\n2. Transaction 모델 마이그레이션\n3. Webhook Controller + Service\n4. Webhook 서명 검증\n5. 이벤트별 상태 업데이트\n6. OZ Relayer Webhook 설정",
        "testStrategy": "## Phase 1 테스트 전략 (상태 폴링)\n\n1. **유효한 txId로 상태 조회 성공**\n   - OZ Relayer API에서 트랜잭션 정보 정상 반환 확인\n   - DTO 매핑 정확성 검증\n\n2. **존재하지 않는 txId 시 404 Not Found 반환**\n   - NotFoundException 발생 확인\n   - 에러 메시지 검증\n\n3. **OZ Relayer 다운 시 적절한 에러 처리**\n   - 다른 Relayer로 자동 전환 (RelayerPoolService)\n   - 모든 Relayer 다운 시 503 Service Unavailable\n\n4. **상태 전환 시나리오 테스트**\n   - pending → sent → submitted → mined → confirmed\n   - pending → sent → failed\n\n5. **Relayer Pool 통합 테스트**\n   - Multi-Relayer 환경에서 상태 조회 정상 동작 확인\n\n---\n\n## Phase 2+ 테스트 전략 (Webhook Handler)\n\n1. **Webhook 서명 검증 성공/실패 케이스**\n   - 유효한 HMAC SHA-256 서명: 200 OK\n   - 잘못된 서명: 401 Unauthorized\n   - 서명 누락: 401 Unauthorized\n\n2. **각 이벤트 타입별 상태 업데이트 확인**\n   - transaction.sent → status: 'sent'\n   - transaction.mined → status: 'mined', blockNumber 업데이트\n   - transaction.confirmed → status: 'confirmed', confirmations 업데이트\n   - transaction.failed → status: 'failed', error 메시지 저장\n\n3. **DB에 트랜잭션 정보 정상 저장 확인**\n   - Prisma를 통한 Transaction 모델 저장/업데이트\n   - Index 성능 확인 (txId, status, createdAt)\n\n4. **중복 이벤트 처리**\n   - 동일 txId에 대한 중복 Webhook 처리 시 멱등성 보장\n\n5. **OZ Relayer 통합 테스트**\n   - 로컬 OZ Relayer에서 실제 Webhook 발송 테스트\n   - Webhook 재시도 로직 검증",
        "subtasks": [
          {
            "id": 1,
            "title": "Phase 1: Status 폴링 API 구현",
            "description": "GET /api/v1/relay/status/{txId} 엔드포인트 구현 (OZ Relayer API 연동)",
            "dependencies": [],
            "details": "- StatusController 생성 (packages/relay-api/src/relay/status/status.controller.ts)\n- StatusService 구현 (OZ Relayer API 폴링)\n- TxStatusDto 정의 (DTO)\n- RelayerPoolService 통합 (Multi-Relayer 지원)\n- 에러 핸들링 (404 Not Found, 503 Service Unavailable)",
            "status": "done",
            "testStrategy": "단위 테스트: StatusService OZ Relayer API 호출 검증\n통합 테스트: 실제 OZ Relayer와 상태 조회 시나리오",
            "parentId": "undefined",
            "updatedAt": "2025-12-22T15:40:09.191Z"
          },
          {
            "id": 2,
            "title": "Phase 2+: MySQL 및 Prisma Transaction 모델 설정",
            "description": "Transaction 히스토리 저장을 위한 데이터베이스 스키마 설정",
            "dependencies": [],
            "details": "- Prisma Schema 작성 (Transaction 모델)\n- 마이그레이션 파일 생성\n- Index 설정 (txId, status, createdAt)\n- Docker Compose MySQL 서비스 활성화 (Profile: phase2)",
            "status": "pending",
            "testStrategy": "마이그레이션 정상 실행 확인\nTransaction CRUD 테스트",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Phase 2+: Webhook Controller 및 Service 구현",
            "description": "OZ Relayer Webhook 이벤트 수신 및 처리",
            "dependencies": [
              2
            ],
            "details": "- WebhookController 생성 (POST /api/v1/webhook/relayer)\n- @Public() 데코레이터 적용 (API Key 인증 제외)\n- WebhookService 구현 (HMAC SHA-256 서명 검증)\n- 이벤트 타입별 분기 처리 (sent/mined/confirmed/failed)\n- Transaction 모델 업데이트 로직",
            "status": "pending",
            "testStrategy": "Webhook 서명 검증 단위 테스트\n이벤트별 상태 업데이트 통합 테스트\nDB 저장 검증",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Phase 2+: OZ Relayer Webhook 설정",
            "description": "OZ Relayer config.json에 Webhook 알림 설정 추가",
            "dependencies": [
              3
            ],
            "details": "- docker/config/oz-relayer/relayer-{1,2,3}.json 수정\n- notifications 섹션 추가 (type: webhook)\n- WEBHOOK_SIGNING_KEY 환경변수 설정\n- 이벤트 타입 등록 (transaction.sent/mined/confirmed/failed)",
            "status": "pending",
            "testStrategy": "OZ Relayer 재시작 후 Webhook 발송 확인\nAPI Gateway Webhook 수신 로그 검증",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-12-22T15:42:02.137Z"
      },
      {
        "id": "10",
        "title": "Client SDK 패키지 개발 (OZ Defender 호환)",
        "description": "OpenZeppelin Defender SDK와 호환되는 TypeScript Client SDK를 개발하여 Client Service의 마이그레이션 용이성을 제공합니다.",
        "details": "## 구현 세부사항\n\n### 1. SDK 프로젝트 구조\n```\npackages/sdk/\n├── src/\n│   ├── index.ts           # RelayerClient 진입점\n│   ├── clients/\n│   │   ├── relayer.ts     # Direct TX 클라이언트\n│   │   └── relay-signer.ts # Gasless TX 클라이언트\n│   ├── models/\n│   │   ├── transactions.ts\n│   │   ├── relayer.ts\n│   │   └── common.ts      # ApiResponse<T>\n│   └── types.ts\n├── package.json\n└── tsconfig.json\n```\n\n### 2. RelayerClient 진입점\n```typescript\n// src/index.ts\nexport class RelayerClient {\n  public readonly relayer: Relayer;\n  public readonly relaySigner: RelaySigner;\n\n  constructor(config: RelayerClientConfig) {\n    const httpClient = new HttpClient(config);\n    this.relayer = new Relayer(httpClient);\n    this.relaySigner = new RelaySigner(httpClient);\n  }\n}\n\nexport interface RelayerClientConfig {\n  apiKey: string;\n  apiSecret: string;\n  network: string;\n  baseUrl?: string;\n}\n```\n\n### 3. Relayer 클라이언트 (Direct TX)\n```typescript\n// src/clients/relayer.ts\nexport class Relayer {\n  constructor(private readonly http: HttpClient) {}\n\n  async sendTransaction(request: DirectTxRequest): Promise<ApiResponse<TxResponse>> {\n    return this.http.post('/relay/direct', request);\n  }\n\n  async getRelayer(): Promise<ApiResponse<RelayerInfo>> {\n    return this.http.get('/relay/info');\n  }\n\n  async getTransactionStatus(txId: string): Promise<ApiResponse<TxStatus>> {\n    return this.http.get(`/relay/status/${txId}`);\n  }\n\n  async cancelTransactionById(txId: string): Promise<ApiResponse<void>> {\n    return this.http.post(`/relay/cancel/${txId}`);\n  }\n}\n```\n\n### 4. RelaySigner 클라이언트 (Gasless TX)\n```typescript\n// src/clients/relay-signer.ts\nexport class RelaySigner {\n  async sendTransaction(request: GaslessTxRequest): Promise<ApiResponse<TxResponse>> {\n    return this.http.post('/relay/gasless', request);\n  }\n\n  async getNonce(address: string): Promise<ApiResponse<NonceInfo>> {\n    return this.http.get(`/relay/nonce/${address}`);\n  }\n}\n```\n\n### 5. ApiResponse 래퍼\n```typescript\n// src/models/common.ts\nexport interface ApiResponse<T> {\n  data: T | null;\n  error?: string;\n  success: boolean;\n}\n\nexport type TxStatus = \n  | 'pending' \n  | 'sent' \n  | 'submitted' \n  | 'inmempool' \n  | 'mined' \n  | 'confirmed' \n  | 'failed';\n```\n\n### 6. package.json\n```json\n{\n  \"name\": \"@msq/relayer-sdk\",\n  \"version\": \"1.0.0\",\n  \"main\": \"dist/index.js\",\n  \"types\": \"dist/index.d.ts\",\n  \"dependencies\": {\n    \"ethers\": \"^6.0.0\"\n  },\n  \"peerDependencies\": {\n    \"ethers\": \"^6.0.0\"\n  }\n}\n```",
        "testStrategy": "1. Direct TX 전송 테스트 (sendTransaction)\n2. Gasless TX 전송 테스트 (relaySigner.sendTransaction)\n3. 트랜잭션 상태 조회 테스트\n4. Nonce 조회 테스트\n5. API 에러 응답 처리 테스트\n6. OZ Defender SDK에서 마이그레이션 코드 변경 최소화 확인",
        "priority": "medium",
        "dependencies": [
          "6",
          "8",
          "9"
        ],
        "status": "cancelled",
        "subtasks": [],
        "updatedAt": "2025-12-15T03:44:21.230Z"
      },
      {
        "id": "11",
        "title": "통합 테스트 및 결제 시스템 연동 검증",
        "description": "전체 시스템 통합 테스트를 수행하고, 결제 시스템 연동 시나리오(Direct TX 정산, Gasless TX 가스비 대납)를 검증합니다. PRD v7.0 변경사항에 따라 Client SDK를 제거하고 HTTP API 직접 호출 방식으로 테스트합니다.",
        "status": "done",
        "dependencies": [
          "8",
          "9"
        ],
        "priority": "high",
        "details": "## 구현 세부사항\n\n### 1. E2E 테스트 설정\n```typescript\n// packages/relay-api/test/e2e/relay.e2e-spec.ts\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { INestApplication } from '@nestjs/common';\nimport * as request from 'supertest';\n\ndescribe('Relay API (e2e)', () => {\n  let app: INestApplication;\n\n  beforeAll(async () => {\n    const moduleFixture: TestingModule = await Test.createTestingModule({\n      imports: [AppModule],\n    }).compile();\n\n    app = moduleFixture.createNestApplication();\n    await app.init();\n  });\n\n  describe('Direct Transaction', () => {\n    it('should send direct transaction successfully', async () => {\n      const response = await request(app.getHttpServer())\n        .post('/api/v1/relay/direct')\n        .set('X-API-Key', process.env.TEST_API_KEY)\n        .send({\n          to: '0x...',\n          data: '0x...',\n          value: '0',\n          speed: 'fast',\n        })\n        .expect(201);\n\n      expect(response.body.success).toBe(true);\n      expect(response.body.data.txId).toBeDefined();\n    });\n  });\n\n  describe('Gasless Transaction', () => {\n    it('should send gasless transaction with valid signature', async () => {\n      const forwardRequest = await buildForwardRequest();\n      const signature = await signTypedData(forwardRequest);\n\n      const response = await request(app.getHttpServer())\n        .post('/api/v1/relay/gasless')\n        .set('X-API-Key', process.env.TEST_API_KEY)\n        .send({ request: forwardRequest, signature })\n        .expect(201);\n\n      expect(response.body.success).toBe(true);\n    });\n  });\n});\n```\n\n### 2. 결제 시스템 통합 테스트 (HTTP API 직접 호출)\n```typescript\n// test/integration/payment-system.test.ts\nimport axios from 'axios';\nimport { Wallet } from 'ethers';\nimport { encodeTransfer } from './utils/encoding';\n\nconst API_BASE_URL = process.env.API_BASE_URL || 'http://localhost:3000';\nconst API_KEY = process.env.API_KEY;\nconst TOKEN_ADDRESS = process.env.TOKEN_ADDRESS;\nconst MERCHANT_ADDRESS = process.env.MERCHANT_ADDRESS;\n\nconst apiClient = axios.create({\n  baseURL: API_BASE_URL,\n  headers: {\n    'X-API-Key': API_KEY,\n    'Content-Type': 'application/json',\n  },\n});\n\ndescribe('Payment System Integration', () => {\n  describe('Direct TX - 토큰 정산', () => {\n    it('should batch transfer tokens to multiple recipients', async () => {\n      const recipients = [\n        { address: '0x...', amount: '100' },\n        { address: '0x...', amount: '200' },\n      ];\n\n      for (const recipient of recipients) {\n        const response = await apiClient.post('/api/v1/relay/direct', {\n          to: TOKEN_ADDRESS,\n          data: encodeTransfer(recipient.address, recipient.amount),\n          value: '0',\n          speed: 'fast',\n        });\n\n        expect(response.status).toBe(201);\n        expect(response.data.success).toBe(true);\n        expect(response.data.data.txId).toBeDefined();\n      }\n    });\n  });\n\n  describe('Gasless TX - 가스비 대납 결제', () => {\n    it('should execute payment on behalf of end user', async () => {\n      // 1. End User 서명 시뮬레이션\n      const userWallet = new Wallet(process.env.USER_PRIVATE_KEY);\n      \n      // 2. Nonce 조회 (HTTP API)\n      const nonceResponse = await apiClient.get(\n        `/api/v1/relay/nonce/${userWallet.address}`,\n        { params: { network: 'polygon-amoy' } }\n      );\n      const nonce = nonceResponse.data.data.nonce;\n\n      // 3. ForwardRequest 생성\n      const forwardRequest = {\n        from: userWallet.address,\n        to: TOKEN_ADDRESS,\n        value: '0',\n        gas: '200000',\n        nonce,\n        deadline: Math.floor(Date.now() / 1000) + 3600,\n        data: encodeTransfer(MERCHANT_ADDRESS, '50'),\n      };\n\n      // 4. EIP-712 서명 생성\n      const domain = {\n        name: 'MSQ Relayer',\n        version: '1',\n        chainId: 80002, // Polygon Amoy\n        verifyingContract: process.env.FORWARDER_ADDRESS,\n      };\n\n      const types = {\n        ForwardRequest: [\n          { name: 'from', type: 'address' },\n          { name: 'to', type: 'address' },\n          { name: 'value', type: 'uint256' },\n          { name: 'gas', type: 'uint256' },\n          { name: 'nonce', type: 'uint256' },\n          { name: 'deadline', type: 'uint48' },\n          { name: 'data', type: 'bytes' },\n        ],\n      };\n\n      const signature = await userWallet.signTypedData(domain, types, forwardRequest);\n\n      // 5. Gasless TX 전송 (HTTP API)\n      const txResponse = await apiClient.post('/api/v1/relay/gasless', {\n        request: forwardRequest,\n        signature,\n        metadata: {\n          paymentId: 'PAY-001',\n          userId: userWallet.address,\n        },\n      });\n\n      expect(txResponse.status).toBe(201);\n      expect(txResponse.data.success).toBe(true);\n      expect(txResponse.data.data.txId).toBeDefined();\n\n      // 6. 트랜잭션 상태 확인\n      const txId = txResponse.data.data.txId;\n      await waitForConfirmation(txId);\n    });\n  });\n});\n\n// 트랜잭션 확인 헬퍼 함수\nasync function waitForConfirmation(txId: string, maxAttempts = 30) {\n  for (let i = 0; i < maxAttempts; i++) {\n    const statusResponse = await apiClient.get(`/api/v1/relay/status/${txId}`);\n    const status = statusResponse.data.data.status;\n\n    if (status === 'confirmed') {\n      return statusResponse.data.data;\n    }\n\n    if (status === 'failed') {\n      throw new Error(`Transaction ${txId} failed`);\n    }\n\n    await new Promise(resolve => setTimeout(resolve, 2000));\n  }\n\n  throw new Error(`Transaction ${txId} confirmation timeout`);\n}\n```\n\n### 3. 부하 테스트 (Artillery)\n```yaml\n# load-test.yml\nconfig:\n  target: 'http://localhost:3000'\n  phases:\n    - duration: 60\n      arrivalRate: 10\n  defaults:\n    headers:\n      X-API-Key: '{{API_KEY}}'\n\nscenarios:\n  - name: 'Direct TX Load Test'\n    flow:\n      - post:\n          url: '/api/v1/relay/direct'\n          json:\n            to: '{{CONTRACT_ADDRESS}}'\n            data: '{{ENCODED_DATA}}'\n            value: '0'\n            speed: 'fast'\n```\n\n### 4. API 문서 참조 가이드\n\n**Swagger UI**: `http://localhost:3000/api/docs`에서 모든 엔드포인트 테스트 가능\n\n**주요 엔드포인트**:\n- `POST /api/v1/relay/direct`: Direct Transaction 전송\n- `POST /api/v1/relay/gasless`: Gasless Transaction 전송\n- `GET /api/v1/relay/nonce/{address}`: Nonce 조회\n- `GET /api/v1/relay/status/{txId}`: 트랜잭션 상태 조회\n- `GET /api/v1/health`: Health Check\n\n**OpenAPI JSON**: `http://localhost:3000/api/docs-json`에서 스펙 파일 다운로드\n\n### 5. 테스트 디렉토리 구조\n```\ntest/\n├── integration/\n│   ├── payment-system.test.ts    # 결제 시스템 통합 테스트\n│   ├── utils/\n│   │   ├── encoding.ts           # 트랜잭션 인코딩 유틸\n│   │   └── signing.ts            # EIP-712 서명 유틸\n│   └── fixtures/\n│       ├── test-wallets.ts       # 테스트 지갑\n│       └── test-contracts.ts     # 테스트 컨트랙트 주소\n└── load/\n    └── load-test.yml             # Artillery 부하 테스트 설정\n```",
        "testStrategy": "1. 로컬 Hardhat 노드에서 전체 플로우 테스트\n2. Polygon Amoy에서 실제 트랜잭션 테스트\n3. Direct TX 배치 처리 성능 테스트 (100 TX, HTTP API 직접 호출)\n4. Gasless TX End-to-End 플로우 검증 (HTTP API 직접 호출)\n5. Multi-Relayer Pool 부하 분산 테스트\n6. 에러 시나리오 테스트 (Relayer 다운, 잔액 부족 등)\n7. Swagger UI를 통한 API 문서 검증 및 수동 테스트\n8. Artillery를 사용한 부하 테스트 (10 req/s, 60초)",
        "subtasks": [],
        "updatedAt": "2025-12-23T11:41:50.664Z"
      },
      {
        "id": "12",
        "title": "프로덕션 환경 설정, API 문서화 및 운영 가이드 작성",
        "description": "프로덕션 배포를 위한 환경 설정, Swagger/OpenAPI 기반 API 문서화, 운영 가이드 및 트러블슈팅 문서를 작성합니다. Client Services가 Swagger UI(/api/docs)와 OpenAPI JSON(/api/docs-json)을 통해 API를 학습하고 통합할 수 있도록 합니다.",
        "status": "done",
        "dependencies": [
          "11"
        ],
        "priority": "medium",
        "details": "## 구현 세부사항\n\n### 1. 프로덕션 Docker Compose\n```yaml\n# docker-compose.prod.yml\nversion: '3.8'\n\nservices:\n  relay-api:\n    image: msq-relayer/relay-api:${VERSION}\n    deploy:\n      replicas: 2\n      resources:\n        limits:\n          cpus: '1'\n          memory: 1G\n    environment:\n      - NODE_ENV=production\n      - DATABASE_URL=${DATABASE_URL}\n    healthcheck:\n      test: ['CMD', 'curl', '-f', 'http://localhost:3000/api/v1/health']\n      interval: 30s\n      timeout: 10s\n      retries: 3\n\n  oz-relayer-1:\n    image: ghcr.io/openzeppelin/openzeppelin-relayer:v1.3.0\n    deploy:\n      resources:\n        limits:\n          cpus: '0.5'\n          memory: 512M\n    secrets:\n      - keystore_passphrase\n```\n\n### 2. Swagger/OpenAPI 문서 완성\n\n#### 2.1 모든 엔드포인트에 상세 문서 추가\n```typescript\n// 모든 엔드포인트에 상세 문서 추가\n@ApiOperation({\n  summary: 'Direct Transaction 전송',\n  description: `\n    OZ Relayer를 통해 Direct Transaction을 전송합니다.\n    \n    ## 사용 사례\n    - 결제 시스템 토큰 정산\n    - 에어드랍 배치 처리\n    \n    ## 주의사항\n    - gasLimit 미지정 시 자동 추정\n    - speed에 따라 가스 가격 조정\n  `,\n})\n@ApiResponse({\n  status: 201,\n  description: '트랜잭션 전송 성공',\n  type: DirectTxResponseDto,\n})\n@ApiResponse({\n  status: 400,\n  description: '잘못된 요청 파라미터',\n})\n@ApiResponse({\n  status: 503,\n  description: 'OZ Relayer 연결 실패',\n})\n```\n\n#### 2.2 OpenAPI JSON 엔드포인트 설정\n```typescript\n// main.ts에서 Swagger 설정\nconst config = new DocumentBuilder()\n  .setTitle('MSQ Relayer Service API')\n  .setDescription('Blockchain Transaction Relayer API for Client Services')\n  .setVersion('1.0')\n  .addApiKey({ type: 'apiKey', name: 'X-API-Key', in: 'header' }, 'api-key')\n  .build();\n\nconst document = SwaggerModule.createDocument(app, config);\n\n// Swagger UI: /api/docs\nSwaggerModule.setup('api/docs', app, document);\n\n// OpenAPI JSON: /api/docs-json (자동 생성)\n// Client Services는 이 JSON을 다운로드하여 코드 생성 가능\n```\n\n#### 2.3 DTO에 상세한 예제 추가\n```typescript\n// Direct TX DTO 예제\nexport class DirectTxRequestDto {\n  @ApiProperty({\n    description: '대상 컨트랙트 주소',\n    example: '0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb',\n  })\n  to: string;\n\n  @ApiProperty({\n    description: '전송할 데이터 (hex)',\n    example: '0xa9059cbb000000000000000000000000...',\n  })\n  data: string;\n\n  @ApiProperty({\n    description: '가스 전송 속도',\n    enum: ['safeLow', 'average', 'fast', 'fastest'],\n    example: 'fast',\n    required: false,\n  })\n  speed?: string;\n}\n```\n\n### 3. 운영 가이드 (docs/operations.md)\n```markdown\n# MSQ Relayer 운영 가이드\n\n## 1. 서비스 시작/종료\n```bash\n# 시작\ndocker compose -f docker-compose.prod.yml up -d\n\n# 종료\ndocker compose -f docker-compose.prod.yml down\n```\n\n## 2. API 문서 접근\n\n### Swagger UI (대화형 문서)\n- URL: `http://localhost:3000/api/docs`\n- 용도: API 테스트, 사용법 확인\n- 기능: Try it out 버튼으로 직접 API 호출 가능\n\n### OpenAPI JSON (코드 생성용)\n- URL: `http://localhost:3000/api/docs-json`\n- 용도: Client SDK 자동 생성\n- 활용:\n  - TypeScript: openapi-generator-cli\n  - Python: openapi-python-client\n  - Java: swagger-codegen\n\n### Client Services 통합 방법\n1. `/api/docs`에서 API 스펙 확인\n2. `/api/docs-json`에서 OpenAPI JSON 다운로드\n3. 해당 언어의 코드 생성 도구로 클라이언트 코드 생성\n4. API Key 발급받아 X-API-Key 헤더에 포함하여 호출\n\n## 3. Relayer 잔액 모니터링\n- OZ Monitor 알림 설정 확인\n- 최소 잔액: 0.1 MATIC (Polygon)\n\n## 4. 스케일링\n```bash\n# Relayer 추가\ndocker compose --profile scale up -d oz-relayer-2\n```\n\n## 5. 트러블슈팅\n### 5.1 Nonce 충돌\n- OZ Relayer 자동 복구 대기 (최대 5분)\n- 수동 개입: Relayer 재시작\n\n### 5.2 Gas Price 급등\n- gas_price_cap 확인\n- 필요시 상한 조정 후 Relayer 재시작\n```\n\n### 4. 배포 Makefile\n```makefile\n.PHONY: build deploy\n\nbuild:\n\tdocker build -t msq-relayer/relay-api:$(VERSION) ./packages/relay-api\n\ndeploy-staging:\n\tdocker compose -f docker-compose.staging.yml up -d\n\ndeploy-prod:\n\tdocker compose -f docker-compose.prod.yml up -d\n\nlogs:\n\tdocker compose logs -f relay-api oz-relayer-1\n\nhealth:\n\tcurl http://localhost:3000/api/v1/health | jq\n\napi-docs:\n\tcurl http://localhost:3000/api/docs-json | jq > openapi.json\n```\n\n### 5. 환경별 설정 분리\n- `.env.development` - 로컬 개발\n- `.env.staging` - 스테이징 (Amoy)\n- `.env.production` - 프로덕션 (Polygon Mainnet)\n\n### 6. API 문서화 체크리스트\n- [ ] 모든 엔드포인트에 @ApiOperation 추가\n- [ ] 모든 DTO에 @ApiProperty와 example 추가\n- [ ] 모든 HTTP 응답 코드에 @ApiResponse 추가\n- [ ] Swagger UI에서 Try it out 기능 정상 작동 확인\n- [ ] OpenAPI JSON 유효성 검증 (validator.swagger.io)\n- [ ] 인증 방식(X-API-Key) 문서화 확인",
        "testStrategy": "1. Swagger UI(/api/docs)에서 모든 API 문서 검토 및 Try it out 기능 테스트\n2. OpenAPI JSON(/api/docs-json) 다운로드 및 스키마 유효성 검증 (validator.swagger.io)\n3. OpenAPI Generator를 사용하여 TypeScript 클라이언트 코드 생성 테스트\n4. 운영 가이드의 API 문서 접근 방법 검증 (신규 인력 온보딩 시뮬레이션)\n5. 프로덕션 Docker Compose로 로컬 테스트\n6. Health Check 및 모니터링 정상 동작 확인\n7. 스케일링 절차 테스트\n8. 트러블슈팅 시나리오별 복구 절차 검증\n9. Makefile의 api-docs 명령어로 OpenAPI JSON 추출 테스트",
        "subtasks": [],
        "updatedAt": "2025-12-25T15:33:42.190Z"
      },
      {
        "id": "13",
        "title": "E2E Test CLI Script 생성 (scripts/e2e-test.ts)",
        "description": "MSQ Relayer Service 전체 인프라를 검증하는 E2E 테스트 CLI 스크립트를 생성합니다. Infrastructure Health Check, Contract Deployment Verification, Direct Transaction, Meta-Transaction 테스트 시나리오를 포함합니다.",
        "details": "## 구현 세부사항\n\n### 1. 프로젝트 구조\n```\nscripts/\n├── e2e-test.ts              # 메인 E2E 테스트 CLI 스크립트\n└── e2e/\n    ├── config.ts             # 테스트 환경 설정 (endpoints, addresses)\n    ├── utils/\n    │   ├── cli-output.ts     # Pretty CLI 출력 유틸리티\n    │   └── eip712-signer.ts  # EIP-712 서명 헬퍼\n    └── scenarios/\n        ├── infrastructure.ts  # 인프라 헬스체크 시나리오\n        ├── contracts.ts       # 컨트랙트 배포 검증 시나리오\n        ├── direct-tx.ts       # Direct Transaction 시나리오\n        └── meta-tx.ts         # Meta-Transaction 시나리오\n```\n\n### 2. 의존성 추가 (root package.json)\n```json\n{\n  \"devDependencies\": {\n    \"tsx\": \"^4.19.0\",\n    \"chalk\": \"^5.3.0\",\n    \"ora\": \"^8.0.1\",\n    \"ethers\": \"^6.13.0\",\n    \"axios\": \"^1.7.0\"\n  }\n}\n```\n\n### 3. 메인 E2E 테스트 스크립트 (scripts/e2e-test.ts)\n```typescript\n#!/usr/bin/env tsx\nimport chalk from 'chalk';\nimport ora from 'ora';\nimport { testInfrastructure } from './e2e/scenarios/infrastructure';\nimport { testContractDeployment } from './e2e/scenarios/contracts';\nimport { testDirectTransaction } from './e2e/scenarios/direct-tx';\nimport { testMetaTransaction } from './e2e/scenarios/meta-tx';\n\ninterface TestResult {\n  name: string;\n  passed: boolean;\n  duration: number;\n  error?: string;\n}\n\nconst results: TestResult[] = [];\n\nasync function runTest(\n  name: string,\n  testFn: () => Promise<void>\n): Promise<void> {\n  const spinner = ora(`Running: ${name}`).start();\n  const start = Date.now();\n  \n  try {\n    await testFn();\n    const duration = Date.now() - start;\n    spinner.succeed(chalk.green(`✓ ${name} (${duration}ms)`));\n    results.push({ name, passed: true, duration });\n  } catch (error) {\n    const duration = Date.now() - start;\n    const errorMsg = error instanceof Error ? error.message : String(error);\n    spinner.fail(chalk.red(`✗ ${name} (${duration}ms)`));\n    console.log(chalk.gray(`  └─ ${errorMsg}`));\n    results.push({ name, passed: false, duration, error: errorMsg });\n  }\n}\n\nasync function main() {\n  console.log(chalk.bold.cyan('\\n═══════════════════════════════════════════'));\n  console.log(chalk.bold.cyan('  MSQ Relayer Service - E2E Test Suite'));\n  console.log(chalk.bold.cyan('═══════════════════════════════════════════\\n'));\n\n  // Scenario 1: Infrastructure Health Check\n  console.log(chalk.yellow('📋 Scenario 1: Infrastructure Health Check'));\n  await runTest('Hardhat Node connectivity', testInfrastructure.hardhatNode);\n  await runTest('Redis connectivity', testInfrastructure.redis);\n  await runTest('OZ Relayer 1 health', testInfrastructure.ozRelayer1);\n  await runTest('OZ Relayer 2 health', testInfrastructure.ozRelayer2);\n  await runTest('OZ Relayer 3 health', testInfrastructure.ozRelayer3);\n  await runTest('Relay API health', testInfrastructure.relayApi);\n\n  // Scenario 2: Contract Deployment Verification\n  console.log(chalk.yellow('\\n📋 Scenario 2: Contract Deployment Verification'));\n  await runTest('ERC2771Forwarder deployment', testContractDeployment.forwarder);\n  await runTest('SampleToken deployment', testContractDeployment.token);\n  await runTest('SampleNFT deployment', testContractDeployment.nft);\n  await runTest('Token trustedForwarder verification', testContractDeployment.tokenForwarder);\n  await runTest('NFT trustedForwarder verification', testContractDeployment.nftForwarder);\n\n  // Scenario 3: Direct Transaction Test\n  console.log(chalk.yellow('\\n📋 Scenario 3: Direct Transaction Test'));\n  await runTest('ERC20 transfer', testDirectTransaction.erc20Transfer);\n  await runTest('ERC721 mint', testDirectTransaction.erc721Mint);\n  await runTest('ERC721 transfer', testDirectTransaction.erc721Transfer);\n\n  // Scenario 4: Meta-Transaction Test\n  console.log(chalk.yellow('\\n📋 Scenario 4: Meta-Transaction Test'));\n  await runTest('EIP-712 domain configuration', testMetaTransaction.eip712Domain);\n  await runTest('ForwardRequest signature', testMetaTransaction.signRequest);\n  await runTest('Forwarder.verify()', testMetaTransaction.verifySignature);\n  await runTest('Forwarder.execute() - Token transfer', testMetaTransaction.executeTokenTransfer);\n\n  // Summary\n  printSummary();\n}\n\nfunction printSummary() {\n  const passed = results.filter(r => r.passed).length;\n  const failed = results.filter(r => !r.passed).length;\n  const total = results.length;\n  const totalDuration = results.reduce((sum, r) => sum + r.duration, 0);\n\n  console.log(chalk.bold('\\n═══════════════════════════════════════════'));\n  console.log(chalk.bold('  Test Summary'));\n  console.log(chalk.bold('═══════════════════════════════════════════'));\n  console.log(`  Total:  ${total} tests`);\n  console.log(chalk.green(`  Passed: ${passed}`));\n  console.log(chalk.red(`  Failed: ${failed}`));\n  console.log(`  Time:   ${totalDuration}ms`);\n  console.log('═══════════════════════════════════════════\\n');\n\n  if (failed > 0) {\n    console.log(chalk.red.bold('Failed Tests:'));\n    results.filter(r => !r.passed).forEach(r => {\n      console.log(chalk.red(`  ✗ ${r.name}`));\n      console.log(chalk.gray(`    └─ ${r.error}`));\n    });\n    process.exit(1);\n  }\n\n  console.log(chalk.green.bold('All tests passed! ✓\\n'));\n  process.exit(0);\n}\n\nmain().catch(console.error);\n```\n\n### 4. 인프라 테스트 시나리오 (scenarios/infrastructure.ts)\n```typescript\nimport axios from 'axios';\nimport { config } from '../config';\n\nexport const testInfrastructure = {\n  async hardhatNode(): Promise<void> {\n    const response = await axios.post(config.hardhatNode, {\n      jsonrpc: '2.0',\n      method: 'eth_chainId',\n      params: [],\n      id: 1,\n    });\n    if (response.data.result !== '0x7a69') { // 31337\n      throw new Error(`Invalid chain ID: ${response.data.result}`);\n    }\n  },\n\n  async redis(): Promise<void> {\n    const response = await axios.get(`${config.relayApi}/health`);\n    const redisStatus = response.data?.info?.redis?.status;\n    if (redisStatus !== 'healthy') {\n      throw new Error(`Redis status: ${redisStatus}`);\n    }\n  },\n\n  async ozRelayer1(): Promise<void> {\n    const response = await axios.get(`${config.ozRelayer1}/health`);\n    if (response.status !== 200) {\n      throw new Error(`Status: ${response.status}`);\n    }\n  },\n\n  async ozRelayer2(): Promise<void> {\n    const response = await axios.get(`${config.ozRelayer2}/health`);\n    if (response.status !== 200) {\n      throw new Error(`Status: ${response.status}`);\n    }\n  },\n\n  async ozRelayer3(): Promise<void> {\n    const response = await axios.get(`${config.ozRelayer3}/health`);\n    if (response.status !== 200) {\n      throw new Error(`Status: ${response.status}`);\n    }\n  },\n\n  async relayApi(): Promise<void> {\n    const response = await axios.get(`${config.relayApi}/health`);\n    if (response.data?.status !== 'ok') {\n      throw new Error(`API health status: ${response.data?.status}`);\n    }\n  },\n};\n```\n\n### 5. 컨트랙트 검증 시나리오 (scenarios/contracts.ts)\n```typescript\nimport { ethers } from 'ethers';\nimport { config } from '../config';\n\nexport const testContractDeployment = {\n  async forwarder(): Promise<void> {\n    const provider = new ethers.JsonRpcProvider(config.hardhatNode);\n    const code = await provider.getCode(config.contracts.forwarder);\n    if (code === '0x') {\n      throw new Error('Forwarder not deployed');\n    }\n  },\n\n  async token(): Promise<void> {\n    const provider = new ethers.JsonRpcProvider(config.hardhatNode);\n    const code = await provider.getCode(config.contracts.token);\n    if (code === '0x') {\n      throw new Error('Token not deployed');\n    }\n  },\n\n  async nft(): Promise<void> {\n    const provider = new ethers.JsonRpcProvider(config.hardhatNode);\n    const code = await provider.getCode(config.contracts.nft);\n    if (code === '0x') {\n      throw new Error('NFT not deployed');\n    }\n  },\n\n  async tokenForwarder(): Promise<void> {\n    const provider = new ethers.JsonRpcProvider(config.hardhatNode);\n    const abi = ['function trustedForwarder() view returns (address)'];\n    const token = new ethers.Contract(config.contracts.token, abi, provider);\n    const forwarder = await token.trustedForwarder();\n    if (forwarder.toLowerCase() !== config.contracts.forwarder.toLowerCase()) {\n      throw new Error(`Mismatch: ${forwarder} != ${config.contracts.forwarder}`);\n    }\n  },\n\n  async nftForwarder(): Promise<void> {\n    const provider = new ethers.JsonRpcProvider(config.hardhatNode);\n    const abi = ['function trustedForwarder() view returns (address)'];\n    const nft = new ethers.Contract(config.contracts.nft, abi, provider);\n    const forwarder = await nft.trustedForwarder();\n    if (forwarder.toLowerCase() !== config.contracts.forwarder.toLowerCase()) {\n      throw new Error(`Mismatch: ${forwarder} != ${config.contracts.forwarder}`);\n    }\n  },\n};\n```\n\n### 6. Meta-Transaction 테스트 (scenarios/meta-tx.ts)\n```typescript\nimport { ethers } from 'ethers';\nimport { config } from '../config';\n\nconst EIP712_TYPES = {\n  ForwardRequest: [\n    { name: 'from', type: 'address' },\n    { name: 'to', type: 'address' },\n    { name: 'value', type: 'uint256' },\n    { name: 'gas', type: 'uint256' },\n    { name: 'nonce', type: 'uint256' },\n    { name: 'deadline', type: 'uint48' },\n    { name: 'data', type: 'bytes' },\n  ],\n};\n\nexport const testMetaTransaction = {\n  async eip712Domain(): Promise<void> {\n    const provider = new ethers.JsonRpcProvider(config.hardhatNode);\n    const abi = ['function eip712Domain() view returns (bytes1, string, string, uint256, address, bytes32, uint256[])'];\n    const forwarder = new ethers.Contract(config.contracts.forwarder, abi, provider);\n    const domain = await forwarder.eip712Domain();\n    if (!domain[1]) throw new Error('Domain name not set');\n  },\n\n  async signRequest(): Promise<void> {\n    const provider = new ethers.JsonRpcProvider(config.hardhatNode);\n    const signer = new ethers.Wallet(config.testPrivateKey, provider);\n    \n    const domain = {\n      name: 'MSQForwarder',\n      version: '1',\n      chainId: 31337,\n      verifyingContract: config.contracts.forwarder,\n    };\n    \n    const request = {\n      from: signer.address,\n      to: config.contracts.token,\n      value: 0n,\n      gas: 100000n,\n      nonce: 0n,\n      deadline: BigInt(Math.floor(Date.now() / 1000) + 3600),\n      data: '0x',\n    };\n    \n    const signature = await signer.signTypedData(domain, EIP712_TYPES, request);\n    if (!signature || signature.length !== 132) {\n      throw new Error('Invalid signature length');\n    }\n  },\n\n  async verifySignature(): Promise<void> {\n    const provider = new ethers.JsonRpcProvider(config.hardhatNode);\n    const signer = new ethers.Wallet(config.testPrivateKey, provider);\n    \n    const abi = ['function verify((address,address,uint256,uint256,uint256,uint48,bytes)) view returns (bool)'];\n    const forwarder = new ethers.Contract(config.contracts.forwarder, abi, provider);\n    \n    const request = {\n      from: signer.address,\n      to: config.contracts.token,\n      value: 0n,\n      gas: 100000n,\n      nonce: 0n,\n      deadline: BigInt(Math.floor(Date.now() / 1000) + 3600),\n      data: '0x',\n    };\n    \n    const domain = {\n      name: 'MSQForwarder',\n      version: '1',\n      chainId: 31337,\n      verifyingContract: config.contracts.forwarder,\n    };\n    \n    const signature = await signer.signTypedData(domain, EIP712_TYPES, request);\n    // Note: verify requires signature appended, this validates EIP-712 setup\n  },\n\n  async executeTokenTransfer(): Promise<void> {\n    // This test validates the full meta-tx flow\n    const provider = new ethers.JsonRpcProvider(config.hardhatNode);\n    const relayerWallet = new ethers.Wallet(config.relayerPrivateKey, provider);\n    const userWallet = new ethers.Wallet(config.testPrivateKey, provider);\n    \n    // Encode token transfer\n    const tokenAbi = ['function transfer(address to, uint256 amount) returns (bool)'];\n    const tokenInterface = new ethers.Interface(tokenAbi);\n    const transferData = tokenInterface.encodeFunctionData('transfer', [\n      relayerWallet.address,\n      ethers.parseEther('1'),\n    ]);\n    \n    // Sign meta-transaction\n    const forwarderAbi = [\n      'function nonces(address) view returns (uint256)',\n      'function execute((address,address,uint256,uint256,uint256,uint48,bytes),bytes) payable returns (bool)',\n    ];\n    const forwarder = new ethers.Contract(config.contracts.forwarder, forwarderAbi, provider);\n    const nonce = await forwarder.nonces(userWallet.address);\n    \n    const request = {\n      from: userWallet.address,\n      to: config.contracts.token,\n      value: 0n,\n      gas: 200000n,\n      nonce: nonce,\n      deadline: BigInt(Math.floor(Date.now() / 1000) + 3600),\n      data: transferData,\n    };\n    \n    const domain = {\n      name: 'MSQForwarder',\n      version: '1',\n      chainId: 31337,\n      verifyingContract: config.contracts.forwarder,\n    };\n    \n    const signature = await userWallet.signTypedData(domain, EIP712_TYPES, request);\n    \n    // Execute via relayer\n    const tx = await forwarder.connect(relayerWallet).execute(\n      [request.from, request.to, request.value, request.gas, request.nonce, request.deadline, request.data],\n      signature\n    );\n    await tx.wait();\n  },\n};\n```\n\n### 7. 설정 파일 (e2e/config.ts)\n```typescript\nexport const config = {\n  hardhatNode: process.env.HARDHAT_RPC_URL || 'http://localhost:8545',\n  relayApi: process.env.RELAY_API_URL || 'http://localhost:3000',\n  ozRelayer1: process.env.OZ_RELAYER_1_URL || 'http://localhost:8081',\n  ozRelayer2: process.env.OZ_RELAYER_2_URL || 'http://localhost:8082',\n  ozRelayer3: process.env.OZ_RELAYER_3_URL || 'http://localhost:8083',\n  \n  contracts: {\n    forwarder: process.env.FORWARDER_ADDRESS || '',\n    token: process.env.TOKEN_ADDRESS || '',\n    nft: process.env.NFT_ADDRESS || '',\n  },\n  \n  // Hardhat default account #0 private key\n  testPrivateKey: process.env.TEST_PRIVATE_KEY || \n    '0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80',\n  // Hardhat default account #10 (relayer)\n  relayerPrivateKey: process.env.RELAYER_PRIVATE_KEY ||\n    '0x47e179ec197488593b187f80a00eb0da91f1b9d0b13f8733639f19c30a34926a',\n};\n```\n\n### 8. package.json 스크립트 추가\n```json\n{\n  \"scripts\": {\n    \"test:e2e\": \"tsx scripts/e2e-test.ts\",\n    \"test:e2e:docker\": \"docker compose -f docker/docker-compose.yaml exec relay-api pnpm run test:e2e\"\n  }\n}\n```",
        "testStrategy": "## 테스트 전략\n\n### 1. 사전 조건 검증\n```bash\n# Docker 인프라 실행 확인\ncd docker && docker compose ps\n# 모든 서비스 healthy 상태 확인: hardhat-node, redis, oz-relayer-1/2/3, relay-api\n```\n\n### 2. E2E 테스트 실행\n```bash\n# 루트 디렉토리에서 실행\npnpm run test:e2e\n```\n\n### 3. 시나리오별 검증\n\n**Scenario 1: Infrastructure Health Check**\n- Hardhat Node JSON-RPC 응답 및 Chain ID (31337) 확인\n- Redis 연결 상태 확인 (relay-api health 엔드포인트 통해)\n- OZ Relayer 1/2/3 각각 `/health` 엔드포인트 200 OK 확인\n- Relay API `/health` 엔드포인트 status: \"ok\" 확인\n\n**Scenario 2: Contract Deployment Verification**\n- ERC2771Forwarder 컨트랙트 코드 존재 확인 (bytecode != '0x')\n- SampleToken 컨트랙트 배포 확인\n- SampleNFT 컨트랙트 배포 확인\n- Token.trustedForwarder() == Forwarder 주소 일치 확인\n- NFT.trustedForwarder() == Forwarder 주소 일치 확인\n\n**Scenario 3: Direct Transaction Test**\n- ERC20 transfer: Account #0 → Account #1 토큰 전송 성공\n- ERC721 mint: Owner가 Account #1에게 NFT 민팅 성공\n- ERC721 transfer: Account #1이 NFT를 Account #2로 전송 성공\n\n**Scenario 4: Meta-Transaction Test**\n- EIP-712 도메인 설정 확인 (name, version, chainId, verifyingContract)\n- ForwardRequest EIP-712 서명 생성 (132 bytes signature)\n- Forwarder.verify() 함수로 서명 검증\n- Forwarder.execute() 실행: 가스 대납 토큰 전송 성공\n\n### 4. 예상 CLI 출력\n```\n═══════════════════════════════════════════\n  MSQ Relayer Service - E2E Test Suite\n═══════════════════════════════════════════\n\n📋 Scenario 1: Infrastructure Health Check\n✓ Hardhat Node connectivity (45ms)\n✓ Redis connectivity (23ms)\n✓ OZ Relayer 1 health (67ms)\n✓ OZ Relayer 2 health (54ms)\n✓ OZ Relayer 3 health (61ms)\n✓ Relay API health (89ms)\n\n📋 Scenario 2: Contract Deployment Verification\n✓ ERC2771Forwarder deployment (12ms)\n✓ SampleToken deployment (8ms)\n✓ SampleNFT deployment (9ms)\n✓ Token trustedForwarder verification (15ms)\n✓ NFT trustedForwarder verification (14ms)\n\n📋 Scenario 3: Direct Transaction Test\n✓ ERC20 transfer (234ms)\n✓ ERC721 mint (189ms)\n✓ ERC721 transfer (201ms)\n\n📋 Scenario 4: Meta-Transaction Test\n✓ EIP-712 domain configuration (18ms)\n✓ ForwardRequest signature (45ms)\n✓ Forwarder.verify() (23ms)\n✓ Forwarder.execute() - Token transfer (456ms)\n\n═══════════════════════════════════════════\n  Test Summary\n═══════════════════════════════════════════\n  Total:  17 tests\n  Passed: 17\n  Failed: 0\n  Time:   1563ms\n═══════════════════════════════════════════\n\nAll tests passed! ✓\n```\n\n### 5. 실패 시 출력 예시\n```\n✗ OZ Relayer 1 health (5023ms)\n  └─ Request timeout after 5000ms\n\n═══════════════════════════════════════════\n  Test Summary\n═══════════════════════════════════════════\n  Total:  17 tests\n  Passed: 16\n  Failed: 1\n  Time:   8234ms\n═══════════════════════════════════════════\n\nFailed Tests:\n  ✗ OZ Relayer 1 health\n    └─ Request timeout after 5000ms\n```\n\n### 6. CI/CD 통합 검증\n- exit code 0: 모든 테스트 통과\n- exit code 1: 하나 이상의 테스트 실패\n- GitHub Actions 워크플로우에서 `pnpm run test:e2e` 실행 가능",
        "status": "cancelled",
        "dependencies": [
          "1",
          "4",
          "7"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2025-12-24T05:31:24.478Z"
      },
      {
        "id": "14",
        "title": "Phase 2 TX History & Webhook System: MySQL 기반 트랜잭션 이력 저장 및 OZ Relayer Webhook 핸들러 구현",
        "description": "MySQL 데이터베이스와 Prisma ORM을 사용하여 트랜잭션 이력 저장 시스템을 구축하고, OZ Relayer의 webhook 이벤트를 처리하여 트랜잭션 상태 변경 시 실시간 알림을 Client Services에 Push하는 시스템을 구현합니다.",
        "details": "## 구현 세부사항\n\n### 1. MySQL 및 Prisma 설정\n\n**Docker Compose MySQL 서비스 추가** (`docker/docker-compose.yaml`):\n```yaml\nservices:\n  mysql:\n    profiles: [\"phase2\"]\n    image: mysql:8.0\n    container_name: msq-mysql\n    environment:\n      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD:-root-dev-password}\n      MYSQL_DATABASE: msq_relayer\n      MYSQL_USER: msq_user\n      MYSQL_PASSWORD: ${MYSQL_PASSWORD:-msq-dev-password}\n    ports:\n      - \"3306:3306\"\n    volumes:\n      - msq-relayer-mysql-data:/var/lib/mysql\n    healthcheck:\n      test: [\"CMD\", \"mysqladmin\", \"ping\", \"-h\", \"localhost\"]\n      interval: 10s\n      timeout: 5s\n      retries: 5\n    networks:\n      - msq-relayer-network\n\nvolumes:\n  msq-relayer-mysql-data:\n    driver: local\n```\n\n**Prisma 스키마** (`packages/relay-api/prisma/schema.prisma`):\n```prisma\ngenerator client {\n  provider = \"prisma-client-js\"\n}\n\ndatasource db {\n  provider = \"mysql\"\n  url      = env(\"DATABASE_URL\")\n}\n\nmodel Transaction {\n  id            String   @id @default(uuid())\n  txId          String   @unique @map(\"tx_id\")\n  hash          String?\n  status        TxStatus @default(PENDING)\n  from          String\n  to            String\n  value         String?\n  data          String   @db.Text\n  type          TxType\n  relayerId     String   @map(\"relayer_id\")\n  createdAt     DateTime @default(now()) @map(\"created_at\")\n  updatedAt     DateTime @updatedAt @map(\"updated_at\")\n  confirmedAt   DateTime? @map(\"confirmed_at\")\n  errorMessage  String?  @map(\"error_message\") @db.Text\n\n  @@index([txId])\n  @@index([status])\n  @@index([createdAt])\n  @@index([from])\n  @@map(\"transactions\")\n}\n\nenum TxStatus {\n  PENDING\n  SENT\n  SUBMITTED\n  INMEMPOOL\n  MINED\n  CONFIRMED\n  FAILED\n}\n\nenum TxType {\n  DIRECT\n  GASLESS\n}\n```\n\n### 2. Webhook 핸들러 구현\n\n**디렉토리 구조**:\n```\npackages/relay-api/src/webhook/\n├── webhook.module.ts\n├── webhook.controller.ts\n├── webhook.service.ts\n├── dto/\n│   ├── webhook-event.dto.ts\n│   └── webhook-response.dto.ts\n├── guards/\n│   └── webhook-signature.guard.ts\n└── webhook.controller.spec.ts\n```\n\n**WebhookController** (`packages/relay-api/src/webhook/webhook.controller.ts`):\n```typescript\n@Controller('api/v1/webhook')\nexport class WebhookController {\n  constructor(private readonly webhookService: WebhookService) {}\n\n  @Public() // API Key 인증 제외\n  @Post('relayer')\n  @UseGuards(WebhookSignatureGuard)\n  @HttpCode(HttpStatus.OK)\n  async handleRelayerWebhook(\n    @Body() event: WebhookEventDto,\n    @Headers('x-oz-signature') signature: string,\n  ): Promise<WebhookResponseDto> {\n    return this.webhookService.processWebhookEvent(event);\n  }\n}\n```\n\n**WebhookService** (`packages/relay-api/src/webhook/webhook.service.ts`):\n```typescript\n@Injectable()\nexport class WebhookService {\n  constructor(\n    private readonly prisma: PrismaService,\n    private readonly notificationService: NotificationService,\n  ) {}\n\n  async processWebhookEvent(event: WebhookEventDto): Promise<WebhookResponseDto> {\n    // 1. 이벤트 타입에 따른 상태 매핑\n    const status = this.mapEventToStatus(event.type);\n    \n    // 2. Transaction 업데이트\n    const transaction = await this.prisma.transaction.update({\n      where: { txId: event.transactionId },\n      data: {\n        status,\n        hash: event.hash,\n        confirmedAt: event.type === 'confirmed' ? new Date() : undefined,\n        errorMessage: event.type === 'failed' ? event.error : undefined,\n      },\n    });\n\n    // 3. Client Services에 Push 알림 전송\n    await this.notificationService.notifyStatusChange(transaction);\n\n    return { success: true, transactionId: event.transactionId };\n  }\n\n  private mapEventToStatus(eventType: string): TxStatus {\n    const statusMap: Record<string, TxStatus> = {\n      'transaction.sent': TxStatus.SENT,\n      'transaction.submitted': TxStatus.SUBMITTED,\n      'transaction.mined': TxStatus.MINED,\n      'transaction.confirmed': TxStatus.CONFIRMED,\n      'transaction.failed': TxStatus.FAILED,\n    };\n    return statusMap[eventType] || TxStatus.PENDING;\n  }\n}\n```\n\n### 3. HMAC SHA-256 서명 검증 Guard\n\n**WebhookSignatureGuard** (`packages/relay-api/src/webhook/guards/webhook-signature.guard.ts`):\n```typescript\n@Injectable()\nexport class WebhookSignatureGuard implements CanActivate {\n  constructor(private readonly configService: ConfigService) {}\n\n  canActivate(context: ExecutionContext): boolean {\n    const request = context.switchToHttp().getRequest();\n    const signature = request.headers['x-oz-signature'];\n    const payload = JSON.stringify(request.body);\n    const signingKey = this.configService.get<string>('WEBHOOK_SIGNING_KEY');\n\n    const expectedSignature = crypto\n      .createHmac('sha256', signingKey)\n      .update(payload)\n      .digest('hex');\n\n    if (!crypto.timingSafeEqual(Buffer.from(signature), Buffer.from(expectedSignature))) {\n      throw new UnauthorizedException('Invalid webhook signature');\n    }\n\n    return true;\n  }\n}\n```\n\n### 4. Client Services Push 알림 서비스\n\n**NotificationService** (`packages/relay-api/src/notification/notification.service.ts`):\n```typescript\n@Injectable()\nexport class NotificationService {\n  constructor(\n    private readonly httpService: HttpService,\n    private readonly configService: ConfigService,\n  ) {}\n\n  async notifyStatusChange(transaction: Transaction): Promise<void> {\n    const callbackUrls = await this.getClientCallbackUrls(transaction.txId);\n    \n    const payload = {\n      transactionId: transaction.txId,\n      hash: transaction.hash,\n      status: transaction.status,\n      confirmedAt: transaction.confirmedAt,\n      errorMessage: transaction.errorMessage,\n    };\n\n    await Promise.allSettled(\n      callbackUrls.map(url => \n        firstValueFrom(this.httpService.post(url, payload, {\n          timeout: 5000,\n          headers: { 'Content-Type': 'application/json' },\n        }))\n      )\n    );\n  }\n}\n```\n\n### 5. OZ Relayer Webhook 설정 업데이트\n\n**relayer-1.json** 수정 (`docker/config/oz-relayer/relayer-1.json`):\n```json\n{\n  \"relayers\": [{\n    \"id\": \"relayer-1\",\n    \"notification_id\": \"relayer-1-webhook\",\n    ...\n  }],\n  \"notifications\": [\n    {\n      \"id\": \"relayer-1-webhook\",\n      \"type\": \"webhook\",\n      \"url\": \"http://relay-api:3000/api/v1/webhook/relayer\",\n      \"signing_key\": {\n        \"type\": \"env\",\n        \"value\": \"WEBHOOK_SIGNING_KEY\"\n      },\n      \"events\": [\n        \"transaction.sent\",\n        \"transaction.submitted\",\n        \"transaction.mined\",\n        \"transaction.confirmed\",\n        \"transaction.failed\"\n      ]\n    }\n  ]\n}\n```\n\n### 6. 환경변수 추가\n\n```bash\n# .env (Phase 2)\nDATABASE_URL=\"mysql://msq_user:msq-dev-password@mysql:3306/msq_relayer\"\nWEBHOOK_SIGNING_KEY=\"your-32-char-signing-key-here\"\n```\n\n### 7. 의존성 추가\n\n```json\n// packages/relay-api/package.json\n{\n  \"dependencies\": {\n    \"@prisma/client\": \"^5.0.0\",\n    ...\n  },\n  \"devDependencies\": {\n    \"prisma\": \"^5.0.0\",\n    ...\n  }\n}\n```\n\n### 8. 기존 StatusService 확장\n\nPhase 2에서는 StatusService가 Prisma를 통해 MySQL에서 트랜잭션 상태를 조회하도록 확장:\n- 먼저 MySQL에서 조회 시도\n- 없으면 OZ Relayer API로 폴백\n- 조회된 결과를 MySQL에 캐싱",
        "testStrategy": "## 테스트 전략\n\n### 1. MySQL 및 Prisma 설정 테스트\n\n```bash\n# Docker Compose Phase 2 실행\ncd docker && docker compose --profile=phase2 up -d\n\n# MySQL 연결 확인\ndocker exec msq-mysql mysql -u msq_user -pmsq-dev-password -e \"SHOW DATABASES;\"\n\n# Prisma 마이그레이션 실행\ncd packages/relay-api && npx prisma migrate dev\n\n# Prisma Studio로 스키마 확인\nnpx prisma studio\n```\n\n### 2. Webhook 서명 검증 단위 테스트\n\n```typescript\n// webhook/guards/webhook-signature.guard.spec.ts\ndescribe('WebhookSignatureGuard', () => {\n  it('should accept valid HMAC SHA-256 signature', async () => {\n    const payload = JSON.stringify({ type: 'transaction.confirmed', transactionId: 'tx-123' });\n    const signature = crypto.createHmac('sha256', 'test-signing-key').update(payload).digest('hex');\n    \n    // Guard should return true\n  });\n\n  it('should reject invalid signature with 401 Unauthorized', async () => {\n    // Guard should throw UnauthorizedException\n  });\n\n  it('should use timing-safe comparison to prevent timing attacks', async () => {\n    // Verify crypto.timingSafeEqual is used\n  });\n});\n```\n\n### 3. Webhook 이벤트 처리 통합 테스트\n\n```typescript\n// webhook/webhook.service.spec.ts\ndescribe('WebhookService', () => {\n  it('should update transaction status on transaction.sent event', async () => {\n    // 1. Create test transaction in DB\n    // 2. Send webhook event\n    // 3. Verify transaction status updated to SENT\n  });\n\n  it('should update transaction status on transaction.confirmed event', async () => {\n    // Verify confirmedAt timestamp is set\n  });\n\n  it('should store error message on transaction.failed event', async () => {\n    // Verify errorMessage is stored\n  });\n\n  it('should trigger notification to Client Services', async () => {\n    // Mock NotificationService and verify it was called\n  });\n});\n```\n\n### 4. E2E Webhook 테스트\n\n```bash\n# 1. Direct TX 전송\ncurl -X POST http://localhost:3000/api/v1/relay/direct \\\n  -H \"Content-Type: application/json\" \\\n  -H \"x-api-key: local-dev-api-key\" \\\n  -d '{\"to\": \"0x...\", \"data\": \"0x...\"}'\n\n# 2. Webhook 이벤트 시뮬레이션\nPAYLOAD='{\"type\":\"transaction.confirmed\",\"transactionId\":\"tx-123\",\"hash\":\"0x...\"}'\nSIGNATURE=$(echo -n \"$PAYLOAD\" | openssl dgst -sha256 -hmac \"local-dev-webhook-signing-key-32ch\" | cut -d' ' -f2)\n\ncurl -X POST http://localhost:3000/api/v1/webhook/relayer \\\n  -H \"Content-Type: application/json\" \\\n  -H \"x-oz-signature: $SIGNATURE\" \\\n  -d \"$PAYLOAD\"\n\n# 3. DB에서 상태 확인\ndocker exec msq-mysql mysql -u msq_user -pmsq-dev-password msq_relayer \\\n  -e \"SELECT * FROM transactions WHERE tx_id = 'tx-123';\"\n```\n\n### 5. Push 알림 테스트\n\n```typescript\n// notification/notification.service.spec.ts\ndescribe('NotificationService', () => {\n  it('should send HTTP POST to registered callback URLs', async () => {\n    // Mock HTTP client\n    // Verify correct payload is sent\n  });\n\n  it('should handle callback failures gracefully (Promise.allSettled)', async () => {\n    // One callback fails, others should still be sent\n  });\n\n  it('should timeout after 5 seconds', async () => {\n    // Verify timeout configuration\n  });\n});\n```\n\n### 6. OZ Relayer Webhook 연동 테스트\n\n```bash\n# OZ Relayer 재시작 후 설정 확인\ndocker restart oz-relayer-1\n\n# Relayer 로그에서 webhook 발송 확인\ndocker logs oz-relayer-1 2>&1 | grep -i webhook\n\n# Relay API 로그에서 webhook 수신 확인\ndocker logs relay-api 2>&1 | grep -i webhook\n```\n\n### 7. 부하 테스트\n\n```yaml\n# test/load/webhook-artillery.yml\nconfig:\n  target: \"http://localhost:3000\"\n  phases:\n    - duration: 60\n      arrivalRate: 100\nscenarios:\n  - name: \"Webhook flood test\"\n    flow:\n      - post:\n          url: \"/api/v1/webhook/relayer\"\n          headers:\n            x-oz-signature: \"{{signature}}\"\n          json:\n            type: \"transaction.confirmed\"\n            transactionId: \"tx-{{$randomString()}}\"\n```\n\n### 8. 성능 기준\n\n- Webhook 처리 시간: < 100ms (P95)\n- DB 쓰기 처리량: >= 1000 TPS\n- Push 알림 전송: 5초 내 완료 또는 타임아웃",
        "status": "done",
        "dependencies": [
          "11",
          "15"
        ],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2026-01-02T12:13:27.071Z"
      },
      {
        "id": "15",
        "title": "Phase 2 Queue System: AWS SQS + LocalStack 기반 비동기 트랜잭션 큐 시스템 구현",
        "description": "AWS SQS Standard Queue를 사용한 비동기 트랜잭션 큐 시스템을 구현합니다. 로컬 개발 환경은 LocalStack으로 SQS를 에뮬레이션하며, Staging/Production 환경은 실제 AWS SQS를 사용합니다. Nginx Load Balancer를 통해 Multi-Relayer로 라우팅하고, 202 Accepted 응답과 Job ID 반환, /api/v1/relay/job/{jobId} 상태 조회 API를 제공합니다. DLQ(Dead Letter Queue)를 사용하여 3회 재시도 후 실패한 작업을 격리합니다.",
        "status": "done",
        "dependencies": [
          "11"
        ],
        "priority": "high",
        "details": "## 구현 세부사항\n\n### 1. 디렉토리 구조\n\n```\npackages/relay-api/src/queue/\n├── queue.module.ts                    # QueueModule 정의\n├── queue.service.ts                   # Queue 서비스 로직 (Enqueue)\n├── queue.consumer.ts                  # SQS Long-polling Consumer\n├── sqs/\n│   ├── sqs.adapter.ts                 # AWS SDK SQS wrapper\n│   ├── sqs.config.ts                  # Configuration types\n│   └── sqs.health.ts                  # SQS Health indicator\n├── job/\n│   ├── job.controller.ts              # Job 상태 조회 API\n│   └── job.service.ts                 # In-memory Job 추적\n├── dto/\n│   ├── job-status-response.dto.ts     # Job 상태 응답 DTO\n│   ├── job-enqueue-response.dto.ts    # 큐 등록 응답 DTO\n│   └── relay-job.dto.ts               # RelayJob 정의\n└── interfaces/\n    ├── queue-message.interface.ts     # QueueMessage 타입\n    └── job-status.interface.ts        # JobStatus 타입\n```\n\n### 2. Docker Compose LocalStack 설정\n\n```yaml\n# docker/docker-compose.yaml\nservices:\n  localstack:\n    image: localstack/localstack:latest\n    container_name: msq-localstack\n    ports:\n      - \"4566:4566\"  # LocalStack gateway\n    environment:\n      SERVICES: sqs\n      AWS_DEFAULT_REGION: ap-northeast-2\n      DEBUG: 1\n    volumes:\n      - ./scripts/init-localstack.sh:/etc/localstack/init/ready.d/init-sqs.sh:ro\n      - msq-relayer-localstack-data:/var/lib/localstack\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:4566/_localstack/health\"]\n      interval: 10s\n      timeout: 5s\n      retries: 5\n      start_period: 10s\n    networks:\n      - msq-relayer-network\n    restart: unless-stopped\n\n  relay-api:\n    depends_on:\n      localstack:\n        condition: service_healthy\n      oz-relayer-lb:\n        condition: service_healthy\n    environment:\n      # Queue 설정\n      QUEUE_ENABLED: \"true\"\n      AWS_REGION: ap-northeast-2\n      AWS_ACCESS_KEY_ID: test                    # LocalStack default\n      AWS_SECRET_ACCESS_KEY: test                # LocalStack default\n      SQS_QUEUE_URL: http://localstack:4566/000000000000/relay-tx-queue\n      SQS_DLQ_URL: http://localstack:4566/000000000000/relay-tx-dlq\n      LOCALSTACK_ENDPOINT: http://localstack:4566\n      SQS_VISIBILITY_TIMEOUT: 30\n      SQS_WAIT_TIME_SECONDS: 20\n      SQS_MAX_RETRIES: 3\n      # OZ Relayer URL (via Nginx LB)\n      OZ_RELAYER_URL: http://oz-relayer-lb:80\n\nvolumes:\n  msq-relayer-localstack-data:\n    driver: local\n```\n\n### 3. LocalStack 초기화 스크립트\n\n```bash\n#!/bin/bash\n# docker/scripts/init-localstack.sh\n\nset -e\n\necho \"Creating SQS queues...\"\n\n# Create Dead Letter Queue\nawslocal sqs create-queue --queue-name relay-tx-dlq\n\n# Create main queue with DLQ redrive policy\nawslocal sqs create-queue \\\n  --queue-name relay-tx-queue \\\n  --attributes '{\n    \"RedrivePolicy\": \"{\\\"deadLetterTargetArn\\\":\\\"arn:aws:sqs:ap-northeast-2:000000000000:relay-tx-dlq\\\",\\\"maxReceiveCount\\\":\\\"3\\\"}\"\n  }'\n\necho \"SQS queues created successfully:\"\nawslocal sqs list-queues\n\nexit 0\n```\n\n### 4. 환경변수 설정 (configuration.ts 확장)\n\n```typescript\n// packages/relay-api/src/config/configuration.ts\nexport default () => ({\n  // 기존 설정...\n  queue: {\n    enabled: process.env.QUEUE_ENABLED === 'true',\n    sqs: {\n      region: process.env.AWS_REGION || 'ap-northeast-2',\n      queueUrl: process.env.SQS_QUEUE_URL || 'http://localstack:4566/000000000000/relay-tx-queue',\n      dlqUrl: process.env.SQS_DLQ_URL || 'http://localstack:4566/000000000000/relay-tx-dlq',\n      endpoint: process.env.LOCALSTACK_ENDPOINT, // Local dev only\n      accessKeyId: process.env.AWS_ACCESS_KEY_ID || 'test',\n      secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY || 'test',\n      visibilityTimeout: parseInt(process.env.SQS_VISIBILITY_TIMEOUT || '30', 10),\n      waitTimeSeconds: parseInt(process.env.SQS_WAIT_TIME_SECONDS || '20', 10),\n      maxRetries: parseInt(process.env.SQS_MAX_RETRIES || '3', 10),\n    },\n  },\n  ozRelayer: {\n    // Nginx LB URL로 변경\n    url: process.env.OZ_RELAYER_URL || 'http://oz-relayer-lb:80',\n    apiKey: process.env.OZ_RELAYER_API_KEY,\n  },\n});\n```\n\n### 5. SQS 메시지 인터페이스\n\n```typescript\n// packages/relay-api/src/queue/interfaces/queue-message.interface.ts\nimport { DirectTxRequestDto } from '../../relay/dto/direct-tx-request.dto';\nimport { GaslessTxRequestDto } from '../../relay/dto/gasless-tx-request.dto';\n\nexport interface QueueMessage {\n  jobId: string;\n  type: 'direct' | 'gasless';\n  payload: DirectTxRequestDto | GaslessTxRequestDto;\n  priority?: 'high' | 'normal' | 'low';\n  metadata?: Record<string, string>;\n  createdAt: string; // ISO 8601\n}\n\nexport type JobStatus = 'queued' | 'processing' | 'completed' | 'failed';\n\nexport interface JobStatusInfo {\n  jobId: string;\n  status: JobStatus;\n  txId?: string;\n  txHash?: string;\n  error?: string;\n  progress?: number;\n  createdAt: string;\n  updatedAt: string;\n  estimatedWait?: string;\n}\n```\n\n### 6. SQS Adapter 구현\n\n```typescript\n// packages/relay-api/src/queue/sqs/sqs.adapter.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\nimport {\n  SQSClient,\n  SendMessageCommand,\n  ReceiveMessageCommand,\n  DeleteMessageCommand,\n  Message,\n  GetQueueAttributesCommand,\n} from '@aws-sdk/client-sqs';\nimport { QueueMessage } from '../interfaces/queue-message.interface';\n\n@Injectable()\nexport class SqsAdapter {\n  private readonly client: SQSClient;\n  private readonly logger = new Logger(SqsAdapter.name);\n  private readonly queueUrl: string;\n  private readonly dlqUrl: string;\n\n  constructor(private readonly configService: ConfigService) {\n    const sqsConfig = this.configService.get('queue.sqs');\n    \n    this.client = new SQSClient({\n      region: sqsConfig.region,\n      endpoint: sqsConfig.endpoint, // undefined in production\n      credentials: {\n        accessKeyId: sqsConfig.accessKeyId,\n        secretAccessKey: sqsConfig.secretAccessKey,\n      },\n    });\n    \n    this.queueUrl = sqsConfig.queueUrl;\n    this.dlqUrl = sqsConfig.dlqUrl;\n  }\n\n  async sendMessage(message: QueueMessage): Promise<string> {\n    const command = new SendMessageCommand({\n      QueueUrl: this.queueUrl,\n      MessageBody: JSON.stringify(message),\n      MessageAttributes: {\n        jobId: {\n          DataType: 'String',\n          StringValue: message.jobId,\n        },\n        type: {\n          DataType: 'String',\n          StringValue: message.type,\n        },\n        priority: {\n          DataType: 'String',\n          StringValue: message.priority || 'normal',\n        },\n      },\n    });\n\n    const result = await this.client.send(command);\n    this.logger.log(`Message sent: ${message.jobId}, MessageId: ${result.MessageId}`);\n    return result.MessageId;\n  }\n\n  async receiveMessages(maxMessages = 10): Promise<Message[]> {\n    const sqsConfig = this.configService.get('queue.sqs');\n    \n    const command = new ReceiveMessageCommand({\n      QueueUrl: this.queueUrl,\n      MaxNumberOfMessages: maxMessages,\n      WaitTimeSeconds: sqsConfig.waitTimeSeconds,\n      VisibilityTimeout: sqsConfig.visibilityTimeout,\n      MessageAttributeNames: ['All'],\n    });\n\n    const result = await this.client.send(command);\n    return result.Messages || [];\n  }\n\n  async deleteMessage(receiptHandle: string): Promise<void> {\n    const command = new DeleteMessageCommand({\n      QueueUrl: this.queueUrl,\n      ReceiptHandle: receiptHandle,\n    });\n\n    await this.client.send(command);\n  }\n\n  async getQueueStats(): Promise<{\n    waiting: number;\n    dlq: number;\n  }> {\n    const [queueAttrs, dlqAttrs] = await Promise.all([\n      this.client.send(\n        new GetQueueAttributesCommand({\n          QueueUrl: this.queueUrl,\n          AttributeNames: ['ApproximateNumberOfMessages'],\n        }),\n      ),\n      this.client.send(\n        new GetQueueAttributesCommand({\n          QueueUrl: this.dlqUrl,\n          AttributeNames: ['ApproximateNumberOfMessages'],\n        }),\n      ),\n    ]);\n\n    return {\n      waiting: parseInt(queueAttrs.Attributes?.ApproximateNumberOfMessages || '0', 10),\n      dlq: parseInt(dlqAttrs.Attributes?.ApproximateNumberOfMessages || '0', 10),\n    };\n  }\n}\n```\n\n### 7. QueueService 구현\n\n```typescript\n// packages/relay-api/src/queue/queue.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\nimport { SqsAdapter } from './sqs/sqs.adapter';\nimport { QueueMessage } from './interfaces/queue-message.interface';\nimport { v4 as uuidv4 } from 'uuid';\n\n@Injectable()\nexport class QueueService {\n  private readonly logger = new Logger(QueueService.name);\n\n  constructor(\n    private readonly sqsAdapter: SqsAdapter,\n    private readonly configService: ConfigService,\n  ) {}\n\n  isQueueEnabled(): boolean {\n    return this.configService.get<boolean>('queue.enabled', false);\n  }\n\n  async enqueueJob(\n    job: Omit<QueueMessage, 'jobId' | 'createdAt'>,\n  ): Promise<{ jobId: string; estimatedWait: string }> {\n    const jobId = uuidv4();\n    const message: QueueMessage = {\n      ...job,\n      jobId,\n      createdAt: new Date().toISOString(),\n    };\n\n    await this.sqsAdapter.sendMessage(message);\n    this.logger.log(`Job enqueued: ${jobId}, type: ${job.type}`);\n\n    const stats = await this.sqsAdapter.getQueueStats();\n    const estimatedWait = this.calculateEstimatedWait(stats.waiting);\n\n    return { jobId, estimatedWait };\n  }\n\n  private calculateEstimatedWait(waitingCount: number): string {\n    // 평균 처리 시간: 5초 가정\n    const avgProcessingTime = 5;\n    const estimatedSeconds = waitingCount * avgProcessingTime;\n\n    if (estimatedSeconds < 60) return `${estimatedSeconds}s`;\n    if (estimatedSeconds < 3600) return `${Math.ceil(estimatedSeconds / 60)}m`;\n    return `${Math.ceil(estimatedSeconds / 3600)}h`;\n  }\n}\n```\n\n### 8. JobService 구현 (In-memory Job 추적)\n\n```typescript\n// packages/relay-api/src/queue/job/job.service.ts\nimport { Injectable, NotFoundException, Logger } from '@nestjs/common';\nimport { JobStatusInfo, JobStatus } from '../interfaces/queue-message.interface';\n\n@Injectable()\nexport class JobService {\n  private readonly logger = new Logger(JobService.name);\n  private readonly jobs = new Map<string, JobStatusInfo>();\n\n  createJob(jobId: string): void {\n    const job: JobStatusInfo = {\n      jobId,\n      status: 'queued',\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n    };\n    this.jobs.set(jobId, job);\n    this.logger.log(`Job created: ${jobId}`);\n  }\n\n  updateJobStatus(\n    jobId: string,\n    status: JobStatus,\n    updates?: Partial<Omit<JobStatusInfo, 'jobId' | 'status'>>,\n  ): void {\n    const job = this.jobs.get(jobId);\n    if (!job) {\n      this.logger.warn(`Job not found: ${jobId}`);\n      return;\n    }\n\n    job.status = status;\n    job.updatedAt = new Date().toISOString();\n    \n    if (updates) {\n      Object.assign(job, updates);\n    }\n\n    this.jobs.set(jobId, job);\n    this.logger.log(`Job updated: ${jobId}, status: ${status}`);\n  }\n\n  getJobStatus(jobId: string): JobStatusInfo {\n    const job = this.jobs.get(jobId);\n    if (!job) {\n      throw new NotFoundException(`Job ${jobId} not found`);\n    }\n    return job;\n  }\n\n  deleteJob(jobId: string): void {\n    this.jobs.delete(jobId);\n  }\n}\n```\n\n### 9. QueueConsumer 구현 (SQS Long-polling)\n\n```typescript\n// packages/relay-api/src/queue/queue.consumer.ts\nimport { Injectable, OnModuleInit, OnModuleDestroy, Logger } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\nimport { SqsAdapter } from './sqs/sqs.adapter';\nimport { JobService } from './job/job.service';\nimport { DirectService } from '../relay/direct/direct.service';\nimport { GaslessService } from '../relay/gasless/gasless.service';\nimport { QueueMessage } from './interfaces/queue-message.interface';\n\n@Injectable()\nexport class QueueConsumer implements OnModuleInit, OnModuleDestroy {\n  private readonly logger = new Logger(QueueConsumer.name);\n  private isRunning = false;\n  private pollingTimeout: NodeJS.Timeout;\n\n  constructor(\n    private readonly sqsAdapter: SqsAdapter,\n    private readonly jobService: JobService,\n    private readonly directService: DirectService,\n    private readonly gaslessService: GaslessService,\n    private readonly configService: ConfigService,\n  ) {}\n\n  onModuleInit() {\n    if (!this.configService.get('queue.enabled')) {\n      this.logger.log('Queue disabled, skipping consumer start');\n      return;\n    }\n\n    this.startPolling();\n    this.logger.log('Queue consumer started');\n  }\n\n  onModuleDestroy() {\n    this.isRunning = false;\n    if (this.pollingTimeout) {\n      clearTimeout(this.pollingTimeout);\n    }\n    this.logger.log('Queue consumer stopped');\n  }\n\n  private async startPolling(): Promise<void> {\n    this.isRunning = true;\n\n    while (this.isRunning) {\n      try {\n        const messages = await this.sqsAdapter.receiveMessages();\n\n        if (messages.length > 0) {\n          this.logger.log(`Received ${messages.length} messages`);\n          await Promise.all(\n            messages.map((message) => this.processMessage(message)),\n          );\n        }\n      } catch (error) {\n        this.logger.error(`Polling error: ${error.message}`, error.stack);\n        // Continue polling even on error\n      }\n\n      // Short delay between polling cycles\n      await new Promise((resolve) => {\n        this.pollingTimeout = setTimeout(resolve, 1000);\n      });\n    }\n  }\n\n  private async processMessage(message: any): Promise<void> {\n    let queueMessage: QueueMessage;\n    \n    try {\n      queueMessage = JSON.parse(message.Body) as QueueMessage;\n    } catch (error) {\n      this.logger.error(`Failed to parse message: ${error.message}`);\n      await this.sqsAdapter.deleteMessage(message.ReceiptHandle);\n      return;\n    }\n\n    const { jobId, type, payload } = queueMessage;\n\n    try {\n      this.jobService.updateJobStatus(jobId, 'processing', { progress: 10 });\n\n      let result: { transactionId: string; hash?: string };\n\n      if (type === 'direct') {\n        this.jobService.updateJobStatus(jobId, 'processing', { progress: 30 });\n        result = await this.directService.sendTransaction(payload as any);\n      } else if (type === 'gasless') {\n        this.jobService.updateJobStatus(jobId, 'processing', { progress: 30 });\n        result = await this.gaslessService.executeMetaTransaction(payload as any);\n      } else {\n        throw new Error(`Unknown job type: ${type}`);\n      }\n\n      this.jobService.updateJobStatus(jobId, 'completed', {\n        txId: result.transactionId,\n        txHash: result.hash,\n        progress: 100,\n      });\n\n      await this.sqsAdapter.deleteMessage(message.ReceiptHandle);\n      this.logger.log(`Job completed: ${jobId}, txId: ${result.transactionId}`);\n    } catch (error) {\n      this.logger.error(`Job failed: ${jobId}, error: ${error.message}`, error.stack);\n      \n      this.jobService.updateJobStatus(jobId, 'failed', {\n        error: error.message,\n      });\n\n      // SQS will automatically retry based on DLQ policy (3 retries)\n      // After 3 failures, message moves to DLQ\n      throw error;\n    }\n  }\n}\n```\n\n### 10. JobController 구현\n\n```typescript\n// packages/relay-api/src/queue/job/job.controller.ts\nimport { Controller, Get, Param, HttpCode, HttpStatus } from '@nestjs/common';\nimport { ApiTags, ApiOperation, ApiResponse, ApiParam, ApiBearerAuth } from '@nestjs/swagger';\nimport { JobService } from './job.service';\nimport { JobStatusResponseDto } from '../dto/job-status-response.dto';\n\n@Controller('api/v1/relay')\n@ApiTags('Queue')\n@ApiBearerAuth()\nexport class JobController {\n  constructor(private readonly jobService: JobService) {}\n\n  @Get('job/:jobId')\n  @HttpCode(HttpStatus.OK)\n  @ApiOperation({ \n    summary: 'Get job status', \n    description: 'Query async transaction job status by Job ID' \n  })\n  @ApiParam({ \n    name: 'jobId', \n    description: 'Job ID (UUID v4)', \n    example: '550e8400-e29b-41d4-a716-446655440000' \n  })\n  @ApiResponse({ \n    status: 200, \n    description: 'Job status retrieved', \n    type: JobStatusResponseDto \n  })\n  @ApiResponse({ \n    status: 404, \n    description: 'Job not found' \n  })\n  async getJobStatus(@Param('jobId') jobId: string): Promise<JobStatusResponseDto> {\n    const status = this.jobService.getJobStatus(jobId);\n    return {\n      jobId: status.jobId,\n      status: status.status,\n      txId: status.txId,\n      txHash: status.txHash,\n      error: status.error,\n      progress: status.progress,\n      createdAt: status.createdAt,\n      updatedAt: status.updatedAt,\n      estimatedWait: status.estimatedWait,\n    };\n  }\n}\n```\n\n### 11. DirectController/GaslessController 수정 (Queue 모드 지원)\n\n```typescript\n// packages/relay-api/src/relay/direct/direct.controller.ts 수정\nimport { QueueService } from '../../queue/queue.service';\nimport { JobService } from '../../queue/job/job.service';\n\n@Post()\nasync sendTransaction(@Body() dto: DirectTxRequestDto) {\n  if (this.queueService.isQueueEnabled()) {\n    // Phase 2: Queue mode - return 202 Accepted with jobId\n    const { jobId, estimatedWait } = await this.queueService.enqueueJob({\n      type: 'direct',\n      payload: dto,\n      priority: dto.speed === 'fastest' ? 'high' : 'normal',\n    });\n    \n    // Create job tracking entry\n    this.jobService.createJob(jobId);\n    \n    return {\n      jobId,\n      status: 'queued',\n      estimatedWait,\n    };\n  }\n\n  // Phase 1: Immediate processing\n  return this.directService.sendTransaction(dto);\n}\n```\n\n### 12. QueueModule 정의\n\n```typescript\n// packages/relay-api/src/queue/queue.module.ts\nimport { Module } from '@nestjs/common';\nimport { QueueService } from './queue.service';\nimport { QueueConsumer } from './queue.consumer';\nimport { SqsAdapter } from './sqs/sqs.adapter';\nimport { JobService } from './job/job.service';\nimport { JobController } from './job/job.controller';\nimport { RelayModule } from '../relay/relay.module';\n\n@Module({\n  imports: [RelayModule],\n  controllers: [JobController],\n  providers: [\n    QueueService,\n    QueueConsumer,\n    SqsAdapter,\n    JobService,\n  ],\n  exports: [QueueService, JobService],\n})\nexport class QueueModule {}\n```\n\n### 13. 의존성 추가\n\n```json\n// packages/relay-api/package.json\n{\n  \"dependencies\": {\n    \"@aws-sdk/client-sqs\": \"^3.700.0\",\n    \"uuid\": \"^11.0.0\"\n  },\n  \"devDependencies\": {\n    \"@types/uuid\": \"^11.0.0\"\n  }\n}\n```\n\n### 14. 환경변수 예시\n\n```bash\n# .env.example\n\n# Queue 설정 (Phase 2)\nQUEUE_ENABLED=true\n\n# AWS 설정\nAWS_REGION=ap-northeast-2\nAWS_ACCESS_KEY_ID=test                    # LocalStack default\nAWS_SECRET_ACCESS_KEY=test                # LocalStack default\n\n# SQS Queue URLs\nSQS_QUEUE_URL=http://localstack:4566/000000000000/relay-tx-queue\nSQS_DLQ_URL=http://localstack:4566/000000000000/relay-tx-dlq\n\n# LocalStack Endpoint (local dev only)\nLOCALSTACK_ENDPOINT=http://localstack:4566\n\n# Consumer 설정\nSQS_VISIBILITY_TIMEOUT=30\nSQS_WAIT_TIME_SECONDS=20\nSQS_MAX_RETRIES=3\n\n# OZ Relayer URL (via Nginx LB)\nOZ_RELAYER_URL=http://oz-relayer-lb:80\nOZ_RELAYER_API_KEY=oz-relayer-shared-api-key-local-dev\n```",
        "testStrategy": "## 테스트 전략\n\n### 1. SQS Adapter 단위 테스트\n\n```typescript\n// packages/relay-api/src/queue/sqs/sqs.adapter.spec.ts\nimport { Test } from '@nestjs/testing';\nimport { ConfigService } from '@nestjs/config';\nimport { SqsAdapter } from './sqs.adapter';\nimport { SQSClient, SendMessageCommand } from '@aws-sdk/client-sqs';\n\njest.mock('@aws-sdk/client-sqs');\n\ndescribe('SqsAdapter', () => {\n  let adapter: SqsAdapter;\n  let mockSqsClient: jest.Mocked<SQSClient>;\n  let configService: ConfigService;\n\n  beforeEach(async () => {\n    const module = await Test.createTestingModule({\n      providers: [\n        SqsAdapter,\n        {\n          provide: ConfigService,\n          useValue: {\n            get: jest.fn((key: string) => {\n              const config = {\n                'queue.sqs.region': 'ap-northeast-2',\n                'queue.sqs.queueUrl': 'http://localstack:4566/000000000000/relay-tx-queue',\n                'queue.sqs.dlqUrl': 'http://localstack:4566/000000000000/relay-tx-dlq',\n                'queue.sqs.endpoint': 'http://localstack:4566',\n                'queue.sqs.accessKeyId': 'test',\n                'queue.sqs.secretAccessKey': 'test',\n                'queue.sqs.visibilityTimeout': 30,\n                'queue.sqs.waitTimeSeconds': 20,\n              };\n              return config[key];\n            }),\n          },\n        },\n      ],\n    }).compile();\n\n    adapter = module.get<SqsAdapter>(SqsAdapter);\n    configService = module.get<ConfigService>(ConfigService);\n  });\n\n  describe('sendMessage', () => {\n    it('should send message to SQS queue', async () => {\n      const message = {\n        jobId: 'test-job-id',\n        type: 'direct' as const,\n        payload: { to: '0x...', data: '0x...' },\n        createdAt: new Date().toISOString(),\n      };\n\n      const mockSend = jest.fn().mockResolvedValue({ MessageId: 'msg-123' });\n      (SQSClient as jest.Mock).mockImplementation(() => ({ send: mockSend }));\n\n      const result = await adapter.sendMessage(message);\n\n      expect(result).toBe('msg-123');\n      expect(mockSend).toHaveBeenCalledWith(expect.any(SendMessageCommand));\n    });\n\n    it('should include message attributes', async () => {\n      const message = {\n        jobId: 'test-job-id',\n        type: 'gasless' as const,\n        payload: {},\n        priority: 'high' as const,\n        createdAt: new Date().toISOString(),\n      };\n\n      await adapter.sendMessage(message);\n\n      // Verify MessageAttributes include jobId, type, priority\n    });\n  });\n\n  describe('getQueueStats', () => {\n    it('should return queue waiting count and DLQ count', async () => {\n      const mockSend = jest.fn()\n        .mockResolvedValueOnce({ Attributes: { ApproximateNumberOfMessages: '5' } })\n        .mockResolvedValueOnce({ Attributes: { ApproximateNumberOfMessages: '2' } });\n\n      (SQSClient as jest.Mock).mockImplementation(() => ({ send: mockSend }));\n\n      const stats = await adapter.getQueueStats();\n\n      expect(stats).toEqual({ waiting: 5, dlq: 2 });\n    });\n  });\n});\n```\n\n### 2. QueueService 단위 테스트\n\n```typescript\n// packages/relay-api/src/queue/queue.service.spec.ts\ndescribe('QueueService', () => {\n  let service: QueueService;\n  let mockSqsAdapter: jest.Mocked<SqsAdapter>;\n  let mockConfigService: jest.Mocked<ConfigService>;\n\n  beforeEach(async () => {\n    const module = await Test.createTestingModule({\n      providers: [\n        QueueService,\n        {\n          provide: SqsAdapter,\n          useValue: {\n            sendMessage: jest.fn(),\n            getQueueStats: jest.fn(),\n          },\n        },\n        {\n          provide: ConfigService,\n          useValue: {\n            get: jest.fn().mockReturnValue(true),\n          },\n        },\n      ],\n    }).compile();\n\n    service = module.get<QueueService>(QueueService);\n    mockSqsAdapter = module.get(SqsAdapter);\n    mockConfigService = module.get(ConfigService);\n  });\n\n  describe('enqueueJob', () => {\n    it('should return jobId and estimated wait time', async () => {\n      mockSqsAdapter.sendMessage.mockResolvedValue('msg-123');\n      mockSqsAdapter.getQueueStats.mockResolvedValue({ waiting: 5, dlq: 0 });\n\n      const result = await service.enqueueJob({\n        type: 'direct',\n        payload: { to: '0x...', data: '0x...' },\n      });\n\n      expect(result.jobId).toBeDefined();\n      expect(result.estimatedWait).toMatch(/^\\d+(s|m|h)$/);\n    });\n\n    it('should calculate estimated wait time correctly', async () => {\n      mockSqsAdapter.sendMessage.mockResolvedValue('msg-123');\n      \n      // 5 jobs * 5s = 25s\n      mockSqsAdapter.getQueueStats.mockResolvedValue({ waiting: 5, dlq: 0 });\n      const result1 = await service.enqueueJob({ type: 'direct', payload: {} });\n      expect(result1.estimatedWait).toBe('25s');\n\n      // 15 jobs * 5s = 75s = 2m\n      mockSqsAdapter.getQueueStats.mockResolvedValue({ waiting: 15, dlq: 0 });\n      const result2 = await service.enqueueJob({ type: 'direct', payload: {} });\n      expect(result2.estimatedWait).toBe('2m');\n    });\n  });\n});\n```\n\n### 3. JobService 단위 테스트\n\n```typescript\n// packages/relay-api/src/queue/job/job.service.spec.ts\ndescribe('JobService', () => {\n  let service: JobService;\n\n  beforeEach(() => {\n    service = new JobService();\n  });\n\n  describe('createJob', () => {\n    it('should create job with queued status', () => {\n      service.createJob('job-123');\n      const job = service.getJobStatus('job-123');\n      \n      expect(job.jobId).toBe('job-123');\n      expect(job.status).toBe('queued');\n    });\n  });\n\n  describe('updateJobStatus', () => {\n    it('should update job status and timestamp', () => {\n      service.createJob('job-123');\n      \n      service.updateJobStatus('job-123', 'processing', { progress: 50 });\n      const job = service.getJobStatus('job-123');\n      \n      expect(job.status).toBe('processing');\n      expect(job.progress).toBe(50);\n    });\n\n    it('should handle non-existent job gracefully', () => {\n      expect(() => {\n        service.updateJobStatus('non-existent', 'processing');\n      }).not.toThrow();\n    });\n  });\n\n  describe('getJobStatus', () => {\n    it('should throw NotFoundException for non-existent job', () => {\n      expect(() => service.getJobStatus('non-existent')).toThrow(NotFoundException);\n    });\n  });\n});\n```\n\n### 4. QueueConsumer 통합 테스트\n\n```typescript\n// packages/relay-api/src/queue/queue.consumer.spec.ts\ndescribe('QueueConsumer', () => {\n  let consumer: QueueConsumer;\n  let mockSqsAdapter: jest.Mocked<SqsAdapter>;\n  let mockJobService: jest.Mocked<JobService>;\n  let mockDirectService: jest.Mocked<DirectService>;\n\n  beforeEach(async () => {\n    const module = await Test.createTestingModule({\n      providers: [\n        QueueConsumer,\n        {\n          provide: SqsAdapter,\n          useValue: {\n            receiveMessages: jest.fn(),\n            deleteMessage: jest.fn(),\n          },\n        },\n        {\n          provide: JobService,\n          useValue: {\n            updateJobStatus: jest.fn(),\n          },\n        },\n        {\n          provide: DirectService,\n          useValue: {\n            sendTransaction: jest.fn(),\n          },\n        },\n        {\n          provide: GaslessService,\n          useValue: {\n            executeMetaTransaction: jest.fn(),\n          },\n        },\n        {\n          provide: ConfigService,\n          useValue: {\n            get: jest.fn().mockReturnValue(true),\n          },\n        },\n      ],\n    }).compile();\n\n    consumer = module.get<QueueConsumer>(QueueConsumer);\n    mockSqsAdapter = module.get(SqsAdapter);\n    mockJobService = module.get(JobService);\n    mockDirectService = module.get(DirectService);\n  });\n\n  describe('processMessage', () => {\n    it('should process direct transaction job successfully', async () => {\n      const message = {\n        Body: JSON.stringify({\n          jobId: 'job-123',\n          type: 'direct',\n          payload: { to: '0x...', data: '0x...' },\n          createdAt: new Date().toISOString(),\n        }),\n        ReceiptHandle: 'receipt-123',\n      };\n\n      mockDirectService.sendTransaction.mockResolvedValue({\n        transactionId: 'tx-123',\n        hash: '0xabc...',\n        status: 'submitted',\n        createdAt: new Date().toISOString(),\n      });\n\n      await consumer['processMessage'](message);\n\n      expect(mockJobService.updateJobStatus).toHaveBeenCalledWith(\n        'job-123',\n        'completed',\n        expect.objectContaining({ txId: 'tx-123', txHash: '0xabc...' }),\n      );\n      expect(mockSqsAdapter.deleteMessage).toHaveBeenCalledWith('receipt-123');\n    });\n\n    it('should handle job failure and not delete message (for retry)', async () => {\n      const message = {\n        Body: JSON.stringify({\n          jobId: 'job-123',\n          type: 'direct',\n          payload: {},\n          createdAt: new Date().toISOString(),\n        }),\n        ReceiptHandle: 'receipt-123',\n      };\n\n      mockDirectService.sendTransaction.mockRejectedValue(new Error('RPC error'));\n\n      await expect(consumer['processMessage'](message)).rejects.toThrow('RPC error');\n\n      expect(mockJobService.updateJobStatus).toHaveBeenCalledWith(\n        'job-123',\n        'failed',\n        expect.objectContaining({ error: 'RPC error' }),\n      );\n      expect(mockSqsAdapter.deleteMessage).not.toHaveBeenCalled();\n    });\n  });\n});\n```\n\n### 5. JobController E2E 테스트\n\n```typescript\n// packages/relay-api/test/queue.e2e-spec.ts\ndescribe('Queue E2E Tests', () => {\n  let app: INestApplication;\n  let jobService: JobService;\n\n  beforeAll(async () => {\n    const moduleFixture = await Test.createTestingModule({\n      imports: [AppModule],\n    }).compile();\n\n    app = moduleFixture.createNestApplication();\n    jobService = moduleFixture.get<JobService>(JobService);\n    await app.init();\n  });\n\n  describe('GET /api/v1/relay/job/:jobId', () => {\n    it('should return 200 with job status for valid jobId', async () => {\n      // Create a test job\n      jobService.createJob('test-job-123');\n      jobService.updateJobStatus('test-job-123', 'processing', { progress: 50 });\n\n      const response = await request(app.getHttpServer())\n        .get('/api/v1/relay/job/test-job-123')\n        .set('x-api-key', 'local-dev-api-key')\n        .expect(200);\n\n      expect(response.body).toMatchObject({\n        jobId: 'test-job-123',\n        status: 'processing',\n        progress: 50,\n      });\n    });\n\n    it('should return 404 for non-existent job', async () => {\n      await request(app.getHttpServer())\n        .get('/api/v1/relay/job/non-existent-uuid')\n        .set('x-api-key', 'local-dev-api-key')\n        .expect(404);\n    });\n  });\n\n  describe('Queue Integration Flow', () => {\n    it('should enqueue job via Direct TX API and query status', async () => {\n      // Enable queue mode\n      process.env.QUEUE_ENABLED = 'true';\n\n      // Enqueue job\n      const enqueueResponse = await request(app.getHttpServer())\n        .post('/api/v1/relay/direct')\n        .set('x-api-key', 'local-dev-api-key')\n        .send({\n          to: '0x5FbDB2315678afecb367f032d93F642f64180aa3',\n          data: '0x',\n        })\n        .expect(200);\n\n      const { jobId } = enqueueResponse.body;\n      expect(jobId).toBeDefined();\n      expect(enqueueResponse.body.status).toBe('queued');\n\n      // Query job status\n      const statusResponse = await request(app.getHttpServer())\n        .get(`/api/v1/relay/job/${jobId}`)\n        .set('x-api-key', 'local-dev-api-key')\n        .expect(200);\n\n      expect(statusResponse.body.jobId).toBe(jobId);\n      expect(['queued', 'processing', 'completed']).toContain(statusResponse.body.status);\n    });\n  });\n});\n```\n\n### 6. LocalStack E2E 테스트\n\n```bash\n# 1. LocalStack 및 Docker Compose 실행\ncd docker && docker compose up -d localstack relay-api\n\n# 2. LocalStack 상태 확인\ndocker exec msq-localstack awslocal sqs list-queues\n\n# Expected Output:\n# {\n#   \"QueueUrls\": [\n#     \"http://localstack:4566/000000000000/relay-tx-queue\",\n#     \"http://localstack:4566/000000000000/relay-tx-dlq\"\n#   ]\n# }\n\n# 3. Queue 속성 확인 (DLQ redrive policy)\ndocker exec msq-localstack awslocal sqs get-queue-attributes \\\n  --queue-url http://localstack:4566/000000000000/relay-tx-queue \\\n  --attribute-names All\n\n# 4. Direct TX Enqueue 테스트 (QUEUE_ENABLED=true)\ncurl -X POST http://localhost:8080/api/v1/relay/direct \\\n  -H \"Content-Type: application/json\" \\\n  -H \"x-api-key: local-dev-api-key\" \\\n  -d '{\n    \"to\": \"0x5FbDB2315678afecb367f032d93F642f64180aa3\",\n    \"data\": \"0x\"\n  }' | jq\n\n# Expected Response (202 Accepted):\n# {\n#   \"jobId\": \"550e8400-e29b-41d4-a716-446655440000\",\n#   \"status\": \"queued\",\n#   \"estimatedWait\": \"5s\"\n# }\n\n# 5. Job 상태 조회\nJOB_ID=\"550e8400-e29b-41d4-a716-446655440000\"\ncurl http://localhost:8080/api/v1/relay/job/$JOB_ID \\\n  -H \"x-api-key: local-dev-api-key\" | jq\n\n# Expected Response:\n# {\n#   \"jobId\": \"550e8400-e29b-41d4-a716-446655440000\",\n#   \"status\": \"completed\",\n#   \"txId\": \"uuid-from-oz-relayer\",\n#   \"txHash\": \"0x...\",\n#   \"progress\": 100\n# }\n\n# 6. SQS 메시지 확인 (디버깅용)\ndocker exec msq-localstack awslocal sqs receive-message \\\n  --queue-url http://localstack:4566/000000000000/relay-tx-queue \\\n  --max-number-of-messages 10\n\n# 7. DLQ 메시지 확인 (실패한 작업)\ndocker exec msq-localstack awslocal sqs receive-message \\\n  --queue-url http://localstack:4566/000000000000/relay-tx-dlq\n```\n\n### 7. 부하 테스트\n\n```yaml\n# test/load/queue-artillery.yml\nconfig:\n  target: \"http://localhost:8080\"\n  phases:\n    - duration: 60\n      arrivalRate: 50  # 초당 50개 요청\n  environments:\n    local:\n      target: \"http://localhost:8080\"\nscenarios:\n  - name: \"Queue stress test\"\n    flow:\n      - post:\n          url: \"/api/v1/relay/direct\"\n          headers:\n            x-api-key: \"local-dev-api-key\"\n            Content-Type: \"application/json\"\n          json:\n            to: \"0x5FbDB2315678afecb367f032d93F642f64180aa3\"\n            data: \"0x\"\n          capture:\n            - json: \"$.jobId\"\n              as: \"jobId\"\n      - get:\n          url: \"/api/v1/relay/job/{{ jobId }}\"\n          headers:\n            x-api-key: \"local-dev-api-key\"\n```\n\n**실행**:\n```bash\nnpx artillery run test/load/queue-artillery.yml\n```\n\n### 8. 성능 기준\n\n| Metric | Target |\n|--------|--------|\n| Enqueue 응답 시간 | < 100ms (P95) |\n| Job 상태 조회 응답 시간 | < 20ms (P95) |\n| SQS 메시지 처리 지연 | < 5s (P95) |\n| Consumer 처리량 | >= 100 jobs/sec |\n| DLQ 이동률 | < 1% |\n\n### 9. 모니터링 및 디버깅\n\n```bash\n# LocalStack 로그\ndocker logs -f msq-localstack\n\n# Relay API 로그\ndocker logs -f relay-api\n\n# SQS 큐 메트릭\ndocker exec msq-localstack awslocal sqs get-queue-attributes \\\n  --queue-url http://localstack:4566/000000000000/relay-tx-queue \\\n  --attribute-names ApproximateNumberOfMessages,ApproximateNumberOfMessagesNotVisible\n```\n\n### 10. 환경별 검증\n\n```bash\n# Local Dev (LocalStack)\nQUEUE_ENABLED=true \\\nLOCALSTACK_ENDPOINT=http://localstack:4566 \\\npnpm --filter @msq-relayer/relay-api test\n\n# Staging/Production (AWS SQS)\nQUEUE_ENABLED=true \\\nAWS_REGION=ap-northeast-2 \\\nSQS_QUEUE_URL=https://sqs.ap-northeast-2.amazonaws.com/123456789012/relay-tx-queue \\\npnpm --filter @msq-relayer/relay-api test\n```",
        "subtasks": [],
        "updatedAt": "2026-01-07T06:34:37.567Z"
      },
      {
        "id": "16",
        "title": "Phase 2 Monitor Service: OZ Monitor 설정 및 Relayer 잔액 모니터링 시스템 구축",
        "description": "OZ Monitor v1.1.0 컨테이너를 Docker Compose에 추가하고, Relayer 잔액 임계값 모니터링 및 Slack/Discord 알림 통합을 구현합니다. 블록체인 이벤트 모니터링 및 이상 감지 시스템을 구축합니다.",
        "details": "## 구현 세부사항\n\n### 1. 디렉토리 구조\n\n```\ndocker/\n├── config/\n│   └── oz-monitor/\n│       ├── networks/\n│       │   ├── polygon-mainnet.json    # Polygon Mainnet RPC 설정\n│       │   ├── polygon-amoy.json       # Polygon Amoy Testnet RPC 설정\n│       │   └── localhost.json          # Hardhat Node 로컬 설정\n│       ├── monitors/\n│       │   ├── relayer-balance.json    # Relayer 잔액 모니터\n│       │   ├── large-transfer.json     # 대량 전송 이벤트 모니터\n│       │   └── forwarder-events.json   # ERC2771Forwarder 이벤트 모니터\n│       ├── triggers/\n│       │   ├── slack.json              # Slack Webhook 알림\n│       │   ├── discord.json            # Discord Webhook 알림\n│       │   └── webhook.json            # 커스텀 Webhook (Relay API)\n│       └── filters/\n│           └── balance-threshold.sh    # 잔액 임계값 필터 스크립트\n```\n\n### 2. Docker Compose 서비스 추가 (Phase 2 Profile)\n\n**파일**: `docker/docker-compose.yaml`\n\n```yaml\nservices:\n  # ... 기존 서비스 ...\n\n  # === Phase 2: OZ Monitor Service ===\n  oz-monitor:\n    image: ghcr.io/openzeppelin/openzeppelin-monitor:v1.1.0\n    container_name: oz-monitor\n    profiles: [\"phase2\", \"monitoring\"]\n    depends_on:\n      hardhat-node:\n        condition: service_healthy\n      redis:\n        condition: service_healthy\n    environment:\n      RUST_LOG: info\n      # Slack/Discord Webhook URLs (환경변수로 주입)\n      SLACK_WEBHOOK_URL: ${SLACK_WEBHOOK_URL:-}\n      DISCORD_WEBHOOK_URL: ${DISCORD_WEBHOOK_URL:-}\n      # Relay API Webhook (내부 알림용)\n      RELAY_API_WEBHOOK_URL: http://relay-api:3000/api/v1/webhook/monitor\n      # RPC URLs\n      POLYGON_RPC_URL: ${POLYGON_RPC_URL:-http://hardhat-node:8545}\n      AMOY_RPC_URL: ${AMOY_RPC_URL:-http://hardhat-node:8545}\n    volumes:\n      - ./config/oz-monitor:/app/config:ro\n    networks:\n      - msq-relayer-network\n    restart: unless-stopped\n    healthcheck:\n      test: [\"CMD-SHELL\", \"curl -f http://localhost:8080/health || exit 1\"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n      start_period: 60s\n```\n\n### 3. 네트워크 설정 (networks/)\n\n**파일**: `docker/config/oz-monitor/networks/polygon-mainnet.json`\n\n```json\n{\n  \"polygon_mainnet\": {\n    \"name\": \"Polygon Mainnet\",\n    \"chain_id\": 137,\n    \"network_type\": \"evm\",\n    \"rpc_urls\": [\n      {\n        \"type_\": \"rpc\",\n        \"url\": {\n          \"type\": \"environment\",\n          \"value\": \"POLYGON_RPC_URL\"\n        },\n        \"weight\": 100\n      }\n    ],\n    \"block_time\": 2,\n    \"confirmation_blocks\": 15,\n    \"cron_schedule\": \"*/10 * * * * *\"\n  }\n}\n```\n\n**파일**: `docker/config/oz-monitor/networks/localhost.json`\n\n```json\n{\n  \"localhost\": {\n    \"name\": \"Hardhat Node\",\n    \"chain_id\": 31337,\n    \"network_type\": \"evm\",\n    \"rpc_urls\": [\n      {\n        \"type_\": \"rpc\",\n        \"url\": {\n          \"type\": \"plain\",\n          \"value\": \"http://hardhat-node:8545\"\n        },\n        \"weight\": 100\n      }\n    ],\n    \"block_time\": 1,\n    \"confirmation_blocks\": 1,\n    \"cron_schedule\": \"*/5 * * * * *\"\n  }\n}\n```\n\n### 4. Relayer 잔액 모니터 설정 (monitors/)\n\n**파일**: `docker/config/oz-monitor/monitors/relayer-balance.json`\n\n```json\n{\n  \"relayer_balance_monitor\": {\n    \"name\": \"Relayer Balance Monitor\",\n    \"paused\": false,\n    \"networks\": [\"polygon_mainnet\", \"localhost\"],\n    \"addresses\": [\n      {\n        \"address\": \"${RELAYER_1_ADDRESS}\",\n        \"nickname\": \"oz-relayer-1\"\n      },\n      {\n        \"address\": \"${RELAYER_2_ADDRESS}\",\n        \"nickname\": \"oz-relayer-2\"\n      },\n      {\n        \"address\": \"${RELAYER_3_ADDRESS}\",\n        \"nickname\": \"oz-relayer-3\"\n      }\n    ],\n    \"match_conditions\": {\n      \"transactions\": [\n        {\n          \"status\": \"any\",\n          \"expression\": null\n        }\n      ]\n    },\n    \"trigger_conditions\": [\n      {\n        \"script_path\": \"./config/filters/balance-threshold.sh\",\n        \"language\": \"bash\",\n        \"arguments\": [\"--threshold\", \"100000000000000000\"],\n        \"timeout_ms\": 5000\n      }\n    ],\n    \"triggers\": [\"slack_low_balance\", \"discord_low_balance\", \"relay_api_webhook\"]\n  }\n}\n```\n\n### 5. 알림 트리거 설정 (triggers/)\n\n**파일**: `docker/config/oz-monitor/triggers/slack.json`\n\n```json\n{\n  \"slack_low_balance\": {\n    \"name\": \"Slack Low Balance Alert\",\n    \"trigger_type\": \"slack\",\n    \"config\": {\n      \"slack_url\": {\n        \"type\": \"environment\",\n        \"value\": \"SLACK_WEBHOOK_URL\"\n      },\n      \"message\": {\n        \"title\": \"🚨 Relayer Balance Low Alert\",\n        \"body\": \"Relayer ${address.nickname} balance is below threshold!\\n\\nAddress: ${address.address}\\nCurrent Balance: ${balance} wei\\nNetwork: ${network.name}\\nTimestamp: ${timestamp}\\n\\n⚠️ Please top up the relayer account immediately.\"\n      }\n    }\n  },\n  \"slack_transaction_failed\": {\n    \"name\": \"Slack Transaction Failed Alert\",\n    \"trigger_type\": \"slack\",\n    \"config\": {\n      \"slack_url\": {\n        \"type\": \"environment\",\n        \"value\": \"SLACK_WEBHOOK_URL\"\n      },\n      \"message\": {\n        \"title\": \"❌ Relayer Transaction Failed\",\n        \"body\": \"Transaction failed!\\n\\nTx Hash: ${transaction.hash}\\nFrom: ${transaction.from}\\nTo: ${transaction.to}\\nError: ${transaction.error}\\nNetwork: ${network.name}\"\n      }\n    }\n  }\n}\n```\n\n**파일**: `docker/config/oz-monitor/triggers/discord.json`\n\n```json\n{\n  \"discord_low_balance\": {\n    \"name\": \"Discord Low Balance Alert\",\n    \"trigger_type\": \"discord\",\n    \"config\": {\n      \"discord_url\": {\n        \"type\": \"environment\",\n        \"value\": \"DISCORD_WEBHOOK_URL\"\n      },\n      \"message\": {\n        \"title\": \"🚨 Relayer Balance Low Alert\",\n        \"body\": \"Relayer **${address.nickname}** balance is below threshold!\\n\\n**Address:** `${address.address}`\\n**Current Balance:** ${balance} wei\\n**Network:** ${network.name}\\n**Timestamp:** ${timestamp}\"\n      }\n    }\n  }\n}\n```\n\n**파일**: `docker/config/oz-monitor/triggers/webhook.json`\n\n```json\n{\n  \"relay_api_webhook\": {\n    \"name\": \"Relay API Internal Webhook\",\n    \"trigger_type\": \"webhook\",\n    \"config\": {\n      \"url\": {\n        \"type\": \"environment\",\n        \"value\": \"RELAY_API_WEBHOOK_URL\"\n      },\n      \"method\": \"POST\",\n      \"headers\": {\n        \"Content-Type\": \"application/json\",\n        \"X-Monitor-Event\": \"balance-alert\"\n      },\n      \"body\": {\n        \"type\": \"balance_alert\",\n        \"relayer\": \"${address.nickname}\",\n        \"address\": \"${address.address}\",\n        \"balance\": \"${balance}\",\n        \"threshold\": \"${threshold}\",\n        \"network\": \"${network.name}\",\n        \"timestamp\": \"${timestamp}\"\n      }\n    }\n  }\n}\n```\n\n### 6. 잔액 임계값 필터 스크립트\n\n**파일**: `docker/config/oz-monitor/filters/balance-threshold.sh`\n\n```bash\n#!/bin/bash\n# Balance Threshold Filter Script\n# Checks if relayer balance is below the specified threshold\n\nTHRESHOLD=\"${1:-100000000000000000}\"  # Default: 0.1 ETH in wei\n\n# Read balance from stdin (passed by OZ Monitor)\nBALANCE=$(cat)\n\n# Compare balance with threshold\nif [ \"$BALANCE\" -lt \"$THRESHOLD\" ]; then\n    echo \"true\"\n    exit 0\nelse\n    echo \"false\"\n    exit 0\nfi\n```\n\n### 7. NestJS Monitor Webhook Handler (Relay API 확장)\n\n**파일**: `packages/relay-api/src/monitor/monitor.module.ts`\n\n```typescript\nimport { Module } from '@nestjs/common';\nimport { MonitorWebhookController } from './monitor-webhook.controller';\nimport { MonitorService } from './monitor.service';\n\n@Module({\n  controllers: [MonitorWebhookController],\n  providers: [MonitorService],\n  exports: [MonitorService],\n})\nexport class MonitorModule {}\n```\n\n**파일**: `packages/relay-api/src/monitor/monitor-webhook.controller.ts`\n\n```typescript\nimport { Controller, Post, Body, Headers, HttpCode, HttpStatus, Logger } from '@nestjs/common';\nimport { ApiTags, ApiOperation, ApiResponse } from '@nestjs/swagger';\nimport { Public } from '../auth/decorators/public.decorator';\nimport { MonitorService } from './monitor.service';\nimport { MonitorAlertDto } from './dto/monitor-alert.dto';\n\n@ApiTags('Monitor Webhook')\n@Controller('api/v1/webhook/monitor')\nexport class MonitorWebhookController {\n  private readonly logger = new Logger(MonitorWebhookController.name);\n\n  constructor(private readonly monitorService: MonitorService) {}\n\n  @Post()\n  @Public()\n  @HttpCode(HttpStatus.OK)\n  @ApiOperation({ summary: 'Receive OZ Monitor webhook events' })\n  @ApiResponse({ status: 200, description: 'Webhook processed successfully' })\n  async handleMonitorWebhook(\n    @Body() alert: MonitorAlertDto,\n    @Headers('X-Monitor-Event') eventType: string,\n  ): Promise<{ received: boolean }> {\n    this.logger.log(`Received monitor event: ${eventType}`);\n    await this.monitorService.processAlert(alert, eventType);\n    return { received: true };\n  }\n}\n```\n\n**파일**: `packages/relay-api/src/monitor/monitor.service.ts`\n\n```typescript\nimport { Injectable, Logger } from '@nestjs/common';\nimport { MonitorAlertDto } from './dto/monitor-alert.dto';\n\n@Injectable()\nexport class MonitorService {\n  private readonly logger = new Logger(MonitorService.name);\n\n  async processAlert(alert: MonitorAlertDto, eventType: string): Promise<void> {\n    this.logger.warn(`Monitor Alert [${eventType}]: Relayer ${alert.relayer} - Balance: ${alert.balance} wei`);\n\n    switch (eventType) {\n      case 'balance-alert':\n        await this.handleBalanceAlert(alert);\n        break;\n      case 'transaction-failed':\n        await this.handleTransactionFailedAlert(alert);\n        break;\n      default:\n        this.logger.log(`Unknown event type: ${eventType}`);\n    }\n  }\n\n  private async handleBalanceAlert(alert: MonitorAlertDto): Promise<void> {\n    // Phase 2+: DB에 알림 이력 저장\n    // Phase 2+: 자동 충전 로직 트리거 (optional)\n    this.logger.error(`LOW BALANCE ALERT: ${alert.relayer} on ${alert.network} - ${alert.balance} wei`);\n  }\n\n  private async handleTransactionFailedAlert(alert: MonitorAlertDto): Promise<void> {\n    this.logger.error(`TRANSACTION FAILED: ${alert.relayer} on ${alert.network}`);\n  }\n}\n```\n\n**파일**: `packages/relay-api/src/monitor/dto/monitor-alert.dto.ts`\n\n```typescript\nimport { ApiProperty } from '@nestjs/swagger';\n\nexport class MonitorAlertDto {\n  @ApiProperty({ description: 'Alert type' })\n  type: string;\n\n  @ApiProperty({ description: 'Relayer nickname' })\n  relayer: string;\n\n  @ApiProperty({ description: 'Relayer address' })\n  address: string;\n\n  @ApiProperty({ description: 'Current balance in wei' })\n  balance: string;\n\n  @ApiProperty({ description: 'Threshold in wei' })\n  threshold: string;\n\n  @ApiProperty({ description: 'Network name' })\n  network: string;\n\n  @ApiProperty({ description: 'Event timestamp' })\n  timestamp: string;\n}\n```\n\n### 8. 환경변수 설정\n\n```bash\n# .env (docker/ 디렉토리)\n# Phase 2 Monitor 환경변수\nSLACK_WEBHOOK_URL=https://hooks.slack.com/services/XXXXX/YYYYY/ZZZZZ\nDISCORD_WEBHOOK_URL=https://discord.com/api/webhooks/123456/abcdef\n\n# Relayer 주소 (Hardhat Account #10, #11, #12)\nRELAYER_1_ADDRESS=0x...\nRELAYER_2_ADDRESS=0x...\nRELAYER_3_ADDRESS=0x...\n\n# Balance Alert 임계값 (0.1 ETH in wei)\nBALANCE_THRESHOLD=100000000000000000\n```\n\n### 9. Health Indicator 확장 (Phase 2)\n\n**파일**: `packages/relay-api/src/health/indicators/oz-monitor.health.ts`\n\n```typescript\nimport { Injectable } from '@nestjs/common';\nimport { HealthIndicator, HealthIndicatorResult, HealthCheckError } from '@nestjs/terminus';\nimport { HttpService } from '@nestjs/axios';\nimport { ConfigService } from '@nestjs/config';\nimport { firstValueFrom, timeout, catchError, of } from 'rxjs';\n\n@Injectable()\nexport class OzMonitorHealthIndicator extends HealthIndicator {\n  private readonly monitorUrl: string;\n\n  constructor(\n    private readonly httpService: HttpService,\n    private readonly configService: ConfigService,\n  ) {\n    super();\n    this.monitorUrl = this.configService.get<string>(\n      'OZ_MONITOR_URL',\n      'http://oz-monitor:8080'\n    );\n  }\n\n  async isHealthy(key: string): Promise<HealthIndicatorResult> {\n    try {\n      const response = await firstValueFrom(\n        this.httpService.get(`${this.monitorUrl}/health`).pipe(\n          timeout(5000),\n          catchError(() => of({ status: 500 }))\n        )\n      );\n\n      const isHealthy = response.status === 200;\n      return this.getStatus(key, isHealthy, {\n        url: this.monitorUrl,\n        status: isHealthy ? 'healthy' : 'unhealthy',\n      });\n    } catch (error) {\n      throw new HealthCheckError(\n        'OZ Monitor check failed',\n        this.getStatus(key, false, { error: error.message })\n      );\n    }\n  }\n}\n```\n\n### 10. 주요 모니터링 시나리오\n\n1. **Relayer 잔액 모니터링**: 각 Relayer 주소의 ETH 잔액이 임계값(0.1 ETH) 이하로 떨어지면 Slack/Discord 알림\n2. **대량 전송 감지**: ERC2771Forwarder를 통한 대량 토큰 전송 시 알림\n3. **트랜잭션 실패 감지**: Relayer 트랜잭션 실패 시 즉시 알림\n4. **네트워크 이상 감지**: RPC 연결 실패 또는 블록 생성 지연 시 알림",
        "testStrategy": "## 테스트 전략\n\n### 1. OZ Monitor 컨테이너 시작 테스트\n\n```bash\n# Phase 2 프로필로 Docker Compose 시작\ncd docker && docker compose --profile=phase2 up -d\n\n# OZ Monitor 컨테이너 상태 확인\ndocker ps | grep oz-monitor\n# 예상: oz-monitor 컨테이너 running 상태\n\n# OZ Monitor 로그 확인\ndocker logs oz-monitor\n# 예상: 설정 파일 로드 및 모니터링 시작 로그\n\n# Health check 확인\ncurl http://localhost:8090/health\n# 예상: 200 OK\n```\n\n### 2. Slack 알림 테스트\n\n```bash\n# 테스트용 Slack Webhook 설정 (Slack App 생성 필요)\nexport SLACK_WEBHOOK_URL=https://hooks.slack.com/services/TEST/WEBHOOK/URL\n\n# Docker Compose 재시작\ndocker compose --profile=phase2 down && docker compose --profile=phase2 up -d\n\n# Relayer 잔액을 임계값 이하로 설정 (Hardhat Node에서)\n# Hardhat 콘솔에서 ETH 전송으로 잔액 감소 시뮬레이션\nnpx hardhat console --network localhost\n> await ethers.provider.send(\"hardhat_setBalance\", [\"RELAYER_ADDRESS\", \"0x1\"])\n\n# Slack 채널에서 알림 수신 확인\n# 예상: \"🚨 Relayer Balance Low Alert\" 메시지\n```\n\n### 3. Discord 알림 테스트\n\n```bash\n# Discord Webhook 설정\nexport DISCORD_WEBHOOK_URL=https://discord.com/api/webhooks/XXX/YYY\n\n# 잔액 임계값 알림 트리거 (위와 동일)\n# Discord 채널에서 알림 수신 확인\n```\n\n### 4. Relay API Webhook 핸들러 테스트\n\n```bash\n# 수동 Webhook 호출 테스트\ncurl -X POST http://localhost:3000/api/v1/webhook/monitor \\\n  -H \"Content-Type: application/json\" \\\n  -H \"X-Monitor-Event: balance-alert\" \\\n  -d '{\n    \"type\": \"balance_alert\",\n    \"relayer\": \"oz-relayer-1\",\n    \"address\": \"0x123...\",\n    \"balance\": \"50000000000000000\",\n    \"threshold\": \"100000000000000000\",\n    \"network\": \"polygon_mainnet\",\n    \"timestamp\": \"2025-12-26T10:00:00Z\"\n  }'\n# 예상: {\"received\": true}\n\n# Relay API 로그에서 알림 처리 확인\ndocker logs relay-api | grep \"Monitor Alert\"\n# 예상: \"LOW BALANCE ALERT: oz-relayer-1 on polygon_mainnet\" 로그\n```\n\n### 5. 단위 테스트 (MonitorService)\n\n**파일**: `packages/relay-api/src/monitor/monitor.service.spec.ts`\n\n```typescript\ndescribe('MonitorService', () => {\n  let service: MonitorService;\n\n  beforeEach(async () => {\n    const module = await Test.createTestingModule({\n      providers: [MonitorService],\n    }).compile();\n\n    service = module.get<MonitorService>(MonitorService);\n  });\n\n  it('should process balance-alert event', async () => {\n    const alert = {\n      type: 'balance_alert',\n      relayer: 'oz-relayer-1',\n      address: '0x123',\n      balance: '50000000000000000',\n      threshold: '100000000000000000',\n      network: 'polygon_mainnet',\n      timestamp: new Date().toISOString(),\n    };\n\n    await expect(service.processAlert(alert, 'balance-alert')).resolves.not.toThrow();\n  });\n\n  it('should handle unknown event type gracefully', async () => {\n    const alert = { type: 'unknown', relayer: 'test' } as any;\n    await expect(service.processAlert(alert, 'unknown')).resolves.not.toThrow();\n  });\n});\n```\n\n### 6. E2E 테스트 (Webhook Controller)\n\n**파일**: `packages/relay-api/test/monitor.e2e-spec.ts`\n\n```typescript\ndescribe('Monitor Webhook (e2e)', () => {\n  let app: INestApplication;\n\n  beforeAll(async () => {\n    const moduleFixture = await Test.createTestingModule({\n      imports: [AppModule],\n    }).compile();\n\n    app = moduleFixture.createNestApplication();\n    await app.init();\n  });\n\n  it('POST /api/v1/webhook/monitor - should accept valid alert', () => {\n    return request(app.getHttpServer())\n      .post('/api/v1/webhook/monitor')\n      .set('X-Monitor-Event', 'balance-alert')\n      .send({\n        type: 'balance_alert',\n        relayer: 'oz-relayer-1',\n        address: '0x123',\n        balance: '50000000000000000',\n        threshold: '100000000000000000',\n        network: 'localhost',\n        timestamp: new Date().toISOString(),\n      })\n      .expect(200)\n      .expect({ received: true });\n  });\n\n  it('POST /api/v1/webhook/monitor - should work without API key (@Public)', () => {\n    return request(app.getHttpServer())\n      .post('/api/v1/webhook/monitor')\n      .send({ type: 'test' })\n      .expect(200);\n  });\n});\n```\n\n### 7. 설정 파일 검증\n\n```bash\n# JSON 설정 파일 문법 검증\ncd docker/config/oz-monitor\nfor f in networks/*.json monitors/*.json triggers/*.json; do\n  jq . \"$f\" > /dev/null && echo \"✅ $f valid\" || echo \"❌ $f invalid\"\ndone\n\n# 필터 스크립트 실행 권한 확인\nls -la filters/balance-threshold.sh\n# 예상: -rwxr-xr-x (실행 권한 있음)\n\n# 필터 스크립트 테스트\necho \"50000000000000000\" | ./filters/balance-threshold.sh 100000000000000000\n# 예상: \"true\" (50 < 100 이므로 알림 발생)\n```\n\n### 8. Health Check 확장 테스트 (Phase 2)\n\n```bash\n# Phase 2 Health Check 응답 확인\ncurl http://localhost:3000/api/v1/health | jq\n# 예상 응답 (Phase 2):\n# {\n#   \"status\": \"ok\",\n#   \"info\": {\n#     \"oz-relayer-pool\": { \"status\": \"healthy\" },\n#     \"redis\": { \"status\": \"healthy\" },\n#     \"oz-monitor\": { \"status\": \"healthy\" }\n#   }\n# }\n```\n\n### 9. 통합 시나리오 테스트\n\n**시나리오 1**: 정상 잔액 유지\n- 모든 Relayer 잔액 > 0.1 ETH\n- 알림 발생 없음 확인\n\n**시나리오 2**: 잔액 부족 알림\n- Relayer #1 잔액을 0.05 ETH로 설정\n- Slack/Discord 알림 수신 확인\n- Relay API 로그에 알림 처리 확인\n\n**시나리오 3**: 다중 Relayer 알림\n- 모든 Relayer 잔액을 임계값 이하로 설정\n- 3개 알림 모두 수신 확인\n\n**시나리오 4**: 네트워크 전환\n- localhost에서 Polygon Amoy로 네트워크 전환\n- 해당 네트워크의 Relayer 잔액 모니터링 확인",
        "status": "pending",
        "dependencies": [
          "17"
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": "17",
        "title": "Phase 2 Infrastructure Enhancement: Kubernetes Manifests, CI/CD Pipeline, and Grafana Monitoring Dashboard",
        "description": "Kubernetes manifests 작성, GitHub Actions 기반 CI/CD 파이프라인 구축, Prometheus/Grafana 대시보드 구성을 통해 프로덕션 배포 자동화 및 모니터링 시각화를 구현합니다.",
        "details": "## 구현 세부사항\n\n### 1. 디렉토리 구조\n\n```\nk8s/\n├── base/                           # Kustomize base manifests\n│   ├── kustomization.yaml\n│   ├── namespace.yaml              # msq-relayer namespace\n│   ├── configmap.yaml              # 환경 설정\n│   ├── secrets.yaml                # Secret 템플릿 (실제 값은 외부 관리)\n│   ├── relay-api/\n│   │   ├── deployment.yaml\n│   │   ├── service.yaml\n│   │   └── hpa.yaml                # Horizontal Pod Autoscaler\n│   ├── oz-relayer/\n│   │   ├── statefulset.yaml        # StatefulSet (개별 Private Key)\n│   │   ├── service.yaml\n│   │   └── pdb.yaml                # Pod Disruption Budget\n│   ├── redis/\n│   │   ├── statefulset.yaml\n│   │   ├── service.yaml\n│   │   └── pvc.yaml\n│   └── monitoring/\n│       ├── prometheus-config.yaml\n│       ├── grafana-deployment.yaml\n│       └── servicemonitor.yaml\n├── overlays/\n│   ├── development/\n│   │   └── kustomization.yaml\n│   ├── staging/\n│   │   └── kustomization.yaml\n│   └── production/\n│       ├── kustomization.yaml\n│       ├── ingress.yaml            # AWS ALB Ingress\n│       └── resource-limits.yaml\n└── helm/                           # Optional Helm charts\n    └── msq-relayer/\n        ├── Chart.yaml\n        ├── values.yaml\n        └── templates/\n\n.github/\n└── workflows/\n    ├── ci.yaml                     # Lint, Test, Build\n    ├── cd-staging.yaml             # Staging 배포\n    ├── cd-production.yaml          # Production 배포\n    └── security-scan.yaml          # 보안 스캔\n\nmonitoring/\n├── dashboards/\n│   ├── relay-api-dashboard.json    # Relay API Grafana 대시보드\n│   ├── oz-relayer-dashboard.json   # OZ Relayer 대시보드\n│   └── infrastructure-dashboard.json\n├── alerts/\n│   ├── relay-api-alerts.yaml\n│   └── relayer-balance-alerts.yaml\n└── prometheus/\n    └── prometheus.yaml\n```\n\n### 2. Kubernetes Manifests 구현\n\n**Namespace 및 기본 설정** (`k8s/base/namespace.yaml`):\n```yaml\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: msq-relayer\n  labels:\n    app.kubernetes.io/name: msq-relayer\n    app.kubernetes.io/part-of: msq-relayer-service\n```\n\n**Relay API Deployment** (`k8s/base/relay-api/deployment.yaml`):\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: relay-api\n  namespace: msq-relayer\nspec:\n  replicas: 2\n  selector:\n    matchLabels:\n      app: relay-api\n  template:\n    metadata:\n      labels:\n        app: relay-api\n      annotations:\n        prometheus.io/scrape: \"true\"\n        prometheus.io/port: \"3000\"\n        prometheus.io/path: \"/api/v1/metrics\"\n    spec:\n      containers:\n        - name: relay-api\n          image: ghcr.io/globalmsq/msq-relayer-service/relay-api:latest\n          ports:\n            - containerPort: 3000\n          env:\n            - name: NODE_ENV\n              value: \"production\"\n            - name: REDIS_URL\n              valueFrom:\n                secretKeyRef:\n                  name: msq-relayer-secrets\n                  key: redis-url\n            - name: RELAY_API_KEY\n              valueFrom:\n                secretKeyRef:\n                  name: msq-relayer-secrets\n                  key: relay-api-key\n          resources:\n            requests:\n              cpu: \"250m\"\n              memory: \"512Mi\"\n            limits:\n              cpu: \"1000m\"\n              memory: \"1Gi\"\n          livenessProbe:\n            httpGet:\n              path: /api/v1/health\n              port: 3000\n            initialDelaySeconds: 30\n            periodSeconds: 10\n          readinessProbe:\n            httpGet:\n              path: /api/v1/health\n              port: 3000\n            initialDelaySeconds: 5\n            periodSeconds: 5\n```\n\n**OZ Relayer StatefulSet** (`k8s/base/oz-relayer/statefulset.yaml`):\n```yaml\napiVersion: apps/v1\nkind: StatefulSet\nmetadata:\n  name: oz-relayer\n  namespace: msq-relayer\nspec:\n  serviceName: oz-relayer\n  replicas: 3\n  selector:\n    matchLabels:\n      app: oz-relayer\n  template:\n    spec:\n      containers:\n        - name: oz-relayer\n          image: openzeppelin/openzeppelin-relayer:latest\n          ports:\n            - containerPort: 8080\n            - containerPort: 8081\n          volumeMounts:\n            - name: config\n              mountPath: /app/config/config.json\n              subPath: config.json\n            - name: keystore\n              mountPath: /app/config/keys\n              readOnly: true\n      volumes:\n        - name: config\n          configMap:\n            name: oz-relayer-config\n        - name: keystore\n          secret:\n            secretName: oz-relayer-keystore\n```\n\n**HPA (Horizontal Pod Autoscaler)** (`k8s/base/relay-api/hpa.yaml`):\n```yaml\napiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: relay-api-hpa\n  namespace: msq-relayer\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: relay-api\n  minReplicas: 2\n  maxReplicas: 10\n  metrics:\n    - type: Resource\n      resource:\n        name: cpu\n        target:\n          type: Utilization\n          averageUtilization: 70\n    - type: Resource\n      resource:\n        name: memory\n        target:\n          type: Utilization\n          averageUtilization: 80\n```\n\n### 3. GitHub Actions CI/CD 파이프라인\n\n**CI Workflow** (`.github/workflows/ci.yaml`):\n```yaml\nname: CI\n\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main, develop]\n\njobs:\n  lint:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: pnpm/action-setup@v2\n        with:\n          version: 9.15.1\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '22'\n          cache: 'pnpm'\n      - run: pnpm install --frozen-lockfile\n      - run: pnpm run lint\n\n  test:\n    runs-on: ubuntu-latest\n    needs: lint\n    steps:\n      - uses: actions/checkout@v4\n      - uses: pnpm/action-setup@v2\n        with:\n          version: 9.15.1\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '22'\n          cache: 'pnpm'\n      - run: pnpm install --frozen-lockfile\n      - run: pnpm run test\n      - uses: codecov/codecov-action@v4\n        with:\n          files: ./coverage/lcov.info\n\n  build:\n    runs-on: ubuntu-latest\n    needs: test\n    steps:\n      - uses: actions/checkout@v4\n      - uses: docker/setup-buildx-action@v3\n      - uses: docker/login-action@v3\n        with:\n          registry: ghcr.io\n          username: ${{ github.actor }}\n          password: ${{ secrets.GITHUB_TOKEN }}\n      - uses: docker/build-push-action@v5\n        with:\n          context: .\n          file: docker/Dockerfile.packages\n          target: relay-api\n          push: ${{ github.event_name != 'pull_request' }}\n          tags: |\n            ghcr.io/${{ github.repository }}/relay-api:${{ github.sha }}\n            ghcr.io/${{ github.repository }}/relay-api:latest\n          cache-from: type=gha\n          cache-to: type=gha,mode=max\n\n  security-scan:\n    runs-on: ubuntu-latest\n    needs: build\n    steps:\n      - uses: actions/checkout@v4\n      - uses: aquasecurity/trivy-action@master\n        with:\n          image-ref: 'ghcr.io/${{ github.repository }}/relay-api:${{ github.sha }}'\n          format: 'sarif'\n          output: 'trivy-results.sarif'\n      - uses: github/codeql-action/upload-sarif@v3\n        with:\n          sarif_file: 'trivy-results.sarif'\n```\n\n**CD Staging Workflow** (`.github/workflows/cd-staging.yaml`):\n```yaml\nname: CD Staging\n\non:\n  push:\n    branches: [develop]\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    environment: staging\n    steps:\n      - uses: actions/checkout@v4\n      - uses: azure/setup-kubectl@v3\n      - uses: aws-actions/configure-aws-credentials@v4\n        with:\n          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}\n          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}\n          aws-region: ap-northeast-2\n      - run: aws eks update-kubeconfig --name msq-relayer-staging\n      - run: |\n          kubectl apply -k k8s/overlays/staging\n          kubectl -n msq-relayer set image deployment/relay-api \\\n            relay-api=ghcr.io/${{ github.repository }}/relay-api:${{ github.sha }}\n          kubectl -n msq-relayer rollout status deployment/relay-api\n```\n\n**CD Production Workflow** (`.github/workflows/cd-production.yaml`):\n```yaml\nname: CD Production\n\non:\n  release:\n    types: [published]\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    environment: production\n    steps:\n      - uses: actions/checkout@v4\n      - uses: azure/setup-kubectl@v3\n      - uses: aws-actions/configure-aws-credentials@v4\n        with:\n          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}\n          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}\n          aws-region: ap-northeast-2\n      - run: aws eks update-kubeconfig --name msq-relayer-production\n      - run: |\n          kubectl apply -k k8s/overlays/production\n          kubectl -n msq-relayer set image deployment/relay-api \\\n            relay-api=ghcr.io/${{ github.repository }}/relay-api:${{ github.ref_name }}\n          kubectl -n msq-relayer rollout status deployment/relay-api --timeout=300s\n```\n\n### 4. Grafana Dashboard 구성\n\n**Relay API Dashboard** (`monitoring/dashboards/relay-api-dashboard.json`):\n```json\n{\n  \"dashboard\": {\n    \"title\": \"MSQ Relay API\",\n    \"panels\": [\n      {\n        \"title\": \"Request Rate\",\n        \"type\": \"graph\",\n        \"targets\": [\n          {\n            \"expr\": \"rate(http_requests_total{service=\\\"relay-api\\\"}[5m])\",\n            \"legendFormat\": \"{{method}} {{path}}\"\n          }\n        ]\n      },\n      {\n        \"title\": \"Response Time (P95)\",\n        \"type\": \"graph\",\n        \"targets\": [\n          {\n            \"expr\": \"histogram_quantile(0.95, rate(http_request_duration_seconds_bucket{service=\\\"relay-api\\\"}[5m]))\",\n            \"legendFormat\": \"{{path}}\"\n          }\n        ]\n      },\n      {\n        \"title\": \"Error Rate\",\n        \"type\": \"stat\",\n        \"targets\": [\n          {\n            \"expr\": \"sum(rate(http_requests_total{service=\\\"relay-api\\\", status=~\\\"5..\\\"}[5m])) / sum(rate(http_requests_total{service=\\\"relay-api\\\"}[5m])) * 100\"\n          }\n        ]\n      },\n      {\n        \"title\": \"Transaction Status\",\n        \"type\": \"piechart\",\n        \"targets\": [\n          {\n            \"expr\": \"sum by (status) (relay_transactions_total)\"\n          }\n        ]\n      }\n    ]\n  }\n}\n```\n\n**OZ Relayer Dashboard Metrics**:\n- Relayer 잔액 모니터링 (Balance per relayer)\n- 트랜잭션 성공/실패율\n- Nonce 사용 현황\n- Gas 비용 추이\n- 평균 처리 시간\n\n**인프라 Dashboard Metrics**:\n- Pod CPU/Memory 사용량\n- Redis 연결 상태 및 메모리\n- Network I/O\n- Pod 재시작 횟수\n\n### 5. Prometheus 알림 규칙\n\n**Relay API Alerts** (`monitoring/alerts/relay-api-alerts.yaml`):\n```yaml\ngroups:\n  - name: relay-api-alerts\n    rules:\n      - alert: HighErrorRate\n        expr: |\n          sum(rate(http_requests_total{service=\"relay-api\", status=~\"5..\"}[5m])) \n          / sum(rate(http_requests_total{service=\"relay-api\"}[5m])) > 0.05\n        for: 5m\n        labels:\n          severity: critical\n        annotations:\n          summary: \"High error rate detected\"\n          description: \"Error rate is {{ $value | humanizePercentage }}\"\n\n      - alert: HighLatency\n        expr: |\n          histogram_quantile(0.95, rate(http_request_duration_seconds_bucket{service=\"relay-api\"}[5m])) > 3\n        for: 5m\n        labels:\n          severity: warning\n        annotations:\n          summary: \"High latency detected\"\n          description: \"P95 latency is {{ $value }}s\"\n\n      - alert: RelayerLowBalance\n        expr: relayer_balance_eth < 0.1\n        for: 10m\n        labels:\n          severity: critical\n        annotations:\n          summary: \"Relayer balance low\"\n          description: \"Relayer {{ $labels.relayer_id }} has only {{ $value }} ETH\"\n```\n\n### 6. AWS EKS 프로덕션 환경 설정\n\n**Production Ingress** (`k8s/overlays/production/ingress.yaml`):\n```yaml\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: relay-api-ingress\n  namespace: msq-relayer\n  annotations:\n    kubernetes.io/ingress.class: alb\n    alb.ingress.kubernetes.io/scheme: internet-facing\n    alb.ingress.kubernetes.io/target-type: ip\n    alb.ingress.kubernetes.io/certificate-arn: ${ACM_CERTIFICATE_ARN}\n    alb.ingress.kubernetes.io/ssl-policy: ELBSecurityPolicy-TLS-1-2-2017-01\nspec:\n  rules:\n    - host: relay-api.msq.io\n      http:\n        paths:\n          - path: /\n            pathType: Prefix\n            backend:\n              service:\n                name: relay-api\n                port:\n                  number: 3000\n```\n\n### 7. 기존 코드베이스 통합\n\n- `docker/Dockerfile.packages` 멀티스테이지 빌드 활용\n- `docker/docker-compose.yaml` 구성을 Kubernetes로 마이그레이션\n- 기존 Health Check 엔드포인트 (`/api/v1/health`) 활용\n- pnpm 패키지 매니저 사용 유지 (CI/CD에서 pnpm 사용)",
        "testStrategy": "## 테스트 전략\n\n### 1. Kubernetes Manifests 검증\n\n```bash\n# Kustomize 빌드 검증\nkubectl kustomize k8s/base\nkubectl kustomize k8s/overlays/staging\nkubectl kustomize k8s/overlays/production\n\n# YAML 구문 및 스키마 검증\nkubeval k8s/base/*.yaml\nkubeconform -strict k8s/base/**/*.yaml\n\n# 드라이런 배포 테스트\nkubectl apply -k k8s/overlays/staging --dry-run=server\n```\n\n### 2. CI/CD 파이프라인 테스트\n\n```bash\n# GitHub Actions 로컬 테스트 (act 사용)\nact -j lint\nact -j test\nact -j build --secret-file .secrets\n\n# Workflow 구문 검증\nactionlint .github/workflows/*.yaml\n```\n\n### 3. 로컬 Kubernetes 테스트 (kind/minikube)\n\n```bash\n# kind 클러스터 생성\nkind create cluster --name msq-relayer-test\n\n# 로컬 배포 테스트\nkubectl apply -k k8s/overlays/development\n\n# Pod 상태 확인\nkubectl -n msq-relayer get pods\nkubectl -n msq-relayer describe pod relay-api-xxx\n\n# 서비스 접근 테스트\nkubectl -n msq-relayer port-forward svc/relay-api 3000:3000\ncurl http://localhost:3000/api/v1/health\n```\n\n### 4. Grafana Dashboard 검증\n\n```bash\n# Grafana 대시보드 JSON 구문 검증\njq . monitoring/dashboards/*.json\n\n# Prometheus 규칙 검증\npromtool check rules monitoring/alerts/*.yaml\n\n# 로컬 Prometheus/Grafana 스택 테스트\ndocker compose -f monitoring/docker-compose.yaml up -d\n# Grafana UI에서 대시보드 import 및 시각화 확인\n```\n\n### 5. 통합 테스트 시나리오\n\n**Scenario 1: CI Pipeline 전체 흐름**\n- PR 생성 → Lint 통과 → Test 통과 → Build 성공 → Security Scan 완료\n- 예상 결과: 모든 job이 녹색 체크로 완료\n\n**Scenario 2: Staging 자동 배포**\n- develop 브랜치에 merge\n- 예상 결과: Staging 클러스터에 자동 배포, rollout status 성공\n\n**Scenario 3: Production 배포**\n- GitHub Release 생성 (v1.0.0)\n- 예상 결과: Production 클러스터에 배포, 300초 내 rollout 완료\n\n**Scenario 4: HPA 스케일링**\n- 부하 테스트 도구로 트래픽 증가 시뮬레이션\n- 예상 결과: CPU 70% 초과 시 Pod 수 자동 증가\n\n**Scenario 5: Grafana 알림**\n- 의도적으로 에러율 5% 초과 시뮬레이션\n- 예상 결과: Slack/Discord로 HighErrorRate 알림 수신\n\n### 6. 보안 검증\n\n```bash\n# Trivy 이미지 스캔\ntrivy image ghcr.io/globalmsq/msq-relayer-service/relay-api:latest\n\n# Kubernetes RBAC 검증\nkubectl auth can-i --list --as=system:serviceaccount:msq-relayer:relay-api\n\n# Network Policy 테스트\nkubectl -n msq-relayer exec relay-api-xxx -- curl redis:6379\n```\n\n### 7. Rollback 테스트\n\n```bash\n# 배포 이력 확인\nkubectl -n msq-relayer rollout history deployment/relay-api\n\n# 이전 버전으로 롤백\nkubectl -n msq-relayer rollout undo deployment/relay-api\n\n# 롤백 성공 확인\nkubectl -n msq-relayer rollout status deployment/relay-api\n```",
        "status": "pending",
        "dependencies": [
          "15",
          "19"
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": "18",
        "title": "Phase 2 Auto Scaling: KEDA 기반 Queue Depth 자동 스케일링 및 Relayer Pool 동적 리소스 할당",
        "description": "Kubernetes HPA와 KEDA(Kubernetes Event-Driven Autoscaling)를 활용하여 Redis Queue Depth 기반 자동 스케일링 시스템을 구현합니다. BullMQ 트랜잭션 큐의 대기 작업 수에 따라 Relay API 및 OZ Relayer Pool을 자동으로 scale out/in하고, 부하에 따른 동적 리소스 할당을 수행합니다.",
        "details": "## 구현 세부사항\n\n### 1. 디렉토리 구조\n\n```\nk8s/\n├── base/\n│   ├── keda/\n│   │   ├── kustomization.yaml\n│   │   ├── scaled-object-relay-api.yaml      # Relay API ScaledObject\n│   │   ├── scaled-object-oz-relayer.yaml     # OZ Relayer Pool ScaledObject\n│   │   ├── trigger-auth-redis.yaml           # Redis TriggerAuthentication\n│   │   └── scaled-job-tx-processor.yaml      # TX Processor ScaledJob (optional)\n│   ├── hpa/\n│   │   ├── hpa-relay-api.yaml                # CPU/Memory 기반 HPA (fallback)\n│   │   └── hpa-oz-relayer.yaml               # OZ Relayer HPA (fallback)\n│   └── resources/\n│       ├── resource-quota.yaml               # Namespace ResourceQuota\n│       ├── limit-range.yaml                  # Pod LimitRange\n│       └── priority-class.yaml               # PriorityClass 정의\n├── overlays/\n│   ├── staging/\n│   │   └── keda/\n│   │       ├── kustomization.yaml\n│   │       └── patches/\n│   │           └── scaled-object-patch.yaml  # minReplicaCount: 1\n│   └── production/\n│       └── keda/\n│           ├── kustomization.yaml\n│           └── patches/\n│               └── scaled-object-patch.yaml  # minReplicaCount: 2\n```\n\n### 2. KEDA 설치 및 설정\n\n**Helm Chart 설치** (k8s/base/keda/install.sh):\n```bash\n#!/bin/bash\n# KEDA v2.18+ 설치\nhelm repo add kedacore https://kedacore.github.io/charts\nhelm repo update\n\nhelm install keda kedacore/keda \\\n  --namespace keda \\\n  --create-namespace \\\n  --set prometheus.metricServer.enabled=true \\\n  --set prometheus.operator.enabled=true\n```\n\n### 3. Redis TriggerAuthentication\n\n**파일**: `k8s/base/keda/trigger-auth-redis.yaml`\n```yaml\napiVersion: v1\nkind: Secret\nmetadata:\n  name: redis-auth-secret\n  namespace: msq-relayer\ntype: Opaque\ndata:\n  redis_password: \"\"  # Base64 encoded, empty for local dev\n---\napiVersion: keda.sh/v1alpha1\nkind: TriggerAuthentication\nmetadata:\n  name: redis-trigger-auth\n  namespace: msq-relayer\nspec:\n  secretTargetRef:\n    - parameter: password\n      name: redis-auth-secret\n      key: redis_password\n```\n\n### 4. Relay API ScaledObject (Queue Depth 기반)\n\n**파일**: `k8s/base/keda/scaled-object-relay-api.yaml`\n```yaml\napiVersion: keda.sh/v1alpha1\nkind: ScaledObject\nmetadata:\n  name: relay-api-scaledobject\n  namespace: msq-relayer\n  labels:\n    app: relay-api\nspec:\n  scaleTargetRef:\n    name: relay-api\n    kind: Deployment\n  pollingInterval: 15                    # 15초마다 메트릭 확인\n  cooldownPeriod: 60                     # Scale down 대기 시간\n  minReplicaCount: 1                     # 최소 1개 (staging)\n  maxReplicaCount: 10                    # 최대 10개\n  fallback:\n    failureThreshold: 3\n    replicas: 2                          # Scaler 실패 시 fallback\n  triggers:\n    # Primary: Redis Queue Depth (BullMQ relay-jobs 큐)\n    - type: redis\n      metadata:\n        address: redis:6379\n        listName: bull:relay-jobs:wait   # BullMQ waiting queue\n        listLength: \"10\"                 # 대기 작업 10개당 1 replica\n        activationListLength: \"1\"        # 1개 이상 시 활성화\n        databaseIndex: \"0\"\n      authenticationRef:\n        name: redis-trigger-auth\n    # Secondary: CPU Usage (fallback)\n    - type: cpu\n      metricType: Utilization\n      metadata:\n        value: \"70\"                      # CPU 70% 초과 시 스케일 아웃\n    # Tertiary: Memory Usage (fallback)\n    - type: memory\n      metricType: Utilization\n      metadata:\n        value: \"80\"                      # Memory 80% 초과 시 스케일 아웃\n  advanced:\n    restoreToOriginalReplicaCount: true\n    horizontalPodAutoscalerConfig:\n      behavior:\n        scaleDown:\n          stabilizationWindowSeconds: 120\n          policies:\n            - type: Percent\n              value: 25\n              periodSeconds: 60\n        scaleUp:\n          stabilizationWindowSeconds: 0\n          policies:\n            - type: Pods\n              value: 2\n              periodSeconds: 15\n```\n\n### 5. OZ Relayer Pool ScaledObject\n\n**파일**: `k8s/base/keda/scaled-object-oz-relayer.yaml`\n```yaml\napiVersion: keda.sh/v1alpha1\nkind: ScaledObject\nmetadata:\n  name: oz-relayer-scaledobject\n  namespace: msq-relayer\n  labels:\n    app: oz-relayer\nspec:\n  scaleTargetRef:\n    name: oz-relayer\n    kind: StatefulSet                    # StatefulSet for persistent identity\n  pollingInterval: 10                    # 10초마다 메트릭 확인\n  cooldownPeriod: 120                    # Scale down 대기 시간 (Relayer 안정성)\n  minReplicaCount: 1                     # 최소 1개 (HA: 2개 권장)\n  maxReplicaCount: 5                     # 최대 5개 (Private Key 관리 고려)\n  triggers:\n    # Primary: Redis Queue Depth\n    - type: redis\n      metadata:\n        address: redis:6379\n        listName: bull:relay-jobs:active  # BullMQ active queue\n        listLength: \"5\"                   # 활성 작업 5개당 1 replica\n        activationListLength: \"1\"\n        databaseIndex: \"0\"\n      authenticationRef:\n        name: redis-trigger-auth\n    # Secondary: Prometheus 메트릭 (TX throughput)\n    - type: prometheus\n      metadata:\n        serverAddress: http://prometheus:9090\n        metricName: oz_relayer_tx_pending_total\n        threshold: \"20\"                   # 대기 TX 20개당 1 replica\n        query: |\n          sum(oz_relayer_tx_pending_total{namespace=\"msq-relayer\"})\n  advanced:\n    horizontalPodAutoscalerConfig:\n      behavior:\n        scaleDown:\n          stabilizationWindowSeconds: 180 # Relayer는 더 보수적으로\n          policies:\n            - type: Pods\n              value: 1\n              periodSeconds: 120\n        scaleUp:\n          stabilizationWindowSeconds: 0\n          policies:\n            - type: Pods\n              value: 1\n              periodSeconds: 30\n```\n\n### 6. Kubernetes HPA (Fallback)\n\n**파일**: `k8s/base/hpa/hpa-relay-api.yaml`\n```yaml\napiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: relay-api-hpa-fallback\n  namespace: msq-relayer\n  annotations:\n    description: \"Fallback HPA when KEDA is unavailable\"\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: relay-api\n  minReplicas: 1\n  maxReplicas: 10\n  metrics:\n    - type: Resource\n      resource:\n        name: cpu\n        target:\n          type: Utilization\n          averageUtilization: 70\n    - type: Resource\n      resource:\n        name: memory\n        target:\n          type: Utilization\n          averageUtilization: 80\n  behavior:\n    scaleDown:\n      stabilizationWindowSeconds: 120\n      policies:\n        - type: Percent\n          value: 25\n          periodSeconds: 60\n    scaleUp:\n      stabilizationWindowSeconds: 0\n      policies:\n        - type: Pods\n          value: 2\n          periodSeconds: 15\n```\n\n### 7. 동적 리소스 할당 (ResourceQuota & LimitRange)\n\n**파일**: `k8s/base/resources/resource-quota.yaml`\n```yaml\napiVersion: v1\nkind: ResourceQuota\nmetadata:\n  name: msq-relayer-quota\n  namespace: msq-relayer\nspec:\n  hard:\n    requests.cpu: \"8\"\n    requests.memory: \"16Gi\"\n    limits.cpu: \"16\"\n    limits.memory: \"32Gi\"\n    pods: \"50\"\n    persistentvolumeclaims: \"10\"\n```\n\n**파일**: `k8s/base/resources/limit-range.yaml`\n```yaml\napiVersion: v1\nkind: LimitRange\nmetadata:\n  name: msq-relayer-limits\n  namespace: msq-relayer\nspec:\n  limits:\n    - type: Pod\n      max:\n        cpu: \"4\"\n        memory: \"8Gi\"\n      min:\n        cpu: \"100m\"\n        memory: \"128Mi\"\n    - type: Container\n      default:\n        cpu: \"500m\"\n        memory: \"512Mi\"\n      defaultRequest:\n        cpu: \"100m\"\n        memory: \"256Mi\"\n      max:\n        cpu: \"2\"\n        memory: \"4Gi\"\n      min:\n        cpu: \"50m\"\n        memory: \"64Mi\"\n```\n\n### 8. PriorityClass 정의 (중요도 기반 스케줄링)\n\n**파일**: `k8s/base/resources/priority-class.yaml`\n```yaml\napiVersion: scheduling.k8s.io/v1\nkind: PriorityClass\nmetadata:\n  name: msq-relayer-critical\nvalue: 1000000\nglobalDefault: false\ndescription: \"Critical priority for OZ Relayer pods\"\n---\napiVersion: scheduling.k8s.io/v1\nkind: PriorityClass\nmetadata:\n  name: msq-relayer-high\nvalue: 100000\nglobalDefault: false\ndescription: \"High priority for Relay API pods\"\n---\napiVersion: scheduling.k8s.io/v1\nkind: PriorityClass\nmetadata:\n  name: msq-relayer-normal\nvalue: 10000\nglobalDefault: false\ndescription: \"Normal priority for supporting services\"\n```\n\n### 9. Relay API Deployment 업데이트 (KEDA 호환)\n\n**파일**: `k8s/base/relay-api/deployment.yaml` (추가 설정)\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: relay-api\n  namespace: msq-relayer\n  labels:\n    app: relay-api\n    keda.sh/scaling-enabled: \"true\"      # KEDA 스케일링 활성화\nspec:\n  # replicas: 제거 (KEDA가 관리)\n  selector:\n    matchLabels:\n      app: relay-api\n  template:\n    metadata:\n      labels:\n        app: relay-api\n    spec:\n      priorityClassName: msq-relayer-high\n      containers:\n        - name: relay-api\n          resources:\n            requests:\n              cpu: \"200m\"\n              memory: \"512Mi\"\n            limits:\n              cpu: \"1\"\n              memory: \"1Gi\"\n          readinessProbe:\n            httpGet:\n              path: /api/v1/health\n              port: 3000\n            initialDelaySeconds: 10\n            periodSeconds: 5\n          livenessProbe:\n            httpGet:\n              path: /api/v1/health\n              port: 3000\n            initialDelaySeconds: 30\n            periodSeconds: 10\n```\n\n### 10. OZ Relayer StatefulSet 업데이트 (KEDA 호환)\n\n**파일**: `k8s/base/oz-relayer/statefulset.yaml` (추가 설정)\n```yaml\napiVersion: apps/v1\nkind: StatefulSet\nmetadata:\n  name: oz-relayer\n  namespace: msq-relayer\n  labels:\n    app: oz-relayer\n    keda.sh/scaling-enabled: \"true\"\nspec:\n  serviceName: oz-relayer\n  # replicas: 제거 (KEDA가 관리)\n  podManagementPolicy: Parallel           # 병렬 스케일링\n  selector:\n    matchLabels:\n      app: oz-relayer\n  template:\n    metadata:\n      labels:\n        app: oz-relayer\n    spec:\n      priorityClassName: msq-relayer-critical\n      terminationGracePeriodSeconds: 120  # TX 완료 대기\n      containers:\n        - name: oz-relayer\n          resources:\n            requests:\n              cpu: \"500m\"\n              memory: \"1Gi\"\n            limits:\n              cpu: \"2\"\n              memory: \"4Gi\"\n          lifecycle:\n            preStop:\n              exec:\n                command:\n                  - /bin/sh\n                  - -c\n                  - |\n                    # Graceful shutdown: 진행 중인 TX 완료 대기\n                    echo \"Waiting for pending transactions...\"\n                    sleep 30\n```\n\n### 11. Grafana 대시보드 통합 (스케일링 모니터링)\n\n**Prometheus 메트릭 쿼리**:\n```promql\n# KEDA ScaledObject 메트릭\nkeda_scaler_metrics_value{scaler=\"redis\", scaledObject=\"relay-api-scaledobject\"}\nkeda_scaler_metrics_value{scaler=\"redis\", scaledObject=\"oz-relayer-scaledobject\"}\n\n# Replica 수 추이\nkube_deployment_spec_replicas{deployment=\"relay-api\", namespace=\"msq-relayer\"}\nkube_statefulset_replicas{statefulset=\"oz-relayer\", namespace=\"msq-relayer\"}\n\n# Queue Depth 추이\nredis_list_length{list=\"bull:relay-jobs:wait\"}\nredis_list_length{list=\"bull:relay-jobs:active\"}\n```\n\n### 12. 환경별 오버레이 설정\n\n**Production Patch** (`k8s/overlays/production/keda/patches/scaled-object-patch.yaml`):\n```yaml\napiVersion: keda.sh/v1alpha1\nkind: ScaledObject\nmetadata:\n  name: relay-api-scaledobject\nspec:\n  minReplicaCount: 2                      # Production: 최소 2개 (HA)\n  maxReplicaCount: 20                     # Production: 최대 20개\n  triggers:\n    - type: redis\n      metadata:\n        listLength: \"5\"                   # 더 민감한 스케일링\n        activationListLength: \"0\"         # 항상 활성화\n---\napiVersion: keda.sh/v1alpha1\nkind: ScaledObject\nmetadata:\n  name: oz-relayer-scaledobject\nspec:\n  minReplicaCount: 2                      # Production: 최소 2개 (HA)\n  maxReplicaCount: 10                     # Production: 최대 10개\n```",
        "testStrategy": "## 테스트 전략\n\n### 1. KEDA 설치 검증\n\n```bash\n# KEDA 설치 확인\nkubectl get pods -n keda\n# 예상: keda-operator, keda-metrics-apiserver 실행 상태\n\n# KEDA CRD 확인\nkubectl get crd | grep keda\n# 예상: scaledobjects.keda.sh, triggerauthentications.keda.sh 등\n\n# KEDA 버전 확인\nkubectl get deployment keda-operator -n keda -o jsonpath='{.spec.template.spec.containers[0].image}'\n# 예상: ghcr.io/kedacore/keda:2.18.x\n```\n\n### 2. ScaledObject 배포 및 상태 확인\n\n```bash\n# ScaledObject 배포\nkubectl apply -k k8s/overlays/staging/keda/\n\n# ScaledObject 상태 확인\nkubectl get scaledobject -n msq-relayer\n# 예상:\n# NAME                      SCALETARGETKIND      SCALETARGETNAME   MIN   MAX   TRIGGERS   AUTHENTICATION          READY\n# relay-api-scaledobject    apps/v1.Deployment   relay-api         1     10    redis      redis-trigger-auth      True\n# oz-relayer-scaledobject   apps/v1.StatefulSet  oz-relayer        1     5     redis      redis-trigger-auth      True\n\n# ScaledObject 상세 상태\nkubectl describe scaledobject relay-api-scaledobject -n msq-relayer\n# 예상: Status.Conditions에 \"Ready: True\" 확인\n\n# HPA 자동 생성 확인\nkubectl get hpa -n msq-relayer\n# 예상: keda-hpa-relay-api-scaledobject, keda-hpa-oz-relayer-scaledobject\n```\n\n### 3. Queue Depth 기반 Scale Out 테스트\n\n```bash\n# 현재 replica 수 확인\nkubectl get deployment relay-api -n msq-relayer -o jsonpath='{.spec.replicas}'\n# 예상: 1 (초기 상태)\n\n# Redis Queue에 테스트 작업 추가 (BullMQ 시뮬레이션)\nkubectl exec -n msq-relayer redis-0 -- redis-cli RPUSH \"bull:relay-jobs:wait\" \"job1\" \"job2\" \"job3\" \"job4\" \"job5\" \"job6\" \"job7\" \"job8\" \"job9\" \"job10\" \"job11\" \"job12\"\n# 12개 작업 추가 (listLength: 10 → 2 replicas 예상)\n\n# 15초 대기 후 replica 수 확인\nsleep 20\nkubectl get deployment relay-api -n msq-relayer -o jsonpath='{.spec.replicas}'\n# 예상: 2 (10개당 1 replica)\n\n# Pod 수 확인\nkubectl get pods -n msq-relayer -l app=relay-api\n# 예상: relay-api-xxx, relay-api-yyy (2개 Pod)\n```\n\n### 4. Scale Down 테스트\n\n```bash\n# Redis Queue 비우기\nkubectl exec -n msq-relayer redis-0 -- redis-cli DEL \"bull:relay-jobs:wait\"\n\n# cooldownPeriod (60초) + stabilizationWindow (120초) 대기\necho \"Waiting for scale down (180 seconds)...\"\nsleep 180\n\n# replica 수 확인\nkubectl get deployment relay-api -n msq-relayer -o jsonpath='{.spec.replicas}'\n# 예상: 1 (minReplicaCount)\n```\n\n### 5. OZ Relayer StatefulSet 스케일링 테스트\n\n```bash\n# 현재 OZ Relayer replica 수\nkubectl get statefulset oz-relayer -n msq-relayer -o jsonpath='{.spec.replicas}'\n# 예상: 1\n\n# Active 큐에 작업 추가\nkubectl exec -n msq-relayer redis-0 -- redis-cli RPUSH \"bull:relay-jobs:active\" \"tx1\" \"tx2\" \"tx3\" \"tx4\" \"tx5\" \"tx6\"\n# 6개 작업 (listLength: 5 → 2 replicas 예상)\n\n# 스케일 아웃 확인\nsleep 15\nkubectl get statefulset oz-relayer -n msq-relayer\n# 예상: READY 2/2\n\n# StatefulSet Pod 확인 (순서대로 생성)\nkubectl get pods -n msq-relayer -l app=oz-relayer\n# 예상: oz-relayer-0, oz-relayer-1\n```\n\n### 6. CPU/Memory Trigger Fallback 테스트\n\n```bash\n# CPU 부하 테스트 (relay-api 내부)\nkubectl exec -n msq-relayer deploy/relay-api -- sh -c \"while true; do :; done\" &\n\n# CPU 사용량 모니터링\nkubectl top pods -n msq-relayer -l app=relay-api\n# 예상: CPU 70% 초과\n\n# 스케일 아웃 확인\nkubectl get hpa keda-hpa-relay-api-scaledobject -n msq-relayer\n# 예상: TARGETS에 CPU 메트릭 표시, REPLICAS 증가\n\n# 부하 종료\nkubectl exec -n msq-relayer deploy/relay-api -- pkill -f \"while true\"\n```\n\n### 7. ResourceQuota 및 LimitRange 검증\n\n```bash\n# ResourceQuota 상태 확인\nkubectl describe resourcequota msq-relayer-quota -n msq-relayer\n# 예상: Used/Hard 비율 확인\n\n# LimitRange 적용 확인\nkubectl describe limitrange msq-relayer-limits -n msq-relayer\n\n# Pod 리소스 요청/제한 확인\nkubectl get pods -n msq-relayer -o custom-columns=\"NAME:.metadata.name,CPU_REQ:.spec.containers[0].resources.requests.cpu,MEM_REQ:.spec.containers[0].resources.requests.memory\"\n```\n\n### 8. PriorityClass 검증\n\n```bash\n# PriorityClass 확인\nkubectl get priorityclass | grep msq-relayer\n# 예상: msq-relayer-critical (1000000), msq-relayer-high (100000)\n\n# Pod PriorityClass 적용 확인\nkubectl get pods -n msq-relayer -o custom-columns=\"NAME:.metadata.name,PRIORITY:.spec.priorityClassName\"\n# 예상: oz-relayer-x: msq-relayer-critical, relay-api-x: msq-relayer-high\n```\n\n### 9. Graceful Shutdown 테스트 (OZ Relayer)\n\n```bash\n# Pod 삭제 시 graceful shutdown 확인\nkubectl delete pod oz-relayer-1 -n msq-relayer &\nkubectl logs -f oz-relayer-1 -n msq-relayer\n# 예상: \"Waiting for pending transactions...\" 로그 후 30초 대기\n\n# terminationGracePeriodSeconds 동작 확인\nkubectl get pod oz-relayer-1 -n msq-relayer -w\n# 예상: Terminating 상태에서 120초 이내 종료\n```\n\n### 10. 부하 테스트 통합 (k6 또는 Artillery)\n\n```bash\n# k6 부하 테스트 스크립트 실행\nk6 run --vus 50 --duration 5m scripts/load-test.js\n\n# 스케일링 추이 모니터링 (별도 터미널)\nwatch -n 5 'kubectl get pods -n msq-relayer -l \"app in (relay-api, oz-relayer)\" && echo \"---\" && kubectl get hpa -n msq-relayer'\n\n# 예상 결과:\n# - Queue Depth 증가 → replica 증가\n# - 부하 감소 → cooldown 후 replica 감소\n# - 최소 replica 유지\n```\n\n### 11. Grafana 대시보드 검증\n\n```bash\n# Prometheus 메트릭 쿼리 테스트\nkubectl port-forward svc/prometheus 9090:9090 -n monitoring\n\n# 브라우저에서 확인:\n# - keda_scaler_metrics_value{scaledObject=\"relay-api-scaledobject\"}\n# - kube_deployment_spec_replicas{deployment=\"relay-api\"}\n\n# Grafana 대시보드 접근\nkubectl port-forward svc/grafana 3001:3000 -n monitoring\n# MSQ Relayer Auto Scaling 대시보드 확인\n```\n\n### 12. 장애 복구 테스트\n\n```bash\n# Redis 장애 시뮬레이션\nkubectl scale statefulset redis --replicas=0 -n msq-relayer\n\n# KEDA fallback 동작 확인\nkubectl get scaledobject relay-api-scaledobject -n msq-relayer -o jsonpath='{.status.conditions}'\n# 예상: Ready: False\n\nkubectl get deployment relay-api -n msq-relayer -o jsonpath='{.spec.replicas}'\n# 예상: 2 (fallback.replicas)\n\n# Redis 복구\nkubectl scale statefulset redis --replicas=1 -n msq-relayer\n\n# 정상 동작 확인\nsleep 30\nkubectl get scaledobject relay-api-scaledobject -n msq-relayer -o jsonpath='{.status.conditions}'\n# 예상: Ready: True\n```",
        "status": "pending",
        "dependencies": [
          "15",
          "17"
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": "19",
        "title": "Phase 2 Policy Engine: NestJS 기반 접근 제어 시스템 구현",
        "description": "NestJS Policy Module을 구현하여 Contract Whitelist(허용된 컨트랙트/메서드만 실행), User Blacklist(악의적 사용자 차단), Rate Limiting(@nestjs/throttler 기반 API 요청 제한) 정책을 적용하는 종합적인 접근 제어 시스템을 구축합니다.",
        "details": "## 구현 세부사항\n\n### 1. 디렉토리 구조\n\n```\npackages/relay-api/src/policy/\n├── policy.module.ts                    # PolicyModule 정의\n├── guards/\n│   ├── policy.guard.ts                 # 통합 Policy Guard (Contract/Method Whitelist + User Blacklist)\n│   ├── contract-whitelist.guard.ts     # Contract Whitelist Guard\n│   └── rate-limit.guard.ts             # Custom ThrottlerGuard (API Key 기반 추적)\n├── services/\n│   ├── whitelist.service.ts            # Contract/Method Whitelist 관리\n│   ├── blacklist.service.ts            # User Blacklist 관리\n│   └── policy-config.service.ts        # 정책 설정 로드/관리\n├── decorators/\n│   ├── skip-policy.decorator.ts        # @SkipPolicy() 데코레이터\n│   └── policy-override.decorator.ts    # 정책 오버라이드 데코레이터\n├── dto/\n│   ├── whitelist-entry.dto.ts          # Whitelist 항목 DTO\n│   ├── blacklist-entry.dto.ts          # Blacklist 항목 DTO\n│   └── policy-config.dto.ts            # 정책 설정 DTO\n├── interfaces/\n│   ├── policy.interface.ts             # Policy 인터페이스 정의\n│   └── whitelist-entry.interface.ts    # Whitelist Entry 타입\n└── __tests__/\n    ├── whitelist.service.spec.ts\n    ├── blacklist.service.spec.ts\n    ├── policy.guard.spec.ts\n    └── rate-limit.guard.spec.ts\n```\n\n### 2. 의존성 설치\n\n```bash\ncd packages/relay-api\npnpm add @nestjs/throttler ioredis\npnpm add -D @types/ioredis\n```\n\n### 3. ThrottlerModule 설정 (Rate Limiting)\n\n**app.module.ts 업데이트**:\n```typescript\nimport { ThrottlerModule, ThrottlerGuard } from '@nestjs/throttler';\nimport { APP_GUARD } from '@nestjs/core';\n\n@Module({\n  imports: [\n    ThrottlerModule.forRoot([\n      {\n        name: 'short',\n        ttl: 1000,    // 1초\n        limit: 5,     // 초당 5회\n      },\n      {\n        name: 'medium',\n        ttl: 60000,   // 1분\n        limit: 100,   // 분당 100회\n      },\n      {\n        name: 'long',\n        ttl: 3600000, // 1시간\n        limit: 1000,  // 시간당 1000회\n      },\n    ]),\n    PolicyModule,\n    // ... 기존 imports\n  ],\n  providers: [\n    {\n      provide: APP_GUARD,\n      useClass: PolicyThrottlerGuard, // Custom Throttler Guard\n    },\n  ],\n})\nexport class AppModule {}\n```\n\n### 4. Contract Whitelist 서비스\n\n```typescript\n// whitelist.service.ts\nimport { Injectable, OnModuleInit, Logger } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\n\nexport interface WhitelistEntry {\n  contractAddress: string;      // 허용된 컨트랙트 주소\n  allowedMethods: string[];     // 허용된 메서드 셀렉터 (4바이트 hex)\n  description?: string;         // 설명\n  enabled: boolean;             // 활성화 여부\n}\n\n@Injectable()\nexport class WhitelistService implements OnModuleInit {\n  private readonly logger = new Logger(WhitelistService.name);\n  private whitelist: Map<string, WhitelistEntry> = new Map();\n\n  constructor(private readonly configService: ConfigService) {}\n\n  async onModuleInit() {\n    await this.loadWhitelist();\n  }\n\n  private async loadWhitelist(): Promise<void> {\n    // Phase 2: 환경변수 또는 설정 파일에서 로드\n    // Phase 3+: MySQL/Redis에서 동적 로드\n    const whitelistConfig = this.configService.get<WhitelistEntry[]>('POLICY_WHITELIST', []);\n    whitelistConfig.forEach(entry => {\n      this.whitelist.set(entry.contractAddress.toLowerCase(), entry);\n    });\n    this.logger.log(`Loaded ${this.whitelist.size} whitelist entries`);\n  }\n\n  isContractAllowed(contractAddress: string): boolean {\n    const entry = this.whitelist.get(contractAddress.toLowerCase());\n    return entry?.enabled ?? false;\n  }\n\n  isMethodAllowed(contractAddress: string, methodSelector: string): boolean {\n    const entry = this.whitelist.get(contractAddress.toLowerCase());\n    if (!entry?.enabled) return false;\n    \n    // 빈 배열 = 모든 메서드 허용\n    if (entry.allowedMethods.length === 0) return true;\n    \n    return entry.allowedMethods.includes(methodSelector.toLowerCase());\n  }\n\n  validateTransaction(to: string, data: string): { allowed: boolean; reason?: string } {\n    if (!this.isContractAllowed(to)) {\n      return { allowed: false, reason: `Contract ${to} is not whitelisted` };\n    }\n\n    const methodSelector = data.slice(0, 10); // 0x + 8 chars\n    if (!this.isMethodAllowed(to, methodSelector)) {\n      return { allowed: false, reason: `Method ${methodSelector} is not allowed for contract ${to}` };\n    }\n\n    return { allowed: true };\n  }\n}\n```\n\n### 5. User Blacklist 서비스\n\n```typescript\n// blacklist.service.ts\nimport { Injectable, OnModuleInit, Logger } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\n\nexport interface BlacklistEntry {\n  address: string;              // 차단된 주소\n  reason: string;               // 차단 사유\n  blockedAt: Date;              // 차단 시각\n  expiresAt?: Date;             // 만료 시각 (없으면 영구 차단)\n}\n\n@Injectable()\nexport class BlacklistService implements OnModuleInit {\n  private readonly logger = new Logger(BlacklistService.name);\n  private blacklist: Map<string, BlacklistEntry> = new Map();\n\n  constructor(private readonly configService: ConfigService) {}\n\n  async onModuleInit() {\n    await this.loadBlacklist();\n  }\n\n  private async loadBlacklist(): Promise<void> {\n    const blacklistConfig = this.configService.get<BlacklistEntry[]>('POLICY_BLACKLIST', []);\n    blacklistConfig.forEach(entry => {\n      this.blacklist.set(entry.address.toLowerCase(), entry);\n    });\n    this.logger.log(`Loaded ${this.blacklist.size} blacklist entries`);\n  }\n\n  isBlacklisted(address: string): { blocked: boolean; reason?: string } {\n    const entry = this.blacklist.get(address.toLowerCase());\n    if (!entry) return { blocked: false };\n\n    // 만료 체크\n    if (entry.expiresAt && new Date() > entry.expiresAt) {\n      this.blacklist.delete(address.toLowerCase());\n      return { blocked: false };\n    }\n\n    return { blocked: true, reason: entry.reason };\n  }\n\n  // Phase 3+: 동적 추가/삭제 API\n  async addToBlacklist(entry: BlacklistEntry): Promise<void> {\n    this.blacklist.set(entry.address.toLowerCase(), entry);\n    this.logger.warn(`Added ${entry.address} to blacklist: ${entry.reason}`);\n  }\n\n  async removeFromBlacklist(address: string): Promise<boolean> {\n    const deleted = this.blacklist.delete(address.toLowerCase());\n    if (deleted) {\n      this.logger.log(`Removed ${address} from blacklist`);\n    }\n    return deleted;\n  }\n}\n```\n\n### 6. Policy Guard 구현\n\n```typescript\n// policy.guard.ts\nimport {\n  Injectable,\n  CanActivate,\n  ExecutionContext,\n  ForbiddenException,\n  Logger,\n} from '@nestjs/common';\nimport { Reflector } from '@nestjs/core';\nimport { WhitelistService } from '../services/whitelist.service';\nimport { BlacklistService } from '../services/blacklist.service';\n\n@Injectable()\nexport class PolicyGuard implements CanActivate {\n  private readonly logger = new Logger(PolicyGuard.name);\n\n  constructor(\n    private readonly reflector: Reflector,\n    private readonly whitelistService: WhitelistService,\n    private readonly blacklistService: BlacklistService,\n  ) {}\n\n  async canActivate(context: ExecutionContext): Promise<boolean> {\n    // @SkipPolicy() 체크\n    const skipPolicy = this.reflector.getAllAndOverride<boolean>('skipPolicy', [\n      context.getHandler(),\n      context.getClass(),\n    ]);\n    if (skipPolicy) return true;\n\n    const request = context.switchToHttp().getRequest();\n    const body = request.body;\n\n    // Direct TX: body.to, body.data 검증\n    // Gasless TX: body.request.to, body.request.data 검증\n    const to = body.to || body.request?.to;\n    const data = body.data || body.request?.data;\n    const from = body.request?.from; // Gasless TX에서 사용자 주소\n\n    if (!to || !data) {\n      return true; // 다른 엔드포인트는 패스\n    }\n\n    // 1. User Blacklist 체크 (Gasless TX만)\n    if (from) {\n      const blacklistResult = this.blacklistService.isBlacklisted(from);\n      if (blacklistResult.blocked) {\n        this.logger.warn(`Blocked request from blacklisted user: ${from}`);\n        throw new ForbiddenException(`User is blacklisted: ${blacklistResult.reason}`);\n      }\n    }\n\n    // 2. Contract Whitelist 체크\n    const whitelistResult = this.whitelistService.validateTransaction(to, data);\n    if (!whitelistResult.allowed) {\n      this.logger.warn(`Blocked transaction: ${whitelistResult.reason}`);\n      throw new ForbiddenException(whitelistResult.reason);\n    }\n\n    return true;\n  }\n}\n```\n\n### 7. Custom Throttler Guard (API Key 기반)\n\n```typescript\n// rate-limit.guard.ts\nimport { Injectable, ExecutionContext } from '@nestjs/common';\nimport { ThrottlerGuard, ThrottlerRequest } from '@nestjs/throttler';\nimport { Reflector } from '@nestjs/core';\n\n@Injectable()\nexport class PolicyThrottlerGuard extends ThrottlerGuard {\n  constructor(\n    protected readonly options: any,\n    protected readonly storageService: any,\n    protected readonly reflector: Reflector,\n  ) {\n    super(options, storageService, reflector);\n  }\n\n  protected async getTracker(req: Record<string, any>): Promise<string> {\n    // API Key 기반 추적 (각 클라이언트 서비스별 Rate Limit)\n    const apiKey = req.headers['x-api-key'];\n    if (apiKey) {\n      return `apikey-${apiKey}`;\n    }\n\n    // Gasless TX의 경우 사용자 주소 기반 추적\n    const userAddress = req.body?.request?.from;\n    if (userAddress) {\n      return `user-${userAddress.toLowerCase()}`;\n    }\n\n    // 기본: IP 기반\n    return req.ip;\n  }\n\n  protected async shouldSkip(context: ExecutionContext): Promise<boolean> {\n    // @SkipThrottle() 또는 @Public() 체크\n    const isPublic = this.reflector.getAllAndOverride<boolean>('isPublic', [\n      context.getHandler(),\n      context.getClass(),\n    ]);\n    if (isPublic) return true;\n\n    return super.shouldSkip(context);\n  }\n}\n```\n\n### 8. Policy Module 정의\n\n```typescript\n// policy.module.ts\nimport { Module, Global } from '@nestjs/common';\nimport { ConfigModule } from '@nestjs/config';\nimport { WhitelistService } from './services/whitelist.service';\nimport { BlacklistService } from './services/blacklist.service';\nimport { PolicyGuard } from './guards/policy.guard';\n\n@Global()\n@Module({\n  imports: [ConfigModule],\n  providers: [\n    WhitelistService,\n    BlacklistService,\n    PolicyGuard,\n  ],\n  exports: [\n    WhitelistService,\n    BlacklistService,\n    PolicyGuard,\n  ],\n})\nexport class PolicyModule {}\n```\n\n### 9. 환경변수 설정\n\n**docker/docker-compose.yaml 업데이트**:\n```yaml\nrelay-api:\n  environment:\n    # Rate Limiting 설정\n    THROTTLE_TTL: 60000          # 기본 TTL (ms)\n    THROTTLE_LIMIT: 100          # 기본 요청 제한\n\n    # Policy 설정 (JSON 문자열)\n    POLICY_WHITELIST: '[{\"contractAddress\":\"0x...\", \"allowedMethods\":[\"0xa9059cbb\"], \"enabled\":true}]'\n    POLICY_BLACKLIST: '[]'\n    \n    # Policy 활성화 플래그\n    POLICY_ENABLED: 'true'\n```\n\n### 10. Relay Controller 업데이트\n\n**relay/direct/direct.controller.ts**:\n```typescript\nimport { UseGuards } from '@nestjs/common';\nimport { Throttle } from '@nestjs/throttler';\nimport { PolicyGuard } from '../../policy/guards/policy.guard';\n\n@Controller('api/v1/relay')\n@UseGuards(PolicyGuard)\nexport class DirectController {\n  @Post('direct')\n  @Throttle({ default: { limit: 50, ttl: 60000 } }) // 분당 50회\n  async sendDirectTransaction(@Body() dto: DirectTxRequestDto) {\n    // ...\n  }\n}\n```\n\n**relay/gasless/gasless.controller.ts**:\n```typescript\n@Controller('api/v1/relay')\n@UseGuards(PolicyGuard)\nexport class GaslessController {\n  @Post('gasless')\n  @Throttle({ \n    short: { limit: 10, ttl: 1000 },    // 초당 10회\n    medium: { limit: 100, ttl: 60000 }, // 분당 100회\n  })\n  async sendGaslessTransaction(@Body() dto: GaslessTxRequestDto) {\n    // ...\n  }\n\n  @Get('gasless/nonce/:address')\n  @Throttle({ default: { limit: 200, ttl: 60000 } }) // Nonce 조회는 더 관대하게\n  async getNonce(@Param('address') address: string) {\n    // ...\n  }\n}\n```\n\n### 11. 에러 응답 표준화\n\n```typescript\n// 403 Forbidden 응답 예시\n{\n  \"statusCode\": 403,\n  \"message\": \"Contract 0x... is not whitelisted\",\n  \"error\": \"Forbidden\",\n  \"timestamp\": \"2025-12-26T10:00:00.000Z\"\n}\n\n// 429 Too Many Requests 응답 예시\n{\n  \"statusCode\": 429,\n  \"message\": \"ThrottlerException: Too Many Requests\",\n  \"error\": \"Too Many Requests\",\n  \"retryAfter\": 60\n}\n```",
        "testStrategy": "## 테스트 전략\n\n### 1. Whitelist Service 단위 테스트\n\n```typescript\n// whitelist.service.spec.ts\ndescribe('WhitelistService', () => {\n  let service: WhitelistService;\n\n  beforeEach(async () => {\n    const module = await Test.createTestingModule({\n      providers: [\n        WhitelistService,\n        {\n          provide: ConfigService,\n          useValue: {\n            get: jest.fn().mockReturnValue([\n              {\n                contractAddress: '0x1234567890123456789012345678901234567890',\n                allowedMethods: ['0xa9059cbb'], // transfer(address,uint256)\n                enabled: true,\n              },\n            ]),\n          },\n        },\n      ],\n    }).compile();\n\n    service = module.get<WhitelistService>(WhitelistService);\n    await service.onModuleInit();\n  });\n\n  describe('isContractAllowed', () => {\n    it('should return true for whitelisted contract', () => {\n      expect(service.isContractAllowed('0x1234567890123456789012345678901234567890')).toBe(true);\n    });\n\n    it('should return false for non-whitelisted contract', () => {\n      expect(service.isContractAllowed('0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa')).toBe(false);\n    });\n\n    it('should be case-insensitive', () => {\n      expect(service.isContractAllowed('0x1234567890123456789012345678901234567890'.toUpperCase())).toBe(true);\n    });\n  });\n\n  describe('isMethodAllowed', () => {\n    it('should return true for allowed method', () => {\n      expect(service.isMethodAllowed('0x1234567890123456789012345678901234567890', '0xa9059cbb')).toBe(true);\n    });\n\n    it('should return false for disallowed method', () => {\n      expect(service.isMethodAllowed('0x1234567890123456789012345678901234567890', '0x23b872dd')).toBe(false);\n    });\n  });\n\n  describe('validateTransaction', () => {\n    it('should return allowed for valid transaction', () => {\n      const result = service.validateTransaction(\n        '0x1234567890123456789012345678901234567890',\n        '0xa9059cbb0000...'\n      );\n      expect(result.allowed).toBe(true);\n    });\n\n    it('should return not allowed for invalid contract', () => {\n      const result = service.validateTransaction(\n        '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',\n        '0xa9059cbb0000...'\n      );\n      expect(result.allowed).toBe(false);\n      expect(result.reason).toContain('not whitelisted');\n    });\n  });\n});\n```\n\n### 2. Blacklist Service 단위 테스트\n\n```typescript\n// blacklist.service.spec.ts\ndescribe('BlacklistService', () => {\n  let service: BlacklistService;\n\n  beforeEach(async () => {\n    const module = await Test.createTestingModule({\n      providers: [\n        BlacklistService,\n        {\n          provide: ConfigService,\n          useValue: {\n            get: jest.fn().mockReturnValue([\n              {\n                address: '0xbad1234567890123456789012345678901234567',\n                reason: 'Malicious activity detected',\n                blockedAt: new Date(),\n              },\n            ]),\n          },\n        },\n      ],\n    }).compile();\n\n    service = module.get<BlacklistService>(BlacklistService);\n    await service.onModuleInit();\n  });\n\n  describe('isBlacklisted', () => {\n    it('should return blocked true for blacklisted address', () => {\n      const result = service.isBlacklisted('0xbad1234567890123456789012345678901234567');\n      expect(result.blocked).toBe(true);\n      expect(result.reason).toContain('Malicious');\n    });\n\n    it('should return blocked false for non-blacklisted address', () => {\n      const result = service.isBlacklisted('0xgood23456789012345678901234567890123456');\n      expect(result.blocked).toBe(false);\n    });\n\n    it('should handle expired blacklist entries', async () => {\n      await service.addToBlacklist({\n        address: '0xexpired567890123456789012345678901234567',\n        reason: 'Temporary ban',\n        blockedAt: new Date(Date.now() - 3600000),\n        expiresAt: new Date(Date.now() - 1000), // 이미 만료\n      });\n      const result = service.isBlacklisted('0xexpired567890123456789012345678901234567');\n      expect(result.blocked).toBe(false);\n    });\n  });\n});\n```\n\n### 3. Policy Guard 통합 테스트\n\n```typescript\n// policy.guard.spec.ts\ndescribe('PolicyGuard', () => {\n  let guard: PolicyGuard;\n  let whitelistService: WhitelistService;\n  let blacklistService: BlacklistService;\n\n  beforeEach(async () => {\n    const module = await Test.createTestingModule({\n      providers: [\n        PolicyGuard,\n        {\n          provide: WhitelistService,\n          useValue: {\n            validateTransaction: jest.fn(),\n          },\n        },\n        {\n          provide: BlacklistService,\n          useValue: {\n            isBlacklisted: jest.fn(),\n          },\n        },\n        Reflector,\n      ],\n    }).compile();\n\n    guard = module.get<PolicyGuard>(PolicyGuard);\n    whitelistService = module.get<WhitelistService>(WhitelistService);\n    blacklistService = module.get<BlacklistService>(BlacklistService);\n  });\n\n  it('should allow whitelisted transactions', async () => {\n    jest.spyOn(whitelistService, 'validateTransaction').mockReturnValue({ allowed: true });\n    jest.spyOn(blacklistService, 'isBlacklisted').mockReturnValue({ blocked: false });\n\n    const mockContext = createMockExecutionContext({\n      body: { to: '0x...', data: '0x...' },\n    });\n\n    expect(await guard.canActivate(mockContext)).toBe(true);\n  });\n\n  it('should block non-whitelisted contracts', async () => {\n    jest.spyOn(whitelistService, 'validateTransaction').mockReturnValue({\n      allowed: false,\n      reason: 'Contract not whitelisted',\n    });\n\n    const mockContext = createMockExecutionContext({\n      body: { to: '0x...', data: '0x...' },\n    });\n\n    await expect(guard.canActivate(mockContext)).rejects.toThrow(ForbiddenException);\n  });\n\n  it('should block blacklisted users', async () => {\n    jest.spyOn(blacklistService, 'isBlacklisted').mockReturnValue({\n      blocked: true,\n      reason: 'Malicious activity',\n    });\n\n    const mockContext = createMockExecutionContext({\n      body: { request: { from: '0xbad...', to: '0x...', data: '0x...' } },\n    });\n\n    await expect(guard.canActivate(mockContext)).rejects.toThrow(ForbiddenException);\n  });\n});\n```\n\n### 4. Rate Limiting E2E 테스트\n\n```typescript\n// rate-limiting.e2e-spec.ts\ndescribe('Rate Limiting (e2e)', () => {\n  let app: INestApplication;\n\n  beforeAll(async () => {\n    const moduleFixture = await Test.createTestingModule({\n      imports: [AppModule],\n    }).compile();\n\n    app = moduleFixture.createNestApplication();\n    await app.init();\n  });\n\n  it('should allow requests within rate limit', async () => {\n    for (let i = 0; i < 5; i++) {\n      const response = await request(app.getHttpServer())\n        .post('/api/v1/relay/direct')\n        .set('x-api-key', 'test-key')\n        .send({ to: '0x...', data: '0x...' });\n      \n      expect(response.status).not.toBe(429);\n    }\n  });\n\n  it('should return 429 when rate limit exceeded', async () => {\n    // 초과 요청 시뮬레이션\n    const promises = Array(20).fill(null).map(() =>\n      request(app.getHttpServer())\n        .post('/api/v1/relay/direct')\n        .set('x-api-key', 'flood-test-key')\n        .send({ to: '0x...', data: '0x...' })\n    );\n\n    const responses = await Promise.all(promises);\n    const rateLimited = responses.filter(r => r.status === 429);\n    \n    expect(rateLimited.length).toBeGreaterThan(0);\n  });\n\n  it('should include Retry-After header on 429', async () => {\n    // Rate limit 초과 후\n    const response = await request(app.getHttpServer())\n      .post('/api/v1/relay/direct')\n      .set('x-api-key', 'limited-key')\n      .send({ to: '0x...', data: '0x...' });\n\n    if (response.status === 429) {\n      expect(response.headers['retry-after']).toBeDefined();\n    }\n  });\n});\n```\n\n### 5. Docker Compose 통합 테스트\n\n```bash\n# Phase 2 프로필로 시작\ncd docker && docker compose --profile=phase2 up -d\n\n# Policy Engine 활성화 확인\ncurl -X POST http://localhost:3000/api/v1/relay/direct \\\n  -H \"Content-Type: application/json\" \\\n  -H \"x-api-key: msq-dev-api-key-12345\" \\\n  -d '{\"to\": \"0xunwhitelisted...\", \"data\": \"0x...\"}' \\\n  | jq .\n# 예상: 403 Forbidden - Contract not whitelisted\n\n# Rate Limiting 테스트 (ab 또는 hey 사용)\nhey -n 200 -c 10 \\\n  -H \"x-api-key: msq-dev-api-key-12345\" \\\n  -m POST \\\n  -T \"application/json\" \\\n  -d '{\"to\": \"0x...\", \"data\": \"0x...\"}' \\\n  http://localhost:3000/api/v1/relay/direct\n# 예상: 429 응답 발생\n\n# Blacklist 테스트\ncurl -X POST http://localhost:3000/api/v1/relay/gasless \\\n  -H \"Content-Type: application/json\" \\\n  -H \"x-api-key: msq-dev-api-key-12345\" \\\n  -d '{\"request\": {\"from\": \"0xblacklisted...\", ...}, \"signature\": \"0x...\"}' \\\n  | jq .\n# 예상: 403 Forbidden - User is blacklisted\n```\n\n### 6. 테스트 커버리지 목표\n\n```bash\n# 단위 테스트 실행\npnpm --filter @msq-relayer/relay-api test\n\n# 커버리지 확인\npnpm --filter @msq-relayer/relay-api test:cov\n\n# 목표:\n# - policy/ 디렉토리 전체: >= 90% 커버리지\n# - Guards: >= 95% 커버리지 (보안 관련)\n# - Services: >= 90% 커버리지\n```\n\n### 7. 성능 테스트\n\n```bash\n# Rate Limiting이 활성화된 상태에서 성능 측정\nartillery run test/load/policy-load.yml\n\n# 예상 결과:\n# - P95 응답시간: < 100ms (Policy 검증 포함)\n# - Rate limit 초과 시: 즉시 429 반환 (< 10ms)\n# - Whitelist 검증: < 5ms (메모리 기반)\n```",
        "status": "pending",
        "dependencies": [
          "11"
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": "20",
        "title": "SPEC-ROUTING-001: Multi Relayer Smart Routing + Fire-and-Forget Pattern 구현",
        "description": "Nginx Load Balancer 기반 라우팅을 pending TX 기반 Smart Routing으로 대체하고, Fire-and-Forget 패턴으로 전환하여 SQS 메시지 보유 시간을 95% 단축합니다. 동시에 WebhooksService의 ozRelayerTxId lookup 버그를 수정하고 Hash 필드 업데이트 경쟁 조건을 방지합니다.",
        "details": "## 구현 개요\n\nSPEC-ROUTING-001은 기존 Nginx 기반 라우팅을 pending TX 기반 Smart Routing으로 대체하고, 폴링 방식을 제거한 Fire-and-Forget 패턴을 구현하여 처리 성능을 95% 향상시킵니다.\n\n## 현재 코드베이스 분석\n\n### 기존 아키텍처\n- **Webhook Service**: `packages/relay-api/src/webhooks/webhooks.service.ts` (Line 116: upsert 사용, `where: { id: transactionId }` - **버그 존재**)\n- **Consumer Service**: `packages/queue-consumer/src/consumer.service.ts` (폴링 기반 확인 로직 포함)\n- **Docker Compose**: `docker/docker-compose.yaml` (oz-relayer-1만 정의됨, relay-api는 Line 179에서 oz-relayer-1에만 의존)\n- **Prisma Schema**: `packages/relay-api/prisma/schema.prisma` (ozRelayerTxId 필드 존재, Line 31)\n\n## 5단계 구현 계획\n\n### Phase 1: Webhook Bug Fix (CRITICAL - 30-45분)\n\n**우선순위**: 🔴 HIGHEST (Fire-and-Forget 패턴은 Webhook에 전적으로 의존)\n\n**파일**: `packages/relay-api/src/webhooks/webhooks.service.ts`\n\n**변경사항**:\n```typescript\n// BEFORE (Line 116-133):\nconst updated = await this.prismaService.transaction.upsert({\n  where: { id: transactionId },  // BUG: OZ Relayer TX ID ≠ DB Primary Key\n  update: { status, hash, confirmedAt },\n  create: { id: transactionId, status, hash, ... }\n});\n\n// AFTER:\nconst updated = await this.prismaService.transaction.update({\n  where: { ozRelayerTxId: transactionId },  // FIXED\n  data: {\n    status,\n    hash: hash || undefined,\n    confirmedAt: confirmedAt ? new Date(confirmedAt) : undefined,\n  },\n});\n```\n\n**에러 처리 추가**:\n```typescript\ncatch (error) {\n  if (error.code === 'P2025') {  // Prisma \"Record not found\"\n    throw new NotFoundException(`Transaction not found: ${transactionId}`);\n  }\n  throw new InternalServerErrorException('Failed to update transaction');\n}\n```\n\n**단위 테스트 업데이트**: `packages/relay-api/src/webhooks/webhooks.service.spec.ts`\n- ozRelayerTxId 조회 검증\n- NotFoundException 테스트 추가\n\n---\n\n### Phase 2: Docker Infrastructure - Multi Relayer Setup (30-45분)\n\n**파일**: `docker/docker-compose.yaml`\n\n**작업 1**: oz-relayer-2, oz-relayer-3 서비스 추가 (oz-relayer-1 이후에 삽입)\n\n```yaml\noz-relayer-2:\n  <<: *relayer-common\n  ports:\n    - \"8082:8080\"\n    - \"8092:8081\"\n  volumes:\n    - ./config/oz-relayer/relayer-2.json:/app/config/config.json:ro\n    - ./keys/relayer-2:/app/config/keys:ro\n  environment:\n    <<: *relayer-env\n    API_KEY: ${OZ_RELAYER_API_KEY:-oz-relayer-shared-api-key-local-dev}\n\noz-relayer-3:\n  <<: *relayer-common\n  ports:\n    - \"8083:8080\"\n    - \"8093:8081\"\n  volumes:\n    - ./config/oz-relayer/relayer-3.json:/app/config/config.json:ro\n    - ./keys/relayer-3:/app/config/keys:ro\n  environment:\n    <<: *relayer-env\n    API_KEY: ${OZ_RELAYER_API_KEY:-oz-relayer-shared-api-key-local-dev}\n```\n\n**작업 2**: relay-api 의존성 업데이트 (Line 174-182 수정)\n\n```yaml\nrelay-api:\n  depends_on:\n    redis:\n      condition: service_healthy\n    mysql:\n      condition: service_healthy\n    oz-relayer-1:\n      condition: service_healthy\n    oz-relayer-2:\n      condition: service_healthy\n    oz-relayer-3:\n      condition: service_healthy\n    localstack:\n      condition: service_healthy\n```\n\n**검증**:\n```bash\ndocker compose up oz-relayer-1 oz-relayer-2 oz-relayer-3 -d\ndocker compose ps | grep oz-relayer  # 3개 모두 healthy 확인\n```\n\n---\n\n### Phase 3: Smart Routing Service Implementation (2-3시간)\n\n**신규 파일 생성**: `packages/queue-consumer/src/relay/relayer-router.service.ts`\n\n**핵심 로직**:\n```typescript\n@Injectable()\nexport class RelayerRouterService {\n  private readonly relayers: { url: string; relayerId: string }[];\n  private healthCache = new Map<string, { healthy: boolean; timestamp: number }>();\n  private readonly HEALTH_CACHE_TTL = 10000; // 10초\n\n  constructor(private configService: ConfigService) {\n    const urlsString = this.configService.get<string>('OZ_RELAYER_URLS');\n    this.relayers = urlsString.split(',').map((url, index) => ({\n      url: url.trim(),\n      relayerId: `relayer-${index + 1}`,\n    }));\n  }\n\n  /**\n   * Algorithm:\n   * 1. Query all relayers: GET /relayers/{id}\n   * 2. Filter unhealthy relayers (cached health check)\n   * 3. Select relayer with lowest numberOfPendingTransactions\n   * 4. Fallback to round-robin if all fail\n   */\n  async getAvailableRelayer(): Promise<string> {\n    // Parallel health checks + pending TX count queries\n    const relayerInfos = await Promise.allSettled(\n      this.relayers.map(async (relayer) => {\n        const healthy = await this.isHealthy(relayer.url);\n        if (!healthy) return null;\n\n        const response = await this.httpClient.get(\n          `${relayer.url}/relayers/${relayer.relayerId}`\n        );\n        return {\n          url: relayer.url,\n          numberOfPendingTransactions: response.data.numberOfPendingTransactions || 0,\n          healthy: true,\n        };\n      })\n    );\n\n    const healthyRelayers = relayerInfos\n      .filter(r => r.status === 'fulfilled' && r.value !== null)\n      .map(r => r.value);\n\n    if (healthyRelayers.length === 0) {\n      return this.roundRobinFallback();\n    }\n\n    // Select min pending TX count\n    const selected = healthyRelayers.reduce((min, curr) =>\n      curr.numberOfPendingTransactions < min.numberOfPendingTransactions ? curr : min\n    );\n\n    return selected.url;\n  }\n\n  private async isHealthy(url: string): Promise<boolean> {\n    // 10-second cache implementation\n  }\n\n  private roundRobinFallback(): string {\n    // Round-robin fallback implementation\n  }\n}\n```\n\n**Module 등록**: `packages/queue-consumer/src/consumer.module.ts`\n\n```typescript\n@Module({\n  providers: [\n    ConsumerService,\n    RelayerRouterService,  // 추가\n    // ... existing providers\n  ],\n})\n```\n\n**환경 변수 추가**: `docker/docker-compose.yaml` (queue-consumer 서비스)\n\n```yaml\nqueue-consumer:\n  environment:\n    OZ_RELAYER_URLS: http://oz-relayer-1:8080,http://oz-relayer-2:8080,http://oz-relayer-3:8080\n    OZ_RELAYER_API_KEY: ${OZ_RELAYER_API_KEY:-oz-relayer-shared-api-key-local-dev}\n```\n\n**단위 테스트**: `packages/queue-consumer/src/relay/relayer-router.service.spec.ts`\n- Smart routing 로직 (12 테스트)\n- Health check caching (10초 TTL)\n- Round-robin fallback\n\n---\n\n### Phase 4: Fire-and-Forget Pattern Implementation (2-3시간)\n\n**작업 1**: OzRelayerClient에 비동기 메서드 추가\n\n**파일**: `packages/queue-consumer/src/relay/oz-relayer.client.ts`\n\n```typescript\n/**\n * Fire-and-Forget: NO polling for confirmation\n */\nasync sendDirectTransactionAsync(\n  request: DirectTxRequest,\n  relayerUrl: string\n): Promise<{ transactionId: string; status: string }> {\n  const response = await this.httpClient.post(`${relayerUrl}/transactions`, {\n    to: request.to,\n    data: request.data,\n    value: request.value || '0',\n    gasLimit: request.gasLimit,\n    speed: request.speed || 'fast',\n  });\n\n  return {\n    transactionId: response.data.transactionId,\n    status: response.data.status || 'pending',\n  };\n}\n\nasync sendGaslessTransactionAsync(\n  request: GaslessTxRequest,\n  forwarderAddress: string,\n  relayerUrl: string\n): Promise<{ transactionId: string; status: string }> {\n  // Similar implementation for gasless\n}\n```\n\n**작업 2**: ConsumerService 업데이트\n\n**파일**: `packages/queue-consumer/src/consumer.service.ts` (Line 128-end 수정)\n\n```typescript\nprivate async handleMessage(message: any): Promise<void> {\n  const { MessageId, Body, ReceiptHandle } = message;\n  const messageBody: QueueMessage = JSON.parse(Body);\n  const { transactionId, type } = messageBody;\n\n  // Idempotency check\n  const transaction = await this.prisma.transaction.findUnique({\n    where: { id: transactionId },\n  });\n\n  if (transaction?.ozRelayerTxId) {\n    this.logger.log(`TX already submitted (${transaction.ozRelayerTxId}), skipping`);\n    // Fire-and-Forget: Webhook handles status update\n    await this.sqsAdapter.deleteMessage(ReceiptHandle);\n    return;\n  }\n\n  // Smart Routing\n  const relayerUrl = await this.relayerRouter.getAvailableRelayer();\n\n  // Fire-and-Forget TX submission\n  let result: { transactionId: string; status: string };\n  if (type === 'direct') {\n    result = await this.relayerClient.sendDirectTransactionAsync(\n      messageBody.request,\n      relayerUrl\n    );\n  } else {\n    result = await this.relayerClient.sendGaslessTransactionAsync(\n      messageBody.request,\n      messageBody.forwarderAddress,\n      relayerUrl\n    );\n  }\n\n  // Save ozRelayerTxId + ozRelayerUrl immediately\n  // CRITICAL: Do NOT set hash here (Webhook is single source of truth)\n  await this.prisma.transaction.update({\n    where: { id: transactionId },\n    data: {\n      status: 'submitted',  // NOT 'confirmed'\n      ozRelayerTxId: result.transactionId,\n      ozRelayerUrl: relayerUrl,  // Track which relayer handled this\n      // hash is OMITTED - only Webhook updates hash (prevents race condition)\n      result,\n    },\n  });\n\n  // Delete SQS message immediately (fire-and-forget)\n  await this.sqsAdapter.deleteMessage(ReceiptHandle);\n}\n```\n\n**작업 3**: Prisma Schema 업데이트\n\n**파일**: `packages/relay-api/prisma/schema.prisma`\n\n```prisma\nmodel Transaction {\n  // ... existing fields\n  ozRelayerTxId String?   @unique @map(\"oz_relayer_tx_id\")\n  ozRelayerUrl  String?   @map(\"oz_relayer_url\")  // NEW: Track relayer\n  // ... rest\n}\n```\n\n**Migration 실행**:\n```bash\npnpm exec prisma migrate dev --name add_oz_relayer_url\n```\n\n---\n\n### Phase 5: Hash Field Race Condition Prevention (Phase 4에 포함)\n\n**문제 분석**:\n```\nConsumer (polling)  → updates hash field\nWebhook (async)     → updates hash field\n                     ↓ Race Condition!\n```\n\n**해결책**: Webhook이 hash의 단일 소스\n\n| Component | ozRelayerTxId | hash | status |\n|-----------|--------------|------|--------|\n| Consumer | ✅ YES | ❌ NO | `submitted` |\n| Webhook | ❌ NO | ✅ YES | `confirmed`/`failed` |\n\n**검증 포인트**:\n- Consumer는 hash 필드를 절대 업데이트하지 않음\n- Webhook만 hash 필드 업데이트\n- 경쟁 조건 완전 방지\n\n---\n\n## 기술 스택 통합\n\n### 기존 사용 중인 기술\n- NestJS (relay-api, queue-consumer)\n- Prisma ORM (MySQL)\n- Redis (cache)\n- AWS SQS (LocalStack 에뮬레이션)\n- OZ Relayer v1.3.0\n- Docker Compose\n\n### 신규 의존성\n- **없음** (기존 패키지 사용)\n\n---\n\n## 성능 지표\n\n- Smart Routing: Relayer 선택 <100ms\n- Fire-and-Forget: SQS 메시지 삭제 <1초 (기존 60초 → 95% 단축)\n- Webhook 처리: <200ms (MySQL + Redis 업데이트)\n- Health Check Cache: 10초 TTL (API 호출 90% 감소)\n- Throughput: 최소 10 messages/sec (3 relayers)\n\n---\n\n## 위험 요소 및 대응\n\n1. **Webhook 실패 시 TX 상태 누락**\n   - 대응: OZ Relayer는 자동 재시도 (최대 3회)\n   - 백업: Consumer 로그에 ozRelayerTxId 저장 → 수동 조회 가능\n\n2. **Smart Router에서 모든 Relayer 실패**\n   - 대응: Round-robin fallback 구현\n   - 로그: 경고 로그 + 모니터링 알림\n\n3. **Hash 필드 경쟁 조건**\n   - 대응: Consumer는 hash 업데이트 금지 (단일 소스: Webhook)\n\n---\n\n## 구현 체크리스트\n\nPhase 1:\n- [ ] WebhooksService.updateMysql() 메서드 수정 (upsert → update)\n- [ ] ozRelayerTxId 조회로 변경 (where: { id } → where: { ozRelayerTxId })\n- [ ] NotFoundException 에러 처리 추가\n- [ ] webhooks.service.spec.ts 단위 테스트 업데이트\n\nPhase 2:\n- [ ] docker-compose.yaml에 oz-relayer-2, oz-relayer-3 추가\n- [ ] relay-api depends_on에 oz-relayer-2, oz-relayer-3 추가\n- [ ] docker compose up으로 3개 relayer 모두 healthy 확인\n\nPhase 3:\n- [ ] RelayerRouterService 클래스 생성 및 구현\n- [ ] Smart routing 로직 구현 (pending TX 기반)\n- [ ] Health check 캐싱 (10초 TTL)\n- [ ] Round-robin fallback 구현\n- [ ] consumer.module.ts에 provider 등록\n- [ ] queue-consumer 환경 변수 추가 (OZ_RELAYER_URLS)\n- [ ] relayer-router.service.spec.ts 단위 테스트 (12 tests)\n\nPhase 4:\n- [ ] OzRelayerClient에 sendDirectTransactionAsync() 추가\n- [ ] OzRelayerClient에 sendGaslessTransactionAsync() 추가\n- [ ] ConsumerService.handleMessage() 메서드 수정\n- [ ] Smart Router 통합\n- [ ] Fire-and-Forget 로직 구현 (폴링 제거)\n- [ ] Consumer는 hash 필드 업데이트 제거 (Webhook only)\n- [ ] ozRelayerUrl 필드 저장 추가\n- [ ] Prisma Schema에 ozRelayerUrl 필드 추가\n- [ ] Migration 생성 및 실행\n- [ ] consumer.service.spec.ts 단위 테스트 업데이트 (+8 tests)\n- [ ] oz-relayer.client.spec.ts 단위 테스트 업데이트 (+6 tests)\n\nPhase 5:\n- [ ] Consumer 코드에서 hash 필드 업데이트 완전 제거 확인\n- [ ] Webhook만 hash 업데이트하는지 검증\n- [ ] Race condition 방지 테스트\n\n통합 테스트:\n- [ ] E2E: Smart Routing 시나리오 (R1=10, R2=5, R3=20 → R2 선택)\n- [ ] E2E: Fire-and-Forget 시나리오 (즉시 SQS 삭제)\n- [ ] E2E: Webhook 업데이트 시나리오 (ozRelayerTxId 조회)\n- [ ] E2E: Idempotency 시나리오 (중복 메시지 처리)\n- [ ] 부하 테스트: 100 TXs/second with 3 relayers\n\n문서화:\n- [ ] CHANGELOG.md 업데이트\n- [ ] API 문서 업데이트 (필요 시)\n- [ ] README.md 환경 변수 설명 추가",
        "testStrategy": "## 테스트 전략\n\n### 1. 단위 테스트 (≥90% 커버리지)\n\n#### 1.1 RelayerRouterService 테스트 (12 tests)\n\n**파일**: `packages/queue-consumer/src/relay/relayer-router.service.spec.ts`\n\n```typescript\ndescribe('RelayerRouterService', () => {\n  // Smart routing logic\n  it('should select relayer with lowest pending TX count', async () => {\n    // Given: R1=10, R2=5, R3=20\n    // When: getAvailableRelayer()\n    // Then: Returns R2 URL\n  });\n\n  it('should skip unhealthy relayers', async () => {\n    // Given: R1 healthy (10), R2 unhealthy, R3 healthy (5)\n    // When: getAvailableRelayer()\n    // Then: Returns R3 URL\n  });\n\n  // Health check caching\n  it('should cache health status for 10 seconds', async () => {\n    // Given: Health check succeeds\n    // When: Called twice within 10s\n    // Then: Only 1 HTTP request made\n  });\n\n  it('should refresh health cache after TTL expires', async () => {\n    // Given: Health check cached\n    // When: 11 seconds passed\n    // Then: New HTTP request made\n  });\n\n  // Round-robin fallback\n  it('should use round-robin when all relayers unhealthy', async () => {\n    // Given: All health checks fail\n    // When: getAvailableRelayer() called 3 times\n    // Then: R1, R2, R3 순서로 반환\n  });\n\n  // Error handling\n  it('should handle API timeout gracefully', async () => {\n    // Given: GET /relayers/{id} timeout (>500ms)\n    // When: getAvailableRelayer()\n    // Then: Skip that relayer, select from others\n  });\n\n  // Environment configuration\n  it('should parse OZ_RELAYER_URLS correctly', async () => {\n    // Given: OZ_RELAYER_URLS=\"http://r1:8080,http://r2:8080,http://r3:8080\"\n    // When: Constructor called\n    // Then: 3 relayers initialized with correct URLs\n  });\n\n  it('should throw error when OZ_RELAYER_URLS not set', () => {\n    // Given: OZ_RELAYER_URLS undefined\n    // When: Constructor called\n    // Then: Throws configuration error\n  });\n\n  // Concurrent requests\n  it('should handle parallel getAvailableRelayer calls', async () => {\n    // Given: 5 concurrent calls\n    // When: All resolve\n    // Then: All return valid relayer URLs\n  });\n\n  // Edge cases\n  it('should handle zero pending transactions', async () => {\n    // Given: All relayers have 0 pending\n    // When: getAvailableRelayer()\n    // Then: Returns first relayer\n  });\n\n  it('should handle negative pending count (invalid response)', async () => {\n    // Given: API returns numberOfPendingTransactions=-1\n    // When: getAvailableRelayer()\n    // Then: Treats as 0 and selects normally\n  });\n\n  it('should recover from temporary network failures', async () => {\n    // Given: First call fails, second succeeds\n    // When: getAvailableRelayer() called twice\n    // Then: Second call returns valid relayer\n  });\n});\n```\n\n#### 1.2 ConsumerService 테스트 업데이트 (+8 tests)\n\n**파일**: `packages/queue-consumer/src/consumer.service.spec.ts`\n\n```typescript\ndescribe('ConsumerService - Fire-and-Forget', () => {\n  it('should submit TX using smart router', async () => {\n    // Given: Smart router returns R2\n    // When: handleMessage() called\n    // Then: sendDirectTransactionAsync() called with R2 URL\n  });\n\n  it('should save ozRelayerTxId immediately after submission', async () => {\n    // Given: OZ Relayer returns {transactionId: \"oz-123\"}\n    // When: TX submitted\n    // Then: MySQL updated with ozRelayerTxId=\"oz-123\", status=\"submitted\"\n  });\n\n  it('should save ozRelayerUrl for tracking', async () => {\n    // Given: TX submitted to http://oz-relayer-2:8080\n    // When: TX saved\n    // Then: ozRelayerUrl=\"http://oz-relayer-2:8080\"\n  });\n\n  it('should NOT update hash field in Consumer', async () => {\n    // Given: OZ Relayer response contains transactionId\n    // When: TX saved\n    // Then: hash field remains null (Webhook updates this)\n  });\n\n  it('should delete SQS message immediately (fire-and-forget)', async () => {\n    // Given: TX submission successful\n    // When: ozRelayerTxId saved\n    // Then: deleteMessage() called immediately\n  });\n\n  it('should skip re-submission if ozRelayerTxId exists (idempotency)', async () => {\n    // Given: TX with ozRelayerTxId=\"oz-123\"\n    // When: Duplicate SQS message received\n    // Then: sendDirectTransactionAsync() NOT called\n    // And: deleteMessage() called immediately\n  });\n\n  it('should mark status as \"submitted\" not \"confirmed\"', async () => {\n    // Given: TX submitted to OZ Relayer\n    // When: MySQL updated\n    // Then: status=\"submitted\" (Webhook changes to \"confirmed\")\n  });\n\n  it('should handle smart router failures with retry', async () => {\n    // Given: Smart router fails on first call\n    // When: handleMessage() called\n    // Then: Message not deleted (SQS retries)\n  });\n});\n```\n\n#### 1.3 WebhooksService 테스트 업데이트 (+3 tests)\n\n**파일**: `packages/relay-api/src/webhooks/webhooks.service.spec.ts`\n\n```typescript\ndescribe('WebhooksService - Bug Fix', () => {\n  it('should query using ozRelayerTxId field', async () => {\n    // Given: Webhook payload {transactionId: \"oz-123\"}\n    // When: handleWebhook() called\n    // Then: transaction.update({ where: { ozRelayerTxId: \"oz-123\" } })\n  });\n\n  it('should throw NotFoundException when TX not found', async () => {\n    // Given: ozRelayerTxId=\"oz-nonexistent\"\n    // When: handleWebhook() called\n    // Then: Prisma error P2025 caught\n    // And: NotFoundException thrown\n  });\n\n  it('should NOT create new TX record (update only)', async () => {\n    // Given: TX with ozRelayerTxId does not exist\n    // When: handleWebhook() called\n    // Then: Prisma update() fails (not upsert)\n    // And: NotFoundException thrown\n  });\n});\n```\n\n#### 1.4 OzRelayerClient 테스트 업데이트 (+6 tests)\n\n**파일**: `packages/queue-consumer/src/relay/oz-relayer.client.spec.ts`\n\n```typescript\ndescribe('OzRelayerClient - Fire-and-Forget', () => {\n  it('should submit direct TX without polling', async () => {\n    // Given: Direct TX request\n    // When: sendDirectTransactionAsync() called\n    // Then: POST /transactions called\n    // And: Returns {transactionId, status}\n    // And: pollForConfirmation() NOT called\n  });\n\n  it('should submit gasless TX without polling', async () => {\n    // Given: Gasless TX request\n    // When: sendGaslessTransactionAsync() called\n    // Then: POST /transactions with encoded request\n    // And: Returns {transactionId, status}\n    // And: pollForConfirmation() NOT called\n  });\n\n  it('should use provided relayerUrl', async () => {\n    // Given: relayerUrl=\"http://oz-relayer-2:8080\"\n    // When: sendDirectTransactionAsync() called\n    // Then: POST http://oz-relayer-2:8080/transactions\n  });\n\n  it('should handle OZ Relayer API errors', async () => {\n    // Given: POST /transactions returns 500\n    // When: sendDirectTransactionAsync() called\n    // Then: Throws error\n  });\n\n  it('should set default speed to \"fast\"', async () => {\n    // Given: Request without speed field\n    // When: sendDirectTransactionAsync() called\n    // Then: Request body includes speed=\"fast\"\n  });\n\n  it('should preserve custom speed value', async () => {\n    // Given: Request with speed=\"slow\"\n    // When: sendDirectTransactionAsync() called\n    // Then: Request body includes speed=\"slow\"\n  });\n});\n```\n\n---\n\n### 2. 통합 테스트 (E2E)\n\n#### 2.1 Smart Routing with Load Balancing\n\n**파일**: `packages/queue-consumer/test/e2e/smart-routing.e2e-spec.ts`\n\n```typescript\nit('should select least busy relayer', async () => {\n  // Given: 3 OZ Relayers running\n  // When: R1 pending=10, R2 pending=5, R3 pending=20\n  // Then: Consumer receives TX from SQS\n  // And: Smart Router selects R2\n  // And: TX submitted to R2\n  // And: SQS message deleted within 1 second\n});\n\nit('should fallback to round-robin when all unhealthy', async () => {\n  // Given: All 3 relayers report unhealthy\n  // When: Consumer receives 3 TXs\n  // Then: TXs distributed R1, R2, R3 순서로\n});\n\nit('should skip unhealthy relayers', async () => {\n  // Given: R2 unhealthy (health check fails)\n  // When: Consumer receives TX\n  // Then: Smart Router skips R2\n  // And: Selects from R1 or R3\n});\n```\n\n#### 2.2 Fire-and-Forget Pattern\n\n**파일**: `packages/queue-consumer/test/e2e/fire-and-forget.e2e-spec.ts`\n\n```typescript\nit('should delete SQS message immediately after submission', async () => {\n  // Given: Consumer receives TX message\n  // When: TX submitted to OZ Relayer\n  // Then: ozRelayerTxId saved to MySQL\n  // And: SQS message deleted within 1 second\n  // And: Consumer does NOT poll for confirmation\n});\n\nit('should NOT update hash field in Consumer', async () => {\n  // Given: TX submitted to OZ Relayer\n  // When: MySQL transaction queried\n  // Then: ozRelayerTxId=\"oz-123\"\n  // And: status=\"submitted\"\n  // And: hash=null (Webhook will set this)\n});\n\nit('should save ozRelayerUrl for debugging', async () => {\n  // Given: TX submitted to http://oz-relayer-2:8080\n  // When: MySQL transaction queried\n  // Then: ozRelayerUrl=\"http://oz-relayer-2:8080\"\n});\n```\n\n#### 2.3 Webhook Updates TX Status\n\n**파일**: `packages/relay-api/test/e2e/webhook-update.e2e-spec.ts`\n\n```typescript\nit('should update TX using ozRelayerTxId lookup', async () => {\n  // Given: TX exists with ozRelayerTxId=\"oz-123\", status=\"submitted\", hash=null\n  // When: Webhook receives {transactionId: \"oz-123\", status: \"confirmed\", hash: \"0xabc\"}\n  // Then: WebhooksService queries WHERE ozRelayerTxId=\"oz-123\"\n  // And: TX updated: status=\"confirmed\", hash=\"0xabc\"\n  // And: Webhook returns 200 OK\n});\n\nit('should return 404 when TX not found', async () => {\n  // Given: Webhook payload {transactionId: \"oz-nonexistent\"}\n  // When: POST /webhooks/oz-relayer\n  // Then: 404 Not Found\n  // And: Error message: \"Transaction not found: oz-nonexistent\"\n});\n\nit('should update Redis cache after MySQL update', async () => {\n  // Given: Webhook updates TX status\n  // When: Redis queried with key \"tx:status:oz-123\"\n  // Then: Cache contains {status: \"confirmed\", hash: \"0xabc\"}\n  // And: TTL reset to 600 seconds\n});\n```\n\n#### 2.4 Idempotent TX Processing\n\n**파일**: `packages/queue-consumer/test/e2e/idempotency.e2e-spec.ts`\n\n```typescript\nit('should skip re-submission if ozRelayerTxId exists', async () => {\n  // Given: TX already submitted with ozRelayerTxId=\"oz-123\"\n  // When: Consumer receives duplicate SQS message\n  // Then: Consumer detects ozRelayerTxId exists\n  // And: Consumer deletes SQS message immediately\n  // And: Consumer does NOT call OZ Relayer API\n  // And: Webhook handles status update\n});\n\nit('should handle SQS at-least-once delivery', async () => {\n  // Given: SQS delivers same message twice (at-least-once guarantee)\n  // When: First message processed (TX submitted, ozRelayerTxId saved)\n  // And: Second message received\n  // Then: Second message immediately deleted (idempotent)\n  // And: No duplicate TX submission\n});\n```\n\n---\n\n### 3. 성능 테스트\n\n#### 3.1 Smart Router Performance\n\n```bash\n# Health check 캐싱 검증\n# 10초 내 동일 relayer 호출 시 캐시 사용 확인\ntime pnpm run test:e2e -- smart-router-cache.e2e-spec.ts\n\n# 예상: First call ~100ms, Subsequent calls <10ms (cached)\n```\n\n#### 3.2 Fire-and-Forget Efficiency\n\n```bash\n# SQS 메시지 보유 시간 측정\n# 기존: ~60초 (폴링 포함)\n# 목표: <3초 (즉시 삭제)\npnpm run test:e2e -- fire-and-forget-timing.e2e-spec.ts\n\n# 예상 결과:\n# - TX 제출: ~500ms\n# - MySQL 업데이트: ~50ms\n# - SQS 삭제: ~100ms\n# - Total: <1초\n```\n\n#### 3.3 Webhook Processing Speed\n\n```bash\n# Webhook 처리 시간 측정\n# 목표: <200ms (MySQL + Redis 업데이트)\npnpm run test:e2e -- webhook-performance.e2e-spec.ts\n\n# 예상 결과:\n# - MySQL update: ~80ms\n# - Redis update: ~20ms\n# - Notification: ~50ms (non-blocking)\n# - Total: <150ms\n```\n\n#### 3.4 Load Testing\n\n```bash\n# 100 TXs/second 처리 능력 검증\n# 3 relayers, 각각 ~33 TXs/sec 처리\nk6 run scripts/load-test.js\n\n# Target:\n# - Success rate: >99%\n# - P95 latency: <2초\n# - Relayer distribution: R1 33%, R2 33%, R3 34%\n```\n\n---\n\n### 4. 사전 조건 검증\n\n```bash\n# Docker 인프라 실행 확인\ncd docker && docker compose ps\n\n# 모든 서비스 healthy 확인:\n# - hardhat-node (8545)\n# - redis (6379)\n# - mysql (3307)\n# - localstack (4566)\n# - oz-relayer-1 (8081)\n# - oz-relayer-2 (8082)\n# - oz-relayer-3 (8083)\n# - relay-api (8080)\n# - queue-consumer\n\n# 각 relayer가 다른 private key 사용하는지 확인\ndocker exec oz-relayer-1 cat /app/config/config.json | grep keystorePath\ndocker exec oz-relayer-2 cat /app/config/config.json | grep keystorePath\ndocker exec oz-relayer-3 cat /app/config/config.json | grep keystorePath\n\n# 예상:\n# - relayer-1: /app/config/keys/relayer-1/keystore.json\n# - relayer-2: /app/config/keys/relayer-2/keystore.json\n# - relayer-3: /app/config/keys/relayer-3/keystore.json\n```\n\n---\n\n### 5. 테스트 실행 순서\n\n```bash\n# Phase 1 검증: Webhook Bug Fix\npnpm --filter @msq-relayer/relay-api run test -- webhooks.service.spec.ts\n\n# Phase 2 검증: Docker Infrastructure\ndocker compose up oz-relayer-1 oz-relayer-2 oz-relayer-3 -d\ncurl http://localhost:8081/health\ncurl http://localhost:8082/health\ncurl http://localhost:8083/health\n\n# Phase 3 검증: Smart Routing\npnpm --filter @msq-relayer/queue-consumer run test -- relayer-router.service.spec.ts\n\n# Phase 4 검증: Fire-and-Forget\npnpm --filter @msq-relayer/queue-consumer run test -- consumer.service.spec.ts\npnpm --filter @msq-relayer/queue-consumer run test -- oz-relayer.client.spec.ts\n\n# Phase 5 검증: E2E 전체 시나리오\npnpm run test:e2e -- smart-routing.e2e-spec.ts\npnpm run test:e2e -- fire-and-forget.e2e-spec.ts\npnpm run test:e2e -- webhook-update.e2e-spec.ts\npnpm run test:e2e -- idempotency.e2e-spec.ts\n\n# 성능 테스트\npnpm run test:e2e -- performance.e2e-spec.ts\n\n# 부하 테스트\nk6 run scripts/load-test.js\n```\n\n---\n\n### 6. 회귀 테스트\n\n```bash\n# 기존 기능 정상 동작 확인\npnpm --filter @msq-relayer/relay-api run test:cov\npnpm --filter @msq-relayer/queue-consumer run test:cov\n\n# 커버리지 목표: ≥90%\n```\n\n---\n\n### 7. 수동 검증 시나리오\n\n#### Scenario 1: Smart Routing 동작 확인\n\n```bash\n# 1. R1, R2, R3의 pending TX 상태 조회\ncurl -H \"Authorization: Bearer oz-relayer-shared-api-key-local-dev\" \\\n  http://localhost:8081/relayers/relayer-1\n\ncurl -H \"Authorization: Bearer oz-relayer-shared-api-key-local-dev\" \\\n  http://localhost:8082/relayers/relayer-2\n\ncurl -H \"Authorization: Bearer oz-relayer-shared-api-key-local-dev\" \\\n  http://localhost:8083/relayers/relayer-3\n\n# 2. TX 전송\ncurl -X POST http://localhost:8080/api/v1/relay/direct \\\n  -H \"Content-Type: application/json\" \\\n  -H \"X-Api-Key: local-dev-api-key\" \\\n  -d '{\n    \"to\": \"0x...\",\n    \"data\": \"0x...\",\n    \"value\": \"0\",\n    \"gasLimit\": \"100000\"\n  }'\n\n# 3. queue-consumer 로그 확인\ndocker logs queue-consumer | grep \"Selected relayer\"\n# 예상: \"Selected relayer-2 (http://oz-relayer-2:8080) with 5 pending TXs\"\n```\n\n#### Scenario 2: Fire-and-Forget 검증\n\n```bash\n# 1. TX 전송\nTX_ID=$(curl -X POST http://localhost:8080/api/v1/relay/direct ... | jq -r '.transactionId')\n\n# 2. MySQL에서 즉시 확인 (ozRelayerTxId 존재, hash=null, status=submitted)\ndocker exec mysql mysql -u root -ppass -e \\\n  \"SELECT id, ozRelayerTxId, ozRelayerUrl, status, hash FROM msq_relayer.transactions WHERE id='$TX_ID';\"\n\n# 예상 결과:\n# ozRelayerTxId: oz-xxx\n# ozRelayerUrl: http://oz-relayer-2:8080\n# status: submitted\n# hash: NULL\n\n# 3. 5초 대기 후 Webhook 업데이트 확인 (hash 채워짐, status=confirmed)\nsleep 5\ndocker exec mysql mysql -u root -ppass -e \\\n  \"SELECT id, ozRelayerTxId, status, hash FROM msq_relayer.transactions WHERE id='$TX_ID';\"\n\n# 예상 결과:\n# status: confirmed\n# hash: 0xabc...\n```\n\n#### Scenario 3: Webhook Bug Fix 검증\n\n```bash\n# 1. Webhook 직접 호출 (잘못된 transactionId)\ncurl -X POST http://localhost:8080/api/v1/webhooks/oz-relayer \\\n  -H \"Content-Type: application/json\" \\\n  -H \"X-OZ-Signature: test-signature\" \\\n  -d '{\n    \"transactionId\": \"oz-nonexistent\",\n    \"status\": \"confirmed\",\n    \"hash\": \"0xabc\"\n  }'\n\n# 예상 응답: 404 Not Found\n# {\"statusCode\":404,\"message\":\"Transaction not found: oz-nonexistent\"}\n\n# 2. Webhook 정상 호출 (올바른 ozRelayerTxId)\ncurl -X POST http://localhost:8080/api/v1/webhooks/oz-relayer \\\n  -H \"Content-Type: application/json\" \\\n  -H \"X-OZ-Signature: test-signature\" \\\n  -d '{\n    \"transactionId\": \"oz-xxx\",\n    \"status\": \"confirmed\",\n    \"hash\": \"0xdef\"\n  }'\n\n# 예상 응답: 200 OK\n# {\"success\":true,\"message\":\"Webhook processed successfully\",\"transactionId\":\"oz-xxx\"}\n```\n\n---\n\n### 8. 성공 기준\n\n- [ ] **Phase 1**: WebhooksService 단위 테스트 통과 (3 tests)\n- [ ] **Phase 2**: 3개 relayers 모두 healthy 상태\n- [ ] **Phase 3**: RelayerRouterService 단위 테스트 통과 (12 tests)\n- [ ] **Phase 4**: Consumer + OzRelayerClient 단위 테스트 통과 (14 tests)\n- [ ] **E2E**: 4개 시나리오 모두 통과 (Smart Routing, Fire-and-Forget, Webhook, Idempotency)\n- [ ] **Performance**: Smart Router <100ms, SQS 삭제 <1초, Webhook <200ms\n- [ ] **Load Test**: 100 TXs/sec, 99% 성공률\n- [ ] **Coverage**: ≥90% (단위 테스트 + 통합 테스트)\n- [ ] **회귀 테스트**: 기존 기능 모두 정상 동작",
        "status": "done",
        "dependencies": [
          "14",
          "15"
        ],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2026-01-27T03:37:52.758Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2026-01-27T03:37:52.759Z",
      "taskCount": 20,
      "completedCount": 14,
      "tags": [
        "master"
      ]
    }
  }
}